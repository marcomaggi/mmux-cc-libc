\input texinfo.tex
@c %**start of header
@setfilename mmux-cc-libc.info
@settitle MMUX CC Types
@c %**end of header

@c @include version.texi
@include mmux-version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX CC Libc

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX CC Libc

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-cc-libc

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024, 2025

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_CC_LIBC
@set PackagePkgconfigModule             mmux-cc-libc
@set PackageLibsVar                     @env{MMUX_CC_LIBC_LIBS}
@set PackageCflagsVar                   @env{MMUX_CC_LIBC_CFLAGS}
@c This is the stem of the library in "libmmux-cc-libc.so".
@set PackageLibstem                     mmux-cc-libc
@set PackageApiPrefixLower              mmux_libc_
@set PackageApiPrefixUpper              MMUX_LIBC_

@set PackageHeader                      mmux-cc-libc.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@macro mmuxcctypesref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,mmux-cc-types}
@end macro

@macro MmuxCFuncpage{FUNCNAME}
@ref{\FUNCNAME\,\FUNCNAME\,\FUNCNAME\,*manpages*}
@end macro

@macro MmuxCStruct{NAME}
@code{struct \NAME\}
@end macro

@macro MmuxCInterfaceTwo{FUNCNAME,MANPAGE}
Interface to the function @cfunc{\FUNCNAME\}, @MmuxCFuncpage{\MANPAGE\}
@end macro

@macro MmuxCInterface{FUNCNAME}
@MmuxCInterfaceTwo{\FUNCNAME\,\FUNCNAME\}
@end macro

@macro MmuxCInterfaceGlibc{FUNCNAME,GLIBCNODENAME}
Interface to the function @cfunc{\FUNCNAME\}, @glibcref{\GLIBCNODENAME\,\GLIBCNODENAME\}
@end macro

@macro MmuxCMacroInterfaceTwo{FUNCNAME,MANPAGE}
Interface to the preprocessor macro @cfunc{\FUNCNAME\}, @MmuxCFuncpage{\MANPAGE\}
@end macro

@macro MmuxCMacroInterface{FUNCNAME}
@MmuxCMacroInterfaceTwo{\FUNCNAME\,\FUNCNAME\}
@end macro

@c ------------------------------------------------------------------------

@macro MmuxCStructOpaqueTypedef{STRUCTNAME}
@deftp {Opaque Struct Typedef} mmux_libc_\STRUCTNAME\_t
An opaque alias for @MmuxCStruct{\STRUCTNAME\}.
@end deftp

@end macro

@macro MmuxCStructPointerOpaqueTypedef{STRUCTNAME}
@deftp {Opaque Struct Pointer Typedef} mmux_libc_\STRUCTNAME\_ptr_t
An opaque alias for @code{mmux_libc_\STRUCTNAME\_t *}.
@end deftp

@end macro

@macro MmuxSetterGetter{STRUCTNAME, FIELDNAME, FIELDTYPE}
@deftypefun bool mmux_libc_\FIELDNAME\_set (mmux_libc_\STRUCTNAME\_t * @var{\STRUCTNAME\_p}, \FIELDTYPE\ @var{\FIELDNAME\})
@deftypefunx bool mmux_libc_\FIELDNAME\_ref (\FIELDTYPE\ * @var{result_p}, mmux_libc_\STRUCTNAME\_t const * @var{\STRUCTNAME\_p})
Setter and getter for the field @code{\FIELDNAME\} of @objtype{mmux_libc_\STRUCTNAME\_t}.
@end deftypefun

@end macro


@macro MmuxStructDumper{STRUCTNAME}
@MmuxStructDumperTwo{\STRUCTNAME\,struct \STRUCTNAME\}
@end macro


@macro MmuxStructDumperTwo{STRUCTNAME,STRUCTTYPE}
@deftypefun bool mmux_libc_\STRUCTNAME\_dump (mmux_libc_fd_arg_t @var{fd}, mmux_libc_\STRUCTNAME\_t const * @var{struct_p}, mmux_asciizcp_t @var{struct_name})
Write to @var{fd} a description of the fields of the @MmuxCStruct{\STRUCTNAME\} referenced by
@var{struct_p}.  @var{struct_name} must be a pointer to an @MmuxAsciiZ{} string representing the name of
the data structure used in the description; when @cnull{}: it defaults to @samp{\STRUCTTYPE\}.
@end deftypefun

@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C23 library,
with @gnu{} C Compiler extensions, which implements a uniform @api{} to the @posix{} library
functions and some Linux extensions.  A possible use of the library is in foreign functions
interfaces for higher--level languages.

The package targets @posix{} platforms.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{MmuxPkgSemanticVersion}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-cc-libc: (mmux-cc-libc).       C11 language library wrapper for the @gnu{} C Library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* constants::                   Constants.
* version::                     Version functions.
* initialisation::              Library initialisation.
* errors::                      Errors management.
* memory::                      Memory management.
* strings::                     String operations.
* characters::                  Character operations.
* time::                        Times and dates.
* system::                      System configuration.
* persona::                     Persona operations.
* processes::                   Processes.
* signals::                     Interprocess signals handling.
* fds::                         File descriptors.
* fs::                          File system.
* sockets::                     Networking sockets.
* interface specifications::    Interface specifications.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C23 library,
with @gnu{} C Compiler extensions, which implements a uniform @api{} to the @posix{} library
functions and some Linux extensions.  A possible use of the library is in foreign functions
interfaces for higher--level languages.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs multiple header files, of which @value{PackageHeaderFile} is the main one,
exporting the whole library @api{}.  All the function names in the @api{} are prefixed with
@code{@value{PackageApiPrefixLower}}; all the preprocessor symbol names are prefixed with
@code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

The library is installed under @code{$libdir}; for example:

@example
/usr/local/lib64/lib@value{PackageLibstem}.so
@end example

@noindent
C language header files are installed under @code{$includedir}, for example:

@example
/usr/local/include/@value{PackageHeaderFile}
@end example

Before using the library, we must initialise it by calling the appropriate function:

@example
mmux_cc_libc_init();
@end example

@menu
* overview stems::              Specifying C language types with their stem.
* overview errors::             Error handling.
* overview results::            Results handling.
* overview linking::            Linking code with the shared library.
@end menu

@c page
@node overview stems
@section Specifying C language types with their stem


@value{PACKAGE} uses the type definitions of the external package @emph{@mmux{} CC Types},
@mmuxcctypesref{overview stems, Specifying C language types with their stem}.

@c page
@node overview errors
@section Error handling


All the functions return a @objtype{bool} value: @cfalse{} when successful; @ctrue{} when an error
occurs.  The usual function call should look like this:

@example
if (mmux_libc_do_something()) @{
  /* error */
@}
@end example

If a function implemented by the @gnu{} C Library is interfaced by @value{PACKAGE} but it is not
available under a specific platform: the corresponding @value{PACKAGE} function is always
implemented; its return value is a @objtype{bool} and it is always @ctrue{}; it sets @code{errno} to
@samp{MMUX_LIBC_ENOSYS}.

@c page
@node overview results
@section Results handling


Unless otherwise specified, if the first argument of a function is a pointer named @var{result_p},
@var{output_p}, @var{ouput_p}, or similar: the function will store in the referenced location the
result of the call.

For example, we can write:

@example
mmux_slong_t    result;

if (mmux_libc_sysconf(&result, MMUX_LIBC__SC_PAGESIZE)) @{
  /* error */
@}
/* the result is in "result" */
@end example

@c page

@include overview-linking.texi

@c page
@node constants
@chapter Constants


@value{PACKAGE} attempts to offer all the constants implemented by the @gnu{} C Library; the name of
the @value{PACKAGE} constant is the original name prefixed with
@code{@value{PackageApiPrefixUpper}}.


@macro MmuxDefineConstant{NAME}
@defvr {Constant} @value{PackageApiPrefixUpper}\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{@value{PackageApiPrefixUpper}\NAME\} evaluates to the C language constant @code{\NAME\}; it can be
either a preprocessor symbol or an enumerated symbol; it can be defined or not depending on the
features of the underlying platform.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbol
@samp{@value{PackageApiPrefixUpper}\NAME\} is available.
@end defvr

@end macro

@MmuxDefineConstant{AT_EMPTY_PATH}
@MmuxDefineConstant{AT_FDCWD}
@MmuxDefineConstant{AT_NOAUTOMOUNT}
@MmuxDefineConstant{AT_REMOVEDIR}
@MmuxDefineConstant{AT_SYMLINK_FOLLOW}
@MmuxDefineConstant{EOF}
@MmuxDefineConstant{F_DUPFD}
@MmuxDefineConstant{F_GETFD}
@MmuxDefineConstant{F_GETFL}
@MmuxDefineConstant{F_GETLK}
@MmuxDefineConstant{F_GETOWN}
@MmuxDefineConstant{F_OFD_SETLK}
@MmuxDefineConstant{F_OFD_SETLKW}
@MmuxDefineConstant{F_OFD_GETLK}
@MmuxDefineConstant{F_OK}
@MmuxDefineConstant{F_RDLCK}
@MmuxDefineConstant{F_SETFD}
@MmuxDefineConstant{F_SETFL}
@MmuxDefineConstant{F_SETLK}
@MmuxDefineConstant{F_SETLKW}
@MmuxDefineConstant{F_SETOWN}
@MmuxDefineConstant{F_UNLCK}
@MmuxDefineConstant{F_WRLCK}
@MmuxDefineConstant{MAXSYMLINKS}
@MmuxDefineConstant{O_ACCMODE}
@MmuxDefineConstant{O_APPEND}
@MmuxDefineConstant{O_ASYNC}
@MmuxDefineConstant{O_CLOEXEC}
@MmuxDefineConstant{O_CREAT}
@MmuxDefineConstant{O_DIRECT}
@MmuxDefineConstant{O_DIRECTORY}
@MmuxDefineConstant{O_EXCL}
@MmuxDefineConstant{O_EXEC}
@MmuxDefineConstant{O_EXLOCK}
@MmuxDefineConstant{O_FSYNC}
@MmuxDefineConstant{O_IGNORE_CTTY}
@MmuxDefineConstant{O_LARGEFILE}
@MmuxDefineConstant{O_NDELAY}
@MmuxDefineConstant{O_NOATIME}
@MmuxDefineConstant{O_NOCTTY}
@MmuxDefineConstant{O_NOFOLLOW}
@MmuxDefineConstant{O_NOLINK}
@MmuxDefineConstant{O_NONBLOCK}
@MmuxDefineConstant{O_NOTRANS}
@MmuxDefineConstant{O_RDONLY}
@MmuxDefineConstant{O_RDWR}
@MmuxDefineConstant{O_READ}
@MmuxDefineConstant{O_SHLOCK}
@MmuxDefineConstant{O_SYNC}
@MmuxDefineConstant{O_TRUNC}
@MmuxDefineConstant{O_WRITE}
@MmuxDefineConstant{O_WRONLY}
@MmuxDefineConstant{R_OK}
@MmuxDefineConstant{RENAME_EXCHANGE}
@MmuxDefineConstant{RENAME_NOREPLACE}
@MmuxDefineConstant{RENAME_WITHEOUT}
@MmuxDefineConstant{RESOLVE_BENEATH}
@MmuxDefineConstant{RESOLVE_IN_ROOT}
@MmuxDefineConstant{RESOLVE_NO_MAGICLINKS}
@MmuxDefineConstant{RESOLVE_NO_SYMLINKS}
@MmuxDefineConstant{RESOLVE_NO_XDEV}
@MmuxDefineConstant{RESOLVE_CACHED}
@MmuxDefineConstant{S_IRGRP}
@MmuxDefineConstant{S_IROTH}
@MmuxDefineConstant{S_IRUSR}
@MmuxDefineConstant{S_IRWXG}
@MmuxDefineConstant{S_IRWXO}
@MmuxDefineConstant{S_IRWXU}
@MmuxDefineConstant{S_ISGID}
@MmuxDefineConstant{S_ISUID}
@MmuxDefineConstant{S_ISVTX}
@MmuxDefineConstant{S_IWGRP}
@MmuxDefineConstant{S_IWOTH}
@MmuxDefineConstant{S_IWUSR}
@MmuxDefineConstant{S_IXGRP}
@MmuxDefineConstant{S_IXOTH}
@MmuxDefineConstant{S_IXUSR}
@MmuxDefineConstant{MFD_CLOEXEC}
@MmuxDefineConstant{MFD_ALLOW_SEALING}
@MmuxDefineConstant{MFD_HUGETLB}
@MmuxDefineConstant{W_OK}
@MmuxDefineConstant{X_OK}
@MmuxDefineConstant{AF_ALG}
@MmuxDefineConstant{AF_APPLETALK}
@MmuxDefineConstant{AF_AX25}
@MmuxDefineConstant{AF_BLUETOOTH}
@MmuxDefineConstant{AF_CAN}
@MmuxDefineConstant{AF_DECnet}
@MmuxDefineConstant{AF_IB}
@MmuxDefineConstant{AF_INET6}
@MmuxDefineConstant{AF_INET}
@MmuxDefineConstant{AF_IPX}
@MmuxDefineConstant{AF_KCM}
@MmuxDefineConstant{AF_KEY}
@MmuxDefineConstant{AF_LLC}
@MmuxDefineConstant{AF_LOCAL}
@MmuxDefineConstant{AF_MPLS}
@MmuxDefineConstant{AF_NETLINK}
@MmuxDefineConstant{AF_PACKET}
@MmuxDefineConstant{AF_PPPOX}
@MmuxDefineConstant{AF_RDS}
@MmuxDefineConstant{AF_TIPC}
@MmuxDefineConstant{AF_UNIX}
@MmuxDefineConstant{AF_UNSPEC}
@MmuxDefineConstant{AF_VSOCK}
@MmuxDefineConstant{AF_X25}
@MmuxDefineConstant{AF_XDP}
@MmuxDefineConstant{IFNAMSIZ}
@MmuxDefineConstant{PF_FILE}
@MmuxDefineConstant{PF_INET6}
@MmuxDefineConstant{PF_INET}
@MmuxDefineConstant{PF_LOCAL}
@MmuxDefineConstant{PF_UNIX}
@MmuxDefineConstant{PF_UNSPEC}
@MmuxDefineConstant{SHUT_RDWR}
@MmuxDefineConstant{SHUT_RD}
@MmuxDefineConstant{SHUT_WR}
@MmuxDefineConstant{MSG_CONFIRM}
@MmuxDefineConstant{MSG_DONTROUTE}
@MmuxDefineConstant{MSG_DONTWAIT}
@MmuxDefineConstant{MSG_EOR}
@MmuxDefineConstant{MSG_MORE}
@MmuxDefineConstant{MSG_NOSIGNAL}
@MmuxDefineConstant{MSG_OOB}
@MmuxDefineConstant{MSG_PEEK}
@MmuxDefineConstant{SOL_SOCKET}
@MmuxDefineConstant{SO_BROADCAST}
@MmuxDefineConstant{SO_DEBUG}
@MmuxDefineConstant{SO_DONTROUTE}
@MmuxDefineConstant{SO_ERROR}
@MmuxDefineConstant{SO_KEEPALIVE}
@MmuxDefineConstant{SO_LINGER}
@MmuxDefineConstant{SO_OOBINLINE}
@MmuxDefineConstant{SO_RCVBUF}
@MmuxDefineConstant{SO_REUSEADDR}
@MmuxDefineConstant{SO_SNDBUF}
@MmuxDefineConstant{SO_STYLE}
@MmuxDefineConstant{SO_TYPE}
@MmuxDefineConstant{INADDR_ANY}
@MmuxDefineConstant{INADDR_BROADCAST}
@MmuxDefineConstant{INADDR_LOOPBACK}
@MmuxDefineConstant{INADDR_NONE}
@MmuxDefineConstant{AI_ADDRCONFIG}
@MmuxDefineConstant{AI_ADDRCONFIG}
@MmuxDefineConstant{AI_ALL}
@MmuxDefineConstant{AI_CANONIDN}
@MmuxDefineConstant{AI_CANONNAME}
@MmuxDefineConstant{AI_IDN}
@MmuxDefineConstant{AI_NUMERICSERV}
@MmuxDefineConstant{AI_PASSIVE}
@MmuxDefineConstant{AI_V4MAPPED}
@MmuxDefineConstant{NI_DGRAM}
@MmuxDefineConstant{NI_IDN}
@MmuxDefineConstant{NI_NAMEREQD}
@MmuxDefineConstant{NI_NOFQDN}
@MmuxDefineConstant{NI_NUMERICHOST}
@MmuxDefineConstant{NI_NUMERICSERV}

@MmuxDefineConstant{RWF_APPEND}
@MmuxDefineConstant{RWF_DSYNC}
@MmuxDefineConstant{RWF_HIPRI}
@MmuxDefineConstant{RWF_NOWAIT}
@MmuxDefineConstant{RWF_SYNC}

@MmuxDefineConstant{IPPROTO_AH}
@MmuxDefineConstant{IPPROTO_BEETPH}
@MmuxDefineConstant{IPPROTO_COMP}
@MmuxDefineConstant{IPPROTO_DCCP}
@MmuxDefineConstant{IPPROTO_EGP}
@MmuxDefineConstant{IPPROTO_ENCAP}
@MmuxDefineConstant{IPPROTO_ESP}
@MmuxDefineConstant{IPPROTO_ETHERNET}
@MmuxDefineConstant{IPPROTO_GRE}
@MmuxDefineConstant{IPPROTO_ICMP}
@MmuxDefineConstant{IPPROTO_IDP}
@MmuxDefineConstant{IPPROTO_IGMP}
@MmuxDefineConstant{IPPROTO_IP}
@MmuxDefineConstant{IPPROTO_IPIP}
@MmuxDefineConstant{IPPROTO_IPV6}
@MmuxDefineConstant{IPPROTO_MPLS}
@MmuxDefineConstant{IPPROTO_MPTCP}
@MmuxDefineConstant{IPPROTO_MTP}
@MmuxDefineConstant{IPPROTO_PIM}
@MmuxDefineConstant{IPPROTO_PUP}
@MmuxDefineConstant{IPPROTO_RAW}
@MmuxDefineConstant{IPPROTO_RSVP}
@MmuxDefineConstant{IPPROTO_SCTP}
@MmuxDefineConstant{IPPROTO_TCP}
@MmuxDefineConstant{IPPROTO_TP}
@MmuxDefineConstant{IPPROTO_UDP}
@MmuxDefineConstant{IPPROTO_UDPLITE}

@MmuxDefineConstant{IPPORT_BIFFUDP}
@MmuxDefineConstant{IPPORT_CMDSERVER}
@MmuxDefineConstant{IPPORT_DAYTIME}
@MmuxDefineConstant{IPPORT_DISCARD}
@MmuxDefineConstant{IPPORT_ECHO}
@MmuxDefineConstant{IPPORT_EFSSERVER}
@MmuxDefineConstant{IPPORT_EXECSERVER}
@MmuxDefineConstant{IPPORT_FINGER}
@MmuxDefineConstant{IPPORT_FTP}
@MmuxDefineConstant{IPPORT_LOGINSERVER}
@MmuxDefineConstant{IPPORT_MTP}
@MmuxDefineConstant{IPPORT_NAMESERVER}
@MmuxDefineConstant{IPPORT_NETSTAT}
@MmuxDefineConstant{IPPORT_RESERVED}
@MmuxDefineConstant{IPPORT_RJE}
@MmuxDefineConstant{IPPORT_ROUTESERVER}
@MmuxDefineConstant{IPPORT_SMTP}
@MmuxDefineConstant{IPPORT_SUPDUP}
@MmuxDefineConstant{IPPORT_SYSTAT}
@MmuxDefineConstant{IPPORT_TELNET}
@MmuxDefineConstant{IPPORT_TFTP}
@MmuxDefineConstant{IPPORT_TIMESERVER}
@MmuxDefineConstant{IPPORT_TTYLINK}
@MmuxDefineConstant{IPPORT_USERRESERVED}
@MmuxDefineConstant{IPPORT_WHOIS}
@MmuxDefineConstant{IPPORT_WHOSERVER}

@MmuxDefineConstant{SOCK_CLOEXEC}
@MmuxDefineConstant{SOCK_DCCP}
@MmuxDefineConstant{SOCK_DGRAM}
@MmuxDefineConstant{SOCK_NONBLOCK}
@MmuxDefineConstant{SOCK_PACKET}
@MmuxDefineConstant{SOCK_RAW}
@MmuxDefineConstant{SOCK_RDM}
@MmuxDefineConstant{SOCK_SEQPACKET}
@MmuxDefineConstant{SOCK_STREAM}

@MmuxDefineConstant{WAIT_ANY}
@MmuxDefineConstant{WAIT_MYPGRP}

@MmuxDefineConstant{P_ALL}
@MmuxDefineConstant{P_PID}
@MmuxDefineConstant{P_PIDFD}
@MmuxDefineConstant{P_PGID}

@MmuxDefineConstant{EXIT_SUCCESS}
@MmuxDefineConstant{EXIT_FAILURE}

@defvr Constant @value{PackageApiPrefixUpper}MSG_ZERO
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_MSG_ZERO
The symbol @code{@value{PackageApiPrefixUpper}MSG_ZERO} evaluates to zero; it is meant to be used as
@var{flags} argument for @cfunc{mmux_libc_send}, and similar functions, when no other
@code{@value{PackageApiPrefixUpper}MSG_*} flag is needed; it gives the reader of the code a
remainder of which flags are available for the operation.

The symbol @code{MMUX_HAVE_LIBC_MSG_ZERO} is always defined and it evaluates to @samp{1}.
@end defvr

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {mmux_asciizcp_t} mmux_cc_libc_version_string (void)
Return a pointer to a statically allocated @MmuxAsciiZ{} string representing the interface version
number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_libc_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_libc_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_libc_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun


@deftypevr {Struct Pointer} {mmux_libc_interface_specification_t const *} mmux_libc_interface_specification
Interface specification for @value{PACKAGE}, @ref{interface specifications} for details.
@end deftypevr

@c page
@node initialisation
@chapter Library initialisation


@deftypefun bool mmux_cc_libc_init (void)
Initialise library's internal state; we can safely call this function multimple times.  When
successful return @cfalse{}; otherwise return @ctrue{}.
@end deftypefun

@c page
@node errors
@chapter Errors management


@cindex @code{errno} variable
@cindex Variacle @code{errno}
@cindex Error handling
@cindex Handling errors


@deftp {Struct Typedef} mmux_libc_errno_t
Data structure type representing the constants of @code{errno}.  All the known standard constants
like @samp{EINVAL} are available as preprocessor symbols like @samp{MMUX_LIBC_EINVAL}, which expand
to an expression evaluating to an instance of this data type.
@end deftp


@deftypefun bool mmux_libc_errno_equal (mmux_libc_errno_t @vari{errnum}, mmux_libc_errno_t @varii{errnum})
Return @ctrue{} if @vari{errnum} equal @varii{errnum}, otherwise return @cfalse{}.

@example
mmux_libc_errno_t       errnum;

mmux_libc_errno_consume(&errno);
if (mmux_libc_errno_equal(MMUX_LIBC_EINVAL, errno)) @{
  ...
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_errno_set (mmux_libc_errno_t @var{errnum})
Setter for the standard @code{errno} variable.  The return value is always @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_errno_ref (mmux_libc_errno_t * @var{result_errnum_p})
Getter for the standard @code{errno} variable: always store the current value of @code{errno} in the
location referenced by @var{result_errnum_p}.  When @code{errno} is zero: the return value is
@ctrue{}, there is no reason to query @code{errno}; otherwise it is @cfalse{}.

@example
mmux_libc_errno_t     errnum;

if (mmux_libc_errno_ref(&errnum)) @{
  ... /* there was no error: why are we querying "errno"? */
@} else @{
  mmux_asciizcp_t       errmsg;

  mmux_libc_strerror(&errmsg, errnum);
  ... /* handle the error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_errno_clear (void)
Set @code{errno} to zero.  Always return @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_errno_consume (mmux_libc_errno_t * @var{result_errnum_p})
Getter--and--resetter for the standard @code{errno} variable: always store the current value of
@code{errno} in the location referenced by @var{result_errnum_p}, then reset @code{errno} to zero.
Upon calling this function, when @code{errno} is zero: the return value is @ctrue{}, there is no
reason to query @code{errno}; otherwise it is @cfalse{}.

@example
mmux_libc_errno_t     errnum;

if (mmux_libc_errno_consume(&errnum)) @{
  ... /* there was no error: why are we querying "errno"? */
@} else @{
  mmux_asciizcp_t       errmsg;

  mmux_libc_strerror(&errmsg, errnum);
  ... /* handle the error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strerror (mmux_asciizcp_t * @var{result_error_message_p}, mmux_libc_errno_t @var{errnum})
@MmuxCInterface{strerror}.  The return value is always @cfalse{}.

Often we want to compose strings using a memory--mapped file descriptor, so we call
@cfunc{mmux_libc_memfd_strerror} instead of this function, @ref{mmux_libc_memfd_strerror} for details.

Otherwise we may want to call @cfunc{mmux_libc_dprintf_strerror}; @ref{mmux_libc_dprintf_strerror}
for details.
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_strerror_r (mmux_asciizcpp_t @var{result_p}, mmux_asciizp_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_libc_errno_t @var{errnum})
@MmuxCInterface{strerror_r}.  This is the @gnu{} variant of this function.

We must use the arguments @var{bufptr} and @var{buflen} to provide a buffer in which the string
could be written: it is up to @cfunc{strerror_r} to use it or not.  If the call is successful: we
just use the pointer stored in the variable referenced by @var{result_p}.  A @var{buflen} of
@samp{1024} should be enough to hold any string.

@example
mmux_asciizcp_t         result;
mmux_usize_t            buflen = 1024;
mmux_char_t             bufptr[buflen];

if (mmux_libc_strerror_r(&result, bufptr, buflen, MMUX_LIBC_EINVAL)) @{
  /* error */
@}

if (mmux_libc_dprintfer("strerror_r result: %s\n", result)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_strerrorname_np (mmux_asciizcpp_t result_p, mmux_libc_errno_t errnum)
@MmuxCInterface{strerrorname_np}.  This is the @gnu{} variant of this function.

The following code example should print @samp{EINVAL}:

@example
mmux_asciizcp_t result;

if (mmux_libc_strerrorname_np(&result, MMUX_LIBC_EINVAL)) @{
  /* error */
@}

if (mmux_libc_dprintfer("strerrorname_np result: %s", result)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_strerrordesc_np (mmux_asciizcpp_t result_p, mmux_libc_errno_t errnum)
@MmuxCInterface{strerrordesc_np}.  This is the @gnu{} variant of this function.

The following code example should print @samp{Invalid argument}:

@example
mmux_asciizcp_t result;

if (mmux_libc_strerrordesc_np(&result, MMUX_LIBC_EINVAL)) @{
  /* error */
@}

if (mmux_libc_dprintfer("strerrordesc_np result: %s", result)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_program_invocation_name (mmux_asciizcpp_t @var{result_p})
Store in the variable referenced by @var{result_p} a pointer to the @gnu{} C Library global variable
@code{program_invocation_name}.  @glibcref{Error Messages, Error Messages}.
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_program_invocation_short_name (mmux_asciizcpp_t @var{result_p})
Store in the variable referenced by @var{result_p} a pointer to the @gnu{} C Library global variable
@code{program_invocation_short_name}.  @glibcref{Error Messages, Error Messages}.
@end deftypefn

@c ------------------------------------------------------------------------

@macro MmuxLibcDefineErrnoConstant{NAME}
@deftypevr {Constant} mmux_libc_errno_t MMUX_LIBC_\NAME\
@deftypevrx {Preprocessor Symbol} int MMUX_LIBC_VALUEOF_\NAME\
@deftypevrx {Preprocessor Symbol} int MMUX_HAVE_LIBC_\NAME\
Error code @code{\NAME\}.
@end deftypevr

@end macro


@MmuxLibcDefineErrnoConstant{EPERM}
@MmuxLibcDefineErrnoConstant{ENOENT}
@MmuxLibcDefineErrnoConstant{ESRCH}
@MmuxLibcDefineErrnoConstant{EINTR}
@MmuxLibcDefineErrnoConstant{EIO}
@MmuxLibcDefineErrnoConstant{ENXIO}
@MmuxLibcDefineErrnoConstant{E2BIG}
@MmuxLibcDefineErrnoConstant{ENOEXEC}
@MmuxLibcDefineErrnoConstant{EBADF}
@MmuxLibcDefineErrnoConstant{ECHILD}
@MmuxLibcDefineErrnoConstant{EAGAIN}
@MmuxLibcDefineErrnoConstant{ENOMEM}
@MmuxLibcDefineErrnoConstant{EACCES}
@MmuxLibcDefineErrnoConstant{EFAULT}
@MmuxLibcDefineErrnoConstant{ENOTBLK}
@MmuxLibcDefineErrnoConstant{EBUSY}
@MmuxLibcDefineErrnoConstant{EEXIST}
@MmuxLibcDefineErrnoConstant{EXDEV}
@MmuxLibcDefineErrnoConstant{ENODEV}
@MmuxLibcDefineErrnoConstant{ENOTDIR}
@MmuxLibcDefineErrnoConstant{EISDIR}
@MmuxLibcDefineErrnoConstant{EINVAL}
@MmuxLibcDefineErrnoConstant{ENFILE}
@MmuxLibcDefineErrnoConstant{EMFILE}
@MmuxLibcDefineErrnoConstant{ENOTTY}
@MmuxLibcDefineErrnoConstant{ETXTBSY}
@MmuxLibcDefineErrnoConstant{EFBIG}
@MmuxLibcDefineErrnoConstant{ENOSPC}
@MmuxLibcDefineErrnoConstant{ESPIPE}
@MmuxLibcDefineErrnoConstant{EROFS}
@MmuxLibcDefineErrnoConstant{EMLINK}
@MmuxLibcDefineErrnoConstant{EPIPE}
@MmuxLibcDefineErrnoConstant{EDOM}
@MmuxLibcDefineErrnoConstant{ERANGE}
@MmuxLibcDefineErrnoConstant{EDEADLK}
@MmuxLibcDefineErrnoConstant{ENAMETOOLONG}
@MmuxLibcDefineErrnoConstant{ENOLCK}
@MmuxLibcDefineErrnoConstant{ENOSYS}
@MmuxLibcDefineErrnoConstant{ENOTSUP}
@MmuxLibcDefineErrnoConstant{ENOTEMPTY}
@MmuxLibcDefineErrnoConstant{ELOOP}
@MmuxLibcDefineErrnoConstant{EWOULDBLOCK}
@MmuxLibcDefineErrnoConstant{ENOMSG}
@MmuxLibcDefineErrnoConstant{EIDRM}
@MmuxLibcDefineErrnoConstant{ECHRNG}
@MmuxLibcDefineErrnoConstant{EL2NSYNC}
@MmuxLibcDefineErrnoConstant{EL3HLT}
@MmuxLibcDefineErrnoConstant{EL3RST}
@MmuxLibcDefineErrnoConstant{ELNRNG}
@MmuxLibcDefineErrnoConstant{EUNATCH}
@MmuxLibcDefineErrnoConstant{ENOCSI}
@MmuxLibcDefineErrnoConstant{EL2HLT}
@MmuxLibcDefineErrnoConstant{EBADE}
@MmuxLibcDefineErrnoConstant{EBADR}
@MmuxLibcDefineErrnoConstant{EXFULL}
@MmuxLibcDefineErrnoConstant{ENOANO}
@MmuxLibcDefineErrnoConstant{EBADRQC}
@MmuxLibcDefineErrnoConstant{EBADSLT}
@MmuxLibcDefineErrnoConstant{EDEADLOCK}
@MmuxLibcDefineErrnoConstant{EBFONT}
@MmuxLibcDefineErrnoConstant{ENOSTR}
@MmuxLibcDefineErrnoConstant{ENODATA}
@MmuxLibcDefineErrnoConstant{ETIME}
@MmuxLibcDefineErrnoConstant{ENOSR}
@MmuxLibcDefineErrnoConstant{ENONET}
@MmuxLibcDefineErrnoConstant{ENOPKG}
@MmuxLibcDefineErrnoConstant{EREMOTE}
@MmuxLibcDefineErrnoConstant{ENOLINK}
@MmuxLibcDefineErrnoConstant{EADV}
@MmuxLibcDefineErrnoConstant{ESRMNT}
@MmuxLibcDefineErrnoConstant{ECOMM}
@MmuxLibcDefineErrnoConstant{EPROTO}
@MmuxLibcDefineErrnoConstant{EMULTIHOP}
@MmuxLibcDefineErrnoConstant{EDOTDOT}
@MmuxLibcDefineErrnoConstant{EBADMSG}
@MmuxLibcDefineErrnoConstant{EOVERFLOW}
@MmuxLibcDefineErrnoConstant{ENOTUNIQ}
@MmuxLibcDefineErrnoConstant{EBADFD}
@MmuxLibcDefineErrnoConstant{EREMCHG}
@MmuxLibcDefineErrnoConstant{ELIBACC}
@MmuxLibcDefineErrnoConstant{ELIBBAD}
@MmuxLibcDefineErrnoConstant{ELIBSCN}
@MmuxLibcDefineErrnoConstant{ELIBMAX}
@MmuxLibcDefineErrnoConstant{ELIBEXEC}
@MmuxLibcDefineErrnoConstant{EILSEQ}
@MmuxLibcDefineErrnoConstant{ERESTART}
@MmuxLibcDefineErrnoConstant{ESTRPIPE}
@MmuxLibcDefineErrnoConstant{EUSERS}
@MmuxLibcDefineErrnoConstant{ENOTSOCK}
@MmuxLibcDefineErrnoConstant{EDESTADDRREQ}
@MmuxLibcDefineErrnoConstant{EMSGSIZE}
@MmuxLibcDefineErrnoConstant{EPROTOTYPE}
@MmuxLibcDefineErrnoConstant{ENOPROTOOPT}
@MmuxLibcDefineErrnoConstant{EPROTONOSUPPORT}
@MmuxLibcDefineErrnoConstant{ESOCKTNOSUPPORT}
@MmuxLibcDefineErrnoConstant{EOPNOTSUPP}
@MmuxLibcDefineErrnoConstant{EPFNOSUPPORT}
@MmuxLibcDefineErrnoConstant{EAFNOSUPPORT}
@MmuxLibcDefineErrnoConstant{EADDRINUSE}
@MmuxLibcDefineErrnoConstant{EADDRNOTAVAIL}
@MmuxLibcDefineErrnoConstant{ENETDOWN}
@MmuxLibcDefineErrnoConstant{ENETUNREACH}
@MmuxLibcDefineErrnoConstant{ENETRESET}
@MmuxLibcDefineErrnoConstant{ECONNABORTED}
@MmuxLibcDefineErrnoConstant{ECONNRESET}
@MmuxLibcDefineErrnoConstant{ENOBUFS}
@MmuxLibcDefineErrnoConstant{EISCONN}
@MmuxLibcDefineErrnoConstant{ENOTCONN}
@MmuxLibcDefineErrnoConstant{ESHUTDOWN}
@MmuxLibcDefineErrnoConstant{ETOOMANYREFS}
@MmuxLibcDefineErrnoConstant{ETIMEDOUT}
@MmuxLibcDefineErrnoConstant{ECONNREFUSED}
@MmuxLibcDefineErrnoConstant{EHOSTDOWN}
@MmuxLibcDefineErrnoConstant{EHOSTUNREACH}
@MmuxLibcDefineErrnoConstant{EALREADY}
@MmuxLibcDefineErrnoConstant{EINPROGRESS}
@MmuxLibcDefineErrnoConstant{ESTALE}
@MmuxLibcDefineErrnoConstant{EUCLEAN}
@MmuxLibcDefineErrnoConstant{ENOTNAM}
@MmuxLibcDefineErrnoConstant{ENAVAIL}
@MmuxLibcDefineErrnoConstant{EISNAM}
@MmuxLibcDefineErrnoConstant{EREMOTEIO}
@MmuxLibcDefineErrnoConstant{EDQUOT}
@MmuxLibcDefineErrnoConstant{ENOMEDIUM}
@MmuxLibcDefineErrnoConstant{EMEDIUMTYPE}
@MmuxLibcDefineErrnoConstant{ECANCELED}
@MmuxLibcDefineErrnoConstant{ENOKEY}
@MmuxLibcDefineErrnoConstant{EKEYEXPIRED}
@MmuxLibcDefineErrnoConstant{EKEYREVOKED}
@MmuxLibcDefineErrnoConstant{EKEYREJECTED}
@MmuxLibcDefineErrnoConstant{EOWNERDEAD}
@MmuxLibcDefineErrnoConstant{ENOTRECOVERABLE}

@c page
@node memory
@chapter Memory management


@menu
* memory core::                 Core memory allocation operations.
* memory operations::           Memory operations.
* memory allocators::           Memory allocator.
@end menu

@c page
@node memory core
@section Core memory allocation operations


Among the following operations: those that allocate or reallocate a block of memory have a result
argument @code{mmux_pointer_t * @var{result_p}}; all of them have both a function and a macro, the
latter just casts a pointer @var{result_p} of any type to @code{mmux_pointer_t *}.


@deftypefn {Preprocessor Macro} bool mmux_libc_malloc (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{len})
@deftypefnx {Function} bool mmux_libc_malloc_ (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{len})
@MmuxCInterface{malloc}.  Upon successful return: the pointer variable referenced by @var{result_p}
is set to the pointer referencing the newly allocated memory block.

@example
auto                     nbytes = mmux_usize_literal(213);
mmux_standard_octet_t *  ptr;

if (mmux_libc_malloc(&ptr, nbytes)) @{
  /* error */
@} else @{
  ...
  mmux_libc_free(ptr);
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_calloc (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx Function bool mmux_libc_calloc_ (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@MmuxCInterface{calloc}.  Upon successful return: the pointer variable referenced by @var{result_p}
is set to the pointer referencing the newly allocated memory block.

@example
@{
  auto                     item_num = mmux_usize_literal(12);
  auto                     item_len = mmux_usize_literal(34);
  mmux_standard_octet_t *  ptr;

  if (mmux_libc_calloc(&ptr, item_num, item_len)) @{
    /* error */
  @} else @{
    ...
    mmux_libc_free(ptr);
  @}
@}

@{
  auto                 item_num = mmux_usize_literal(12);
  auto                 item_len = mmux_flonumd128_sizeof();
  mmux_flonumd128_t *  ptr;

  if (mmux_libc_calloc(&ptr, item_num, item_len)) @{
    /* error */
  @} else @{
    for (auto i = mmux_usize_constant_zero();
         mmux_ctype_less(i, item_num);
         mmux_ctype_incr_variable(i)) @{
      ptr[i.value] = mmux_flonumd128(i.value);
    @}
    mmux_libc_free(ptr);
  @}
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_realloc (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{newlen})
@deftypefnx Function bool mmux_libc_realloc_ (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{newlen})
@MmuxCInterface{realloc}.

@itemize
@item
Upon calling this function: @var{result_p} must reference a pointer variable holding the pointer to the
memory block to reallocate.

@item
Upon successfully returning from this function: the pointer variable referenced by @var{result_p} holds
the new pointer.
@end itemize

@example
auto                     nbytes1 = mmux_usize_literal(56);
auto                     nbytes2 = mmux_usize_literal(89);
mmux_standard_octet_t *  ptr;

if (mmux_libc_malloc(&ptr, nbytes1)) @{
  /* error */
@}
...
if (mmux_libc_realloc(&ptr, nbytes2)) @{
  /* error */
@}
...
mmux_libc_free(ptr);
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_reallocarray (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx Function bool mmux_libc_reallocarray_ (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@MmuxCInterface{reallocarray}.  Upon successful return: the pointer variable referenced by
@var{result_p} is set to the pointer referencing the newly allocated memory block.

@example
auto                item_num1 = mmux_usize_literal(12);
auto                item_num2 = mmux_usize_literal(34);
auto                item_len  = mmux_flonumd128_sizeof();
mmux_flonumd128_t * ptr;

if (mmux_libc_calloc(&ptr, item_num1, item_len)) @{
  /* error */
@}
...
if (mmux_libc_reallocarray(&ptr, item_num2, item_len)) @{
  /* error */
@}
...
mmux_libc_free(ptr);
@end example
@end deftypefn


@deftypefun bool mmux_libc_free (mmux_pointer_t @var{P})
@MmuxCInterface{free}.
@end deftypefun


@deftypefn {Preprocessor Macro} bool mmux_libc_malloc_and_copy (mmux_pointer_t * @var{dstptr_p}, mmux_pointer_t @var{srcptr}, mmux_usize_t @var{srclen})
@deftypefnx {Function} bool mmux_libc_malloc_and_copy_ (mmux_pointer_t * @var{dstptr_p}, mmux_pointer_t @var{srcptr}, mmux_usize_t @var{srclen})
Allocate @var{srclen} bytes using @cfunc{mmux_libc_malloc}; then copy @var{srclen} bytes from
@var{srcptr} to the newly allocated memory block; finally store the resulting pointer in the
variable referenced by @var{result_p}.

To copy bytes from a buffer we do:

@example
auto                      buflen = mmux_usize_literal(12);
mmux_standard_byte_t      srcbuf[buflen.value];
mmux_standard_byte_t *    dstbuf;

for (mmux_standard_usize_t i=0; i<buflen.value; ++i) @{
  srcbuf[i] = ...;
@}
if (mmux_libc_malloc_and_copy(&dstbuf, srcbuf, buflen)) @{
  /* error */
@}
for (mmux_standard_usize_t i=0; i<buflen.value; ++i) @{
  do_something_with(dstbuf[i]);
@}
mmux_libc_free(dstbuf);
@end example

To copy an @MmuxAsciiZ{} string we do:

@example
mmux_standard_char_t *    srcbuf = "the colour of water";
mmux_standard_char_t *    dstbuf;
mmux_usize_t              buflen;

mmux_libc_strlen_plus_nil(&buflen, srcbuf);
if (mmux_libc_malloc_and_copy(&dstbuf, srcbuf, buflen)) @{
  /* error */
@}
if (mmux_libc_dprintfer("@{%s@}\n", dstbuf)) @{
  /* error */
@}
mmux_libc_free(dstbuf);
@end example
@end deftypefn

@c page
@node memory operations
@section Memory operations


@deftypefun bool mmux_libc_memset (mmux_pointer_t @var{ptr}, mmux_octett @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memset}.

@example
auto                    value  = mmux_octet(13);
auto                    buflen = mmux_usize_literal(5);
mmux_standard_octet_t   bufptr[buflen.value];

mmux_libc_memset(bufptr, value, buflen);
@end example
@end deftypefun


@deftypefun bool mmux_libc_memzero (mmux_pointer_t @var{ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memzero}.

@example
auto                   buflen = mmux_usize_literal(5);
mmux_standard_octet_t  bufptr[buflen.value];

mmux_libc_memzero(bufptr, buflen);
@end example
@end deftypefun


@deftypefun bool mmux_libc_memcpy (mmux_pointer_t @var{dst_ptr}, mmux_pointerc_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memcpy}.

@example
auto                   buflen = mmux_usize_literal(5);
mmux_standard_octet_t  srcptr[buflen.value];
mmux_standard_octet_t  dstptr[buflen.value];

...
mmux_libc_memcpy(dstptr, srcptr, buflen);
@end example
@end deftypefun


@deftypefn {Preprocessor Macro} bool mmux_libc_mempcpy (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@deftypefnx {@gnu{} Function} bool mmux_libc_mempcpy_ (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{mempcpy}.

@example
@{
  auto                     buflen = mmux_usize_literal(5);
  mmux_standard_octet_t    srcptr[buflen.value];
  mmux_standard_octet_t    dstptr[buflen.value];
  mmux_standard_octet_t *  nxtptr;

  ...
  mmux_libc_mempcpy(&nxtptr, dstptr, srcptr, buflen);
  assert((mmux_standard_ptrdiff_t)(nxtptr - dstptr) == buflen.value);
@}

@{
  mmux_standard_char_t *    srcptr = "the colour of water";
  mmux_usize_t              buflen;

  mmux_libc_strlen(&buflen, srcptr);
  @{
    mmux_standard_char_t    dstptr[buflen.value];
    mmux_standard_char_t *  nxtptr;

    mmux_libc_mempcpy(&nxtptr, dstptr, srcptr, buflen);
    assert( (mmux_standard_ptrdiff_t)(nxtptr - dstptr) == buflen.value);
  @}
@}
@end example
@end deftypefn


@deftypefn {Preprocssor Macro} bool mmux_libc_memccpy (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_uint8_t @var{octet}, mmux_usize_t @var{nbytes})
@deftypefnx {Function} bool mmux_libc_memccpy_ (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_uint8_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memccpy}.

@example
@{
  auto                      it     = mmux_octet(3);
  auto                      buflen = mmux_usize_literal(5);
  mmux_standard_octet_t     srcptr[buflen.value];
  mmux_standard_octet_t     dstptr[buflen.value];
  mmux_standard_octet_t *   nxtptr;

  ...
  mmux_libc_memccpy(&nxtptr, dstptr, srcptr, it, buflen);
@}

@{
  mmux_standard_char_t *    srcptr = "the colour of water";
  mmux_usize_t              buflen;

  mmux_libc_strlen(&buflen, srcptr);
  @{
    auto                    it = mmux_octet('w');
    mmux_standard_char_t    dstptr[buflen.value];
    mmux_standard_char_t *  nxtptr;

    mmux_libc_memccpy(&nxtptr, dstptr, srcptr, it, buflen);
  @}
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_memmove (mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memmove}.

@example
@{
  auto                   buflen = mmux_usize_literal(5);
  mmux_standard_octet_t  srcptr[buflen.value];
  mmux_standard_octet_t  dstptr[buflen.value];

  ...
  mmux_libc_memmove(dstptr, srcptr, buflen);
@}

@{
  mmux_standard_char_t *  srcptr = "the colour of water";
  mmux_usize_t            buflen;

  mmux_libc_strlen_plus_nil(&buflen, srcptr);
  @{
    mmux_standard_char_t  dstptr[buflen.value];

    mmux_libc_memmove(dstptr, srcptr, buflen);
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_memcmp (mmux_ternary_comparison_result_t * @var{result_p}, mmux_pointerc_t @vari{ptr}, mmux_pointerc_t @varii{ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memcmp}.

@example
@{
  auto                   buflen = mmux_usize_literal(5);
  mmux_standard_octet_t  bufptr1[buflen.value];
  mmux_standard_octet_t  bufptr2[buflen.value];
  mmux_ternary_comparison_result_t  cmpnum;

  ...
  mmux_libc_memcmp(&cmpnum, bufptr1, bufptr2, buflen);
  if (mmux_ternary_comparison_result_is_less(cmpnum)) @{
    ...
  @}
@}

@{
  mmux_standard_char_t *  bufptr1 = "the colour of water";
  mmux_standard_char_t *  bufptr2 = "the colour of water and quicksilver";
  mmux_usize_t            buflen;
  mmux_ternary_comparison_result_t  cmpnum;

  mmux_libc_strlen(&buflen, bufptr1);
  mmux_libc_memcmp(&cmpnum, bufptr1, bufptr2, buflen);
  assert(mmux_ternary_comparison_result_is_equal(cmpnum));
@}
@end example
@end deftypefun


@deftypefn {Preprocessor Macro} bool mmux_libc_memchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@deftypefnx {Function} bool mmux_libc_memchr_ (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memchr}.

@example
@{
  auto                        it     = mmux_octet(3);
  auto                        buflen = mmux_usize_literal(5);
  mmux_standard_octet_t       bufptr[buflen.value];
  mmux_standard_octet_t *     result;

  ...
  mmux_libc_memchr(&result, bufptr, it, buflen);
  do_something_with(result);
@}

@{
  //                                    01234567890123456789
  mmux_standard_char_t *      bufptr = "the colour of water";
  mmux_usize_t                buflen;
  auto                        it     = mmux_octet('w');
  mmux_standard_char_t *      result;

  mmux_libc_strlen(&buflen, bufptr);
  mmux_libc_memchr(&result, bufptr, it, buflen);
  assert( (mmux_standard_ptrdiff_t)(result - bufptr) == 14 );
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_rawmemchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet})
@deftypefnx {@gnu{} Function} bool mmux_libc_rawmemchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet})
@MmuxCInterface{rawmemchr}.

@example
@{
  auto                        it     = mmux_octet(3);
  auto                        buflen = mmux_usize_literal(5);
  mmux_standard_octet_t       bufptr[buflen.value];
  mmux_standard_octet_t *     result;

  ...
  mmux_libc_rawmemchr(&result, bufptr, it);
  assert( (mmux_standard_ptrdiff_t)(result - bufptr) == 3);
@}

@{
  //                                    01234567890123456789
  mmux_standard_char_t *      bufptr = "the colour of water";
  auto                        it     = mmux_octet('w');
  mmux_standard_char_t *      result;

  mmux_libc_rawmemchr(&result, bufptr, it);
  assert( (mmux_standard_ptrdiff_t)(result - bufptr) == 14);
@}

/* Find the terminating nil character. */
@{
  //                                    01234567890123456789
  mmux_standard_char_t *      bufptr = "the colour of water";
  auto                        it     = mmux_octet_constant_zero();
  mmux_standard_char_t *      result;

  mmux_libc_rawmemchr(&result, bufptr, it);
  assert( (mmux_standard_ptrdiff_t)(result - bufptr) == 19);
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_memrchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@deftypefnx {Function} bool mmux_libc_memrchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memrchr}.

@example
@{
  auto                        it     = mmux_octet(3);
  auto                        buflen = mmux_usize_literal(5);
  mmux_standard_octet_t       bufptr[buflen.value];
  mmux_standard_octet_t *     result;

  ...
  mmux_libc_memrchr(&result, bufptr, it, buflen);
  do_something_with(result);
@}

@{
  //                                    01234567890123456789
  mmux_standard_char_t *      bufptr = "the colour of water";
  mmux_usize_t                buflen;
  auto                        it     = mmux_octet('o');
  mmux_standard_char_t *      result;

  mmux_libc_strlen(&buflen, bufptr);
  mmux_libc_memrchr(&result, bufptr, it, buflen);
  assert( NULL != result );
  assert( (mmux_standard_ptrdiff_t)(result - bufptr) == 11);
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_memmem (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{haystack_ptr}, mmux_usize_t @var{haystack_len}, mmux_pointer_t @var{needle_ptr}, mmux_usize_t @var{needle_len})
@deftypefnx {Function} bool mmux_libc_memmem (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{haystack_ptr}, mmux_usize_t @var{haystack_len}, mmux_pointer_t @var{needle_ptr}, mmux_usize_t @var{needle_len})
@MmuxCInterface{memmem}.

@example
@{
  auto                        haystack_len = mmux_usize_literal(11);
  mmux_standard_octet_t       haystack_ptr[haystack_len.value];
  auto                        needle_len = mmux_usize_literal(3);
  mmux_standard_octet_t       needle_ptr[] = @{ 3, 4, 5 @};
  mmux_standard_octet_t *     result;

  for (mmux_standard_usize_t i=0; i<buflen.value; ++i) @{
    bufptr[i] = (mmux_standard_octet_t) i;
  @}
  mmux_libc_memmem(&result,
                   haystack_ptr, haystack_len,
                   needle_ptr, needle_len);
  assert( NULL != result );
  assert( (mmux_standard_ptrdiff_t)(result - haystack_ptr) == 3);
@}

@{
  //                                          01234567890123456789
  mmux_standard_char_t *      haystack_ptr = "the colour of water";
  mmux_standard_char_t *      needle_ptr   = "colour";
  mmux_usize_t                haystack_len;
  mmux_usize_t                needle_len;
  mmux_standard_char_t *      result;

  mmux_libc_strlen(&haystack_len, haystack_ptr);
  mmux_libc_strlen(&needle_len,   needle_ptr);
  mmux_libc_memmem(&result,
                   haystack_ptr, haystack_len,
                   needle_ptr, needle_len);
  assert( NULL != result );
  assert( (mmux_standard_ptrdiff_t)(result - haystack_ptr) == 4);
@}
@end example
@end deftypefn

@c page
@node memory allocators
@section Memory allocators


It is often useful to define special memory allocators for specific data types or for data that we
know is short--lived or long--lived; the following definitions represent the memory allocator
defined by @value{PACKAGE}.

To allocate and release a memory block using the default memory allocator we do:

@example
mmux_libc_mall_t  AP;
mmux_pointer_t    bufptr;
auto              buflen = mmux_usize_literal(4096);

mmux_libc_default_memory_allocator_ref(&AP);

if (mmux_libc_memory_allocator_malloc(AP, &bufptr, buflen)) @{
  /* error */
@} else @{
  ...
  if (mmux_libc_memory_allocator_free(AP, bufptr)) @{
    /* error */
  @}
@}
@end example

Memory allocators implement the core operations @code{malloc}, @code{calloc}, @code{realloc},
@code{reallocarray}, @code{malloc_and_copy}, @code{free}.

@menu
* memory allocators types::     Memory allocator type definitions.
* memory allocators api::       Memory allocator programming interface.
* memory allocators default::   Default memory allocator.
* memory allocators fake::      Fake memory allocator.
* memory allocators example::   How to implement a memory allocator.
@end menu

@c page
@node memory allocators types
@subsection Memory allocator type definitions


@deftp {Struct Typedef} mmux_libc_memory_allocator_t
@deftpx {Struct Pointer Typedef} mmux_libc_mall_t
Data structure representing a memory allocator.  It has the following fields:

@table @code
@item mmux_libc_memory_allocator_value_t * const value
Pointer to an instance of @objtype{mmux_libc_memory_allocator_value_t}.

@item mmux_libc_memory_allocator_class_t const * const class
Pointer to an instance of @objtype{mmux_libc_memory_allocator_class_t} representing the class of
this memory allocator.
@end table

The type @objtype{mmux_libc_mall_t} is an alias for @code{mmux_libc_memory_allocator_t const *} and
we can use it as type for the argument to functions that reference a memory allocator.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Struct Typedef} mmux_libc_memory_allocator_value_t
Data structure representing the value of the memory allocator.  It has the following fields:

@table @code
@item mmux_pointer_t data
A pointer to be used for custom data.
@end table
@end deftp

@c ------------------------------------------------------------------------

@deftp {Struct Typedef} mmux_libc_memory_allocator_class_t
Data structure type representing the table of allocator--specific functions.  It has the following
fields:

@table @code
@item mmux_libc_memory_allocator_malloc_fun_t * const malloc
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_malloc}.

@item mmux_libc_memory_allocator_calloc_fun_t * const calloc
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_calloc}.

@item mmux_libc_memory_allocator_realloc_fun_t * const realloc
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_realloc}.

@item mmux_libc_memory_allocator_reallocarray_fun_t * const reallocarray
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_reallocarray}.

@item mmux_libc_memory_allocator_free_fun_t * const free
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_free}.

@item mmux_libc_default_memory_allocator_malloc_and_copy * const malloc_and_copy
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_malloc_and_copy}.
@end table

If, for some reason, a custom memory allocator does not implement one or more of these operations:
we should just define the corresponding functions to always set @code{errno} to
@samp{MMUX_LIBC_ENOSYS} and always return @ctrue{}.
@end deftp

@c ------------------------------------------------------------------------

@deftypefn {Function Type} bool mmux_libc_memory_allocator_malloc_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{len})
Allocator--specific function that behaves like @cfunc{mmux_libc_malloc}.
@end deftypefn


@deftypefn {Function Type} bool mmux_libc_memory_allocator_calloc_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
Allocator--specific function that behaves like @cfunc{mmux_libc_calloc}.
@end deftypefn


@deftypefn {Function Type} bool mmux_libc_memory_allocator_realloc_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{newlen})
Allocator--specific function that behaves like @cfunc{mmux_libc_realloc}.
@end deftypefn


@deftypefn {Function Type} bool mmux_libc_memory_allocator_reallocarray_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
Allocator--specific function that behaves like @cfunc{mmux_libc_reallocarray}.
@end deftypefn


@deftypefn {Function Type} bool mmux_libc_memory_allocator_free_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t @var{p})
Allocator--specific function that behaves like @cfunc{mmux_libc_free}.
@end deftypefn


@deftypefn {Function Type} bool mmux_libc_memory_allocator_malloc_and_copy_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{dstptr_p}, mmux_pointer_t @var{srcptr}, mmux_usize_t @var{srclen})
Allocator--specific function that behaves like @cfunc{mmux_libc_malloc_and_copy}.
@end deftypefn

@c page
@node memory allocators api
@subsection Memory allocator programming interface


To allocate and release a memory block using the default memory allocator we do:

@example
mmux_libc_mall_t  AP;
mmux_pointer_t    bufptr;
auto              buflen = mmux_usize_literal(4096);

mmux_libc_default_memory_allocator_ref(&AP);

if (mmux_libc_memory_allocator_malloc(AP, &bufptr, buflen)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, bufptr)) @{
  /* error */
@}
@end example

@noindent
while the standard @cfunc{free} function and its wrapper @cfunc{mmux_libc_free} will never return an
error condition: the same cannot be said for custom memory allocators; so it is better to test the
return value of @cfunc{mmux_libc_memory_allocator_free}.

For all the following definitions: the macro just casts a pointer @var{result_p} of any type to
@code{mmux_pointer_t *}.

@deftypefn {Preprocessor Macro} bool mmux_libc_memory_allocator_malloc (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{len})
@deftypefnx Function bool mmux_libc_memory_allocator_malloc_ (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{len})
Call the function of the given memory allocator.
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_memory_allocator_calloc (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx {Function} bool mmux_libc_memory_allocator_calloc_ (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
Call the function of the given memory allocator.

@example
mmux_libc_mall_t  AP;
mmux_pointer_t    items_ptr;
auto              item_num = mmux_usize(123);
auto              item_len = mmux_usize(4096);

mmux_libc_default_memory_allocator_ref(&AP);

if (mmux_libc_memory_allocator_calloc(AP, &items_ptr, item_num, item_len)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, items_ptr)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_memory_allocator_realloc (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{newlen})
@deftypefnx {Function} bool mmux_libc_memory_allocator_realloc_ (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{newlen})
Call the function of the given memory allocator.

@example
mmux_libc_mall_t  AP;
mmux_pointer_t    bufptr;
auto              buflen = mmux_usize(4096);
auto              newlen = mmux_usize(2 * 4096);

mmux_libc_default_memory_allocator_ref(&AP);

if (mmux_libc_memory_allocator_malloc(AP, &bufptr, buflen)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_realloc(AP, &bufptr, newlen)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, bufptr)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_memory_allocator_reallocarray (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx {Function} bool mmux_libc_memory_allocator_reallocarray_ (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
Call the function of the given memory allocator.

@example
mmux_libc_mall_t  AP;
mmux_pointer_t    items_ptr;
auto              item_num  = mmux_usize(123);
auto              item_len  = mmux_usize(4096);
auto              item_num2 = mmux_usize(2 * 123);

mmux_libc_default_memory_allocator_ref(&AP);

if (mmux_libc_memory_allocator_calloc(AP, &items_ptr, item_num, item_len)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_reallocarray(AP, &items_ptr, item_num2, item_len)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, bufptr)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_memory_allocator_free (mmux_libc_mall_t @var{allocp}, mmux_pointer_t @var{p})
Call the function of the given memory allocator.
@end deftypefun


@deftypefn {Preprocessor Macro} bool mmux_libc_memory_allocator_malloc_and_copy (mmux_libc_mall_t @var{allocator}, mmux_pointer_t * @var{dstptr_p}, mmux_pointer_t @var{srcptr}, mmux_usize_t @var{srclen})
@deftypefnx {Function} bool mmux_libc_memory_allocator_malloc_and_copy_ (mmux_libc_mall_t @var{allocator}, mmux_pointer_t * @var{dstptr_p}, mmux_pointer_t @var{srcptr}, mmux_usize_t @var{srclen})
Call the function of the given memory allocator.

@example
mmux_libc_mall_t  AP;
char              srcstr = "/path/to/file.ext";
mmux_usize_t      srclen_plus;
char *            dststr;

mmux_libc_default_memory_allocator_ref(&AP);

mmux_libc_strlen_plus_nil(&srclen_plus, srcstr);

if (mmux_libc_memory_allocator_malloc_and_copy(AP, &dststr, srcstr, srclen_plus)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, dststr)) @{
  /* error */
@}
@end example
@end deftypefn

@c page
@node memory allocators default
@subsection Default memory allocator


@value{PACKAGE} defines a default memory allocator that just uses the standard memory allocation
functions.


@deftypefun bool mmux_libc_default_memory_allocator_ref (mmux_libc_mall_t * @var{result_p})
Retrieve a pointer to the default memory allocator defined by @value{PACKAGE} and store it in the
variable referenced by @var{result_p}.
@end deftypefun

@c page
@node memory allocators fake
@subsection Fake memory allocator


@value{PACKAGE} defines a fake memory allocator to be used to manage statically allocated data.  In
the class of the fake memory allocator: only the following functions are actually implemented:

@table @code
@item malloc_and_copy
just store the argument @var{srcptr} in the variable referenced by the argument @var{dstptr_p}, then
return @cfalse{}.

@item free
does nothing and return @cfalse{};
@end table

@noindent
all the other functions set @code{errno} to @samp{MMUX_LIBC_ENOSYS} then return @ctrue{} to report
an error.

Let's look at the following code:

@example
mmux_libc_mall_t  AP;
char              srcstr = "/path/to/file.ext";
mmux_usize_t      srclen_plus;
char *            dststr;

retrieve_a_memory_allocator(&AP);

mmux_libc_strlen_plus_nil(&srclen_plus, srcstr)
if (mmux_libc_memory_allocator_malloc_and_copy(AP, &dststr, srcstr, srclen_plus)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, dststr)) @{
  /* error */
@}
@end example

@noindent
it will work with both the default and the fake allocators:

@itemize
@item
with the default allocator: a new copy of the string is dynamically allocated with the method
@code{malloc_and_copy} and then released with the method @code{free};

@item
with the fake allocator: @code{srcstr} is stored in @code{dststr} by the method
@code{malloc_and_copy} and the method @code{free} just does nothing;
@end itemize

@noindent
this way we can transparently use statically allocated data and dynamically allocated data.  It is
responsibility of the caller to handle correctly mutable and immutable data.


@deftypefun bool mmux_libc_fake_memory_allocator_ref (mmux_libc_mall_t * @var{result_p})
Retrieve a pointer to the fake memory allocator defined by @value{PACKAGE} and store it in the
variable referenced by @var{result_p}.
@end deftypefun

@c page
@node memory allocators example
@subsection How to implement a memory allocator


We can adapt the following implementation of the default allocator:

@example
static bool
spiffy_memory_allocator_malloc (mmux_libc_mall_t allocp __attribute__((__unused__)),
                                mmux_pointer_t * result_p, mmux_usize_t len)
@{
  return mmux_libc_malloc_(result_p, len);
@}
static bool
spiffy_memory_allocator_calloc (mmux_libc_mall_t allocp __attribute__((__unused__)),
                                mmux_pointer_t * result_p,
                                mmux_usize_t item_num, mmux_usize_t item_len)
@{
  return mmux_libc_calloc_(result_p, item_num, item_len);
@}
static bool
spiffy_memory_allocator_realloc (mmux_libc_mall_t allocp __attribute__((__unused__)),
                                 mmux_pointer_t * result_p, mmux_usize_t newlen)
@{
  return mmux_libc_realloc_(result_p, newlen);
@}
static bool
spiffy_memory_allocator_reallocarray (mmux_libc_mall_t allocp __attribute__((__unused__)),
                                      mmux_pointer_t * result_p, mmux_usize_t item_num,
                                      mmux_usize_t item_len)
@{
  return mmux_libc_reallocarray_(result_p, item_num, item_len);
@}
static bool
spiffy_memory_allocator_free (mmux_libc_mall_t allocp __attribute__((__unused__)),
                              mmux_pointer_t p)
@{
  return mmux_libc_free(p);
@}
bool
spiffy_memory_allocator_malloc_and_copy (mmux_libc_mall_t allocp __attribute__((__unused__)),
                                         mmux_pointer_t * dstptr_p,
                                         mmux_pointer_t srcptr, mmux_usize_t srclen)
@{
  return mmux_libc_malloc_and_copy_(dstptr_p, srcptr, srclen);
@}

static mmux_libc_memory_allocator_value_t const spiffy_memory_allocator_value = @{
  .data = NULL,
@};

static mmux_libc_memory_allocator_class_t const spiffy_memory_allocator_class = @{
  .malloc                      = spiffy_memory_allocator_malloc,
  .realloc                     = spiffy_memory_allocator_realloc,
  .calloc                      = spiffy_memory_allocator_calloc,
  .reallocarray                = spiffy_memory_allocator_reallocarray,
  .free                        = spiffy_memory_allocator_free,
  .malloc_and_copy             = mmux_libc_default_memory_allocator_malloc_and_copy,
@};

static mmux_libc_memory_allocator_t const spiffy_memory_allocator = @{
  .value      = (mmux_libc_memory_allocator_value_t *) &spiffy_memory_allocator_value,
  .class      = &spiffy_memory_allocator_class,
@};

bool
spiffy_memory_allocator_ref (mmux_libc_mall_t * result_p)
@{
  *result_p = &spiffy_memory_allocator;
  return false;
@}
@end example

@c page
@node strings
@chapter String operations


@menu
* strings inspection::          Inspecting @MmuxAsciiZ{} strings.
* strings duplication::         Duplicating @MmuxAsciiZ{} strings.
* strings concatenation::       Concatenating @MmuxAsciiZ{} strings.
* strings comparison::          Comparing @MmuxAsciiZ{} strings.
* strings collation::           Collation builtins for @MmuxAsciiZ{} strings.
* strings searching::           Searching in @MmuxAsciiZ{} strings.
* strings tokens::              Finding tokens in @MmuxAsciiZ{} strings.
@end menu

@c page
@node strings inspection
@section Inspecting @MmuxAsciiZ{} strings


@deftypefun bool mmux_libc_strlen (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr})
@MmuxCInterface{strlen}.

@example
mmux_asciizcp_t         bufptr = "the colour of water";
mmux_usize_t            buflen;

if (mmux_libc_strlen(&buflen, bufptr)) @{
  /* error, it should never happen */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strlen_plus_nil (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr})
Wrapper for @cfunc{mmux_libc_strlen} that adds @samp{1} to the result of the call to @cfunc{strlen};
so the number of characters stored in the variable referenced by @var{result_len_p} includes the
terminating null character.
@end deftypefun


@deftypefun bool mmux_libc_strnlen (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr}, mmux_usize_t @var{maxlen})
@MmuxCInterface{strnlen}.

@example
mmux_asciizcp_t  bufptr = "the colour of water";
auto             maxlen = mmux_usize_literal(10);
typeof(maxlen)   buflen;

if (mmux_libc_strnlen(&buflen, bufptr, maxlen)) @{
  /* error, it should never happen */
@}
@end example
@end deftypefun

@c page
@node strings duplication
@section Duplicating @MmuxAsciiZ{} strings


@deftypefun bool mmux_libc_strcpy (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{strcpy}.

@example
//                         01234567890123456789
mmux_asciizcp_t  srcptr = "the colour of water";
char             dstptr[20];

mmux_libc_strcpy(dstptr, srcptr);
assert('\0' == dstptr[19]);
@end example
@end deftypefun


@deftypefun bool mmux_libc_strncpy (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncpy}.

@example
//                         012345678901234567890
mmux_asciizcp_t  srcptr = "the colour of water";
auto             dstlen = mmux_usize_literal(64);
char             dstptr[dstlen.value];

assert(false == mmux_libc_strncpy(dstptr, srcptr, dstlen));
assert('\0' == dstptr[19]);
@end example
@end deftypefun


@deftypefun bool mmux_libc_stpcpy(mmux_asciizp_t * @var{result_next_ptr_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{stpcpy}.

@example
//                         012345678901234567890
mmux_asciizcp_t  srcptr = "the colour of water";
char             dstptr[20];
mmux_asciizp_t   next_dstptr;

assert(false == mmux_libc_stpcpy(&next_dstptr, dstptr, srcptr));
assert('\0' == *next_dstptr);
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_stpncpy(mmux_asciizp_t * @var{result_next_ptr_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{stpncpy}.

@example
//                         012345678901234567890
mmux_asciizcp_t  srcptr = "the colour of water";
auto             dstlen = mmux_usize_literal(64);
char             dstptr[dstlen.value];
mmux_asciizp_t   next_dstptr;

assert(false == mmux_libc_stpncpy(&next_dstptr, dstptr, srcptr, dstlen));
assert('\0' == *next_dstptr);
@end example
@end deftypefn


@deftypefun bool mmux_libc_strdup (mmux_asciizcp_t * @var{result_oustr_p}, mmux_asciizcp_t @var{instr})
@MmuxCInterface{strdup}.

@example
mmux_asciizcp_t     srcptr = "the colour of water";
mmux_asciizcp_t     dstptr;

if (mmux_libc_strdup(&dstptr, srcptr)) @{
  /* error */
@} else @{
  ...
  mmux_libc_free((mmux_pointer_t)dstptr);
@}
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_strndup (mmux_asciizcp_t * @var{result_oustr_p}, mmux_asciizcp_t @var{instr}, mmux_usize_t @var{len})
@MmuxCInterface{strndup}.

@example
//                         012345678901234567890
mmux_asciizcp_t  srcptr = "the colour of water";
auto             dstlen = mmux_usize_literal(10);
mmux_asciizcp_t  dstptr;

if (mmux_libc_strndup(&dstptr, srcptr, dstlen)) @{
  /* error */
@} else @{
  ...
  mmux_libc_free((mmux_pointer_t)dstptr);
@}
@end example
@end deftypefn

@c page
@node strings concatenation
@section Concatenating @MmuxAsciiZ{} strings


@deftypefun bool mmux_libc_strcat (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{strcat}.

@example
//                          01234567890123456789012345678901234567890
//                                    1         2         3         4
mmux_asciizcp_t  srcptr1 = "the colour of water";
mmux_asciizcp_t  srcptr2 =                    " and quicksilver";
auto             dstlen  = mmux_usize_literal(36);
char             dstptr[dstlen.value];

mmux_libc_memzero(dstptr, dstlen);

assert(false == mmux_libc_strcat(dstptr, srcptr1));
assert('\0' == dstptr[19]);

assert(false == mmux_libc_strcat(dstptr, srcptr2));
assert('\0' == dstptr[35]);
@end example
@end deftypefun


@deftypefun bool mmux_libc_strncat (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncat}.

@example
//                          01234567890123456789012345678901234567890
//                                    1         2         3         4
mmux_asciizcp_t  srcptr1 = "the colour of water ha! ha! ha!";
mmux_asciizcp_t  srcptr2 =                    " and quicksilver ha!";
//                                             012345678901234567890
auto             dstlen  = mmux_usize_literal(36);
char             dstptr[dstlen.value];

auto             len1    = mmux_usize_literal(19);
auto             len2    = mmux_usize_literal(16);

mmux_libc_memzero(dstptr, dstlen);

assert(false == mmux_libc_strncat(dstptr, srcptr1, len1));
assert('\0' == dstptr[19]);

assert(false == mmux_libc_strncat(dstptr, srcptr2, len2));
assert('\0' == dstptr[35]);
@end example
@end deftypefun

@c page
@node strings comparison
@section Comparing @MmuxAsciiZ{} strings


@deftypefun bool mmux_libc_strequ (bool * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr})
@MmuxCInterface{strcmp}.  Store @ctrue{} in the variable referenced by @var{result_p} if the strings
referenced by @vari{ptr} and @varii{ptr} are equal according to @cfunc{strcmp}; otherwise store
@cfalse{}.

@example
@{
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  bool              result;

  assert(false == mmux_libc_strequ(&result, bufptr_one, bufptr_two));
  assert(false == result);
@}
@{
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of water";
  bool              result;

  assert(false == mmux_libc_strequ(&result, bufptr_one, bufptr_two));
  assert(true  == result);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strnequ (bool * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncmp}.  Compare at most @var{len} characters in the given strings: store @ctrue{}
in the variable referenced by @var{result_p} if the strings referenced by @vari{ptr} and @varii{ptr}
are equal according to @cfunc{strncmp}; otherwise store @cfalse{}.

@example
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  auto              buflen     = mmux_usize_literal(15);
  bool              result;

  assert(false == mmux_libc_strnequ(&result, bufptr_one, bufptr_two, buflen));
  assert(false == result);
@}
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of water";
  auto              buflen     = mmux_usize_literal(15);
  bool              result;

  assert(false == mmux_libc_strnequ(&result, bufptr_one, bufptr_two, buflen));
  assert(true  == result);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strcmp (mmux_ternary_comparison_result_t * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr})
@MmuxCInterface{strcmp}.

@example
@{
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  mmux_ternary_comparison_result_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strcmp(&result, bufptr_one, bufptr_two));
  assert(mmux_ternary_comparison_result_is_greater(result));
@}
@{
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  mmux_ternary_comparison_result_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strcmp(&result, bufptr_two, bufptr_one));
  assert(mmux_ternary_comparison_result_is_less(result));
@}
@{
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of water";
  mmux_ternary_comparison_result_t       result;

  assert(false == mmux_libc_strcmp(&result, bufptr_two, bufptr_one));
  assert(mmux_ternary_comparison_result_is_equal(result));
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strncmp (mmux_ternary_comparison_result_t * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncmp}.
@end deftypefun


@deftypefun bool mmux_libc_strcasecmp (mmux_ternary_comparison_result_t * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr})
@MmuxCInterface{strcasecmp}.

@example
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  auto              buflen     = mmux_usize_literal(15);
  mmux_ternary_comparison_result_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strncmp(&result, bufptr_one, bufptr_two, buflen));
  assert(mmux_ternary_comparison_result_is_greater(result));
@}
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  auto              buflen     = mmux_usize_literal(15);
  mmux_ternary_comparison_result_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strncmp(&result, bufptr_two, bufptr_one, buflen));
  assert(mmux_ternary_comparison_result_is_less(result));
@}
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  auto              buflen     = mmux_usize_literal(10);
  mmux_ternary_comparison_result_t       result;

  assert(false == mmux_libc_strncmp(&result, bufptr_two, bufptr_one, buflen));
  assert(mmux_ternary_comparison_result_is_equal(result));
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strncasecmp (mmux_ternary_comparison_result_t * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncasecmp}.

@example
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the COLOUR OF WAter";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  auto              buflen     = mmux_usize_literal(15);
  mmux_ternary_comparison_result_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strncasecmp(&result, bufptr_one, bufptr_two, buflen));
  assert(mmux_ternary_comparison_result_is_greater(result));
@}
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the COLOUR OF water";
  mmux_asciizcp_t   bufptr_two = "the colour of QUICKSILVER";
  auto              buflen     = mmux_usize_literal(15);
  mmux_ternary_comparison_result_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strncasecmp(&result, bufptr_two, bufptr_one, buflen));
  assert(mmux_ternary_comparison_result_is_less(result));
@}
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the COLOUR OF WATER";
  mmux_asciizcp_t   bufptr_two = "the colour OF quicksilver";
  auto              buflen     = mmux_usize_literal(10);
  mmux_ternary_comparison_result_t       result;

  assert(false == mmux_libc_strncasecmp(&result, bufptr_two, bufptr_one, buflen));
  assert(mmux_ternary_comparison_result_is_equal(result));
@}
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_strverscmp (mmux_ternary_comparison_result_t * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr})
@MmuxCInterface{strverscmp}.

@example
@{
  mmux_asciizcp_t   bufptr_one = "1.2.3";
  mmux_asciizcp_t   bufptr_two = "1.2.8";
  mmux_ternary_comparison_result_t       result;

  // '8' > '3' so bufptr_one < bufptr_two */
  assert(false == mmux_libc_strverscmp(&result, bufptr_one, bufptr_two));
  assert(mmux_ternary_comparison_result_is_less(result));
@}
@{
  mmux_asciizcp_t   bufptr_one = "1.2.3";
  mmux_asciizcp_t   bufptr_two = "1.2.8";
  mmux_ternary_comparison_result_t       result;

  // '8' > '3' so bufptr_one < bufptr_two */
  assert(false == mmux_libc_strverscmp(&result, bufptr_two, bufptr_one));
  assert(mmux_ternary_comparison_result_is_greater(result));
@}
@{
  mmux_asciizcp_t   bufptr_one = "1.2.3";
  mmux_asciizcp_t   bufptr_two = "1.2.3";
  mmux_ternary_comparison_result_t       result;

  assert(false == mmux_libc_strverscmp(&result, bufptr_two, bufptr_one));
  assert(mmux_ternary_comparison_result_is_equal(result));
@}
@end example
@end deftypefn

@c page
@node strings collation
@section Collation builtins for @MmuxAsciiZ{} strings


@deftypefun bool mmux_libc_strcoll (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr})
@MmuxCInterface{strcoll}.

@example
mmux_asciizcp_t   bufptr_one = "the colour of water";
mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
mmux_sint_t       result;

// 'w' > 'q' so bufptr_one > bufptr_two */
assert(false == mmux_libc_strcoll(&result, bufptr_one, bufptr_two));
assert(mmux_ctype_is_positive(result));
@end example
@end deftypefun


@deftypefun bool mmux_libc_strxfrm (mmux_usize_t * @var{result_size_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strxfrm}.
@end deftypefun

@c page
@node strings searching
@section Searching in @MmuxAsciiZ{} strings


@deftypefun bool mmux_libc_strchr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strchr}.

@example
@{
  //                          012345678901234567890123456789012345
  mmux_asciizcp_t   bufptr = "the colour of water And quicksilver";
  auto              it     = mmux_char_literal('A');
  mmux_asciizcp_t   result;

  assert(false == mmux_libc_strchr(&result, bufptr, it));
  assert( (mmux_standard_ptrdiff_t) (result - bufptr) == 20 );
@}
@{
  //                          012345678901234567890123456789012345
  mmux_asciizcp_t   bufptr = "the colour of water and quicksilver";
  auto              it     = mmux_char_literal('Y');
  mmux_asciizcp_t   result;

  assert(false == mmux_libc_strchr(&result, bufptr, it));
  assert( NULL == result );
@}
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_strchrnul (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strchrnul}.

@example
@{
  //                          012345678901234567890123456789012345
  mmux_asciizcp_t   bufptr = "the colour of water And quicksilver";
  auto              it     = mmux_char_literal('A');
  mmux_asciizcp_t   result;

  assert(false == mmux_libc_strchrnul(&result, bufptr, it));
  assert( (mmux_standard_ptrdiff_t) (result - bufptr) == 20 );
@}
@{
  //                          012345678901234567890123456789012345
  //                                    1         2         3
  mmux_asciizcp_t   bufptr = "the colour of water and quicksilver";
  auto              it     = mmux_char_literal('Y');
  mmux_asciizcp_t   result;

  assert(false == mmux_libc_strchrnul(&result, bufptr, it));
  assert( (mmux_standard_ptrdiff_t) (result - bufptr) == 35 );
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_strrchr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strrchr}.

@example
@{
  //                          012345678901234567890123456789012345
  mmux_asciizcp_t   bufptr = "the colour of water And quicksilver";
  auto              it     = mmux_char_literal('A');
  mmux_asciizcp_t   result;

  assert(false == mmux_libc_strrchr(&result, bufptr, it));
  assert( (mmux_standard_ptrdiff_t) (result - bufptr) == 20 );
@}
@{
  //                          012345678901234567890123456789012345
  mmux_asciizcp_t   bufptr = "the colour of water and quicksilver";
  auto              it     = mmux_char_literal('Y');
  mmux_asciizcp_t   result;

  assert(false == mmux_libc_strrchr(&result, bufptr, it));
  assert( NULL == result );
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strstr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{haystack}, mmux_asciizcp_t @var{needle})
@MmuxCInterface{strstr}.

@example
//                                01234567890123456789
mmux_asciizcp_t   haystack_ptr = "the colour of water";
mmux_asciizcp_t   needle_ptr   = "colour";
mmux_asciizcp_t   result;

assert(false == mmux_libc_strstr(&result, haystack_ptr, needle_ptr));
assert( (mmux_standard_ptrdiff_t)(result - haystack_ptr) == 4 );
@end example
@end deftypefun


@deftypefun bool mmux_libc_strcasestr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{haystack}, mmux_asciizcp_t @var{needle})
@MmuxCInterface{strcasestr}.

@example
//                                          01234567890123456789
mmux_asciizcp_t   haystack_ptr = "the colOUR OF water";
mmux_asciizcp_t   needle_ptr   = "COLour";
mmux_asciizcp_t   result;

assert(false == mmux_libc_strcasestr(&result, haystack_ptr, needle_ptr));
assert( NULL != result );
assert( (mmux_standard_ptrdiff_t)(result - haystack_ptr) == 4);
@end example
@end deftypefun


@deftypefun bool mmux_libc_strspn (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{skipset})
@MmuxCInterface{strspn}.

@example
@{
  //                            012345678901
  mmux_asciizcp_t   str_ptr  = "123.456e789";
  mmux_asciizcp_t   skip_ptr = "0123456789.";
  mmux_usize_t      result;

  assert(false == mmux_libc_strspn(&result, str_ptr, skip_ptr));
  assert(7 == result.value);
@}
@{
  //                            01 234 5 6 789012345
  mmux_asciizcp_t   str_ptr  = " \t  \t\n\nciao";
  mmux_asciizcp_t   skip_ptr = " \t\n\r";
  mmux_usize_t      result;

  assert(false == mmux_libc_strspn(&result, str_ptr, skip_ptr));
  assert(7 == result.value);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strcspn (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{stopset})
@MmuxCInterface{strcspn}.

@example
@{
  //                            012345678901
  mmux_asciizcp_t   str_ptr  = "123.456e789";
  mmux_asciizcp_t   skip_ptr = "e";
  mmux_usize_t      result;

  assert(false == mmux_libc_strcspn(&result, str_ptr, skip_ptr));
  assert(7 == result.value);
@}
@{
  //                            01 234 5 6 789012345
  mmux_asciizcp_t   str_ptr  = " \t  \t\n\nciao";
  mmux_asciizcp_t   skip_ptr = "acio";
  mmux_usize_t      result;

  assert(false == mmux_libc_strcspn(&result, str_ptr, skip_ptr));
  assert(7 == result.value);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strpbrk (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{stopset})
@MmuxCInterface{strpbrk}.

@example
@{
  //                            012345678901
  mmux_asciizcp_t   str_ptr  = "123.456e789";
  mmux_asciizcp_t   skip_ptr = "e";
  mmux_asciizcp_t   result;

  assert(false == mmux_libc_strpbrk(&result, str_ptr, skip_ptr));
  assert(7 == (mmux_standard_ptrdiff_t)(result - str_ptr));
@}
@{
  //                            01 234 5 6 789012345
  mmux_asciizcp_t   str_ptr  = " \t  \t\n\nciao";
  mmux_asciizcp_t   skip_ptr = "acio";
  mmux_asciizcp_t   result;

  assert(false == mmux_libc_strpbrk(&result, str_ptr, skip_ptr));
  assert(7 == (mmux_standard_ptrdiff_t)(result - str_ptr));
@}
@end example
@end deftypefun

@c page
@node strings tokens
@section Finding tokens in @MmuxAsciiZ{} strings


@deftypefun bool mmux_libc_strtok (mmux_asciizp_t * @var{result_p}, mmux_asciizp_t @var{newstring}, mmux_asciizcp_t @var{delimiters})
@MmuxCInterface{strtok}.

@example
mmux_asciizcp_t   orgptr = "uno due\ttre\nquattro";
mmux_usize_t      orglen;
mmux_asciizcp_t   delimiters = " \t\n\r";
mmux_asciizp_t    bufptr;
mmux_asciizp_t    newptr;
mmux_asciizp_t    result;

assert(false == mmux_libc_strlen(&orglen, orgptr));
assert(false == mmux_libc_malloc_and_copy(&bufptr, orgptr, orglen));
@{
  newptr = bufptr;
  assert(false == mmux_libc_strtok(&result, newptr, delimiters));
  mmux_libc_dprintfer("1=%s, ", result);

  newptr = result;
  assert(false == mmux_libc_strtok(&result, newptr, delimiters));
  mmux_libc_dprintfer("2=%s, ", result);

  newptr = result;
  assert(false == mmux_libc_strtok(&result, newptr, delimiters));
  mmux_libc_dprintfer("3=%s, ", result);

  newptr = result;
  assert(false == mmux_libc_strtok(&result, newptr, delimiters));
  mmux_libc_dprintfer("4=%s, ", result);
@}
assert(false == mmux_libc_free(bufptr));
@end example
@end deftypefun

@deftypefun bool mmux_libc_strtok_r (mmux_asciizp_t * result_p, mmux_asciizp_t newstring, mmux_asciizcp_t delimiters, mmux_asciizp_t * save_ptr)
@MmuxCInterface{strtok_r}.

@example
mmux_asciizcp_t   orgptr = "uno due\ttre\nquattro";
mmux_usize_t      orglen;
mmux_asciizcp_t   delimiters = " \t\n\r";
mmux_asciizp_t    save_ptr;
mmux_asciizp_t    bufptr;
mmux_asciizp_t    newptr;
mmux_asciizp_t    result;

assert(false == mmux_libc_strlen(&orglen, orgptr));
assert(false == mmux_libc_malloc_and_copy(&bufptr, orgptr, orglen));
@{
  newptr = bufptr;
  assert(false == mmux_libc_strtok_r(&result, newptr, delimiters, &save_ptr));
  mmux_libc_dprintfer("1=%s, ", result);

  newptr = result;
  assert(false == mmux_libc_strtok_r(&result, newptr, delimiters, &save_ptr));
  mmux_libc_dprintfer("2=%s, ", result);

  newptr = result;
  assert(false == mmux_libc_strtok_r(&result, newptr, delimiters, &save_ptr));
  mmux_libc_dprintfer("3=%s, ", result);

  newptr = result;
  assert(false == mmux_libc_strtok_r(&result, newptr, delimiters, &save_ptr));
  mmux_libc_dprintfer("4=%s, ", result);
@}
assert(false == mmux_libc_free(bufptr));
@end example
@end deftypefun


@deftypefun bool mmux_libc_strsep (mmux_asciizp_t * result_p, mmux_asciizp_t * newstring_p, mmux_asciizcp_t delimiters)
@MmuxCInterface{strsep}.

@example
mmux_asciizcp_t   orgptr = "uno due\ttre\nquattro";
mmux_usize_t      orglen;
mmux_asciizcp_t   delimiters = " \t\n\r";
mmux_asciizp_t    bufptr;
mmux_asciizp_t    newptr;
mmux_asciizp_t    result;

assert(false == mmux_libc_strlen(&orglen, orgptr));
assert(false == mmux_libc_malloc_and_copy(&bufptr, orgptr, orglen));
@{
  newptr = bufptr;
  assert(false == mmux_libc_strsep(&result, &newptr, delimiters));
  mmux_libc_dprintfer("1=%s, ", result);

  assert(false == mmux_libc_strsep(&result, &newptr, delimiters));
  mmux_libc_dprintfer("2=%s, ", result);

  assert(false == mmux_libc_strsep(&result, &newptr, delimiters));
  mmux_libc_dprintfer("3=%s, ", result);

  assert(false == mmux_libc_strsep(&result, &newptr, delimiters));
  mmux_libc_dprintfer("4=%s, ", result);
@}
assert(false == mmux_libc_free(bufptr));
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefn {@gnu{} Function} bool mmux_libc_basename (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{pathname})
@MmuxCInterface{basename}.

@example
mmux_asciizcp_t     pathname = "/path/to/file.ext";
mmux_asciizcp_t     filename;

assert(false == mmux_libc_basename(&filename, pathname));
@{
  bool      result;

  assert(false == mmux_libc_strequ(&result, filename, "file.ext"));
  assert(true  == result);
@}
@end example
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_dirname (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{pathname})
@MmuxCInterface{dirname}.  Notice that the string referenced by @var{pathname} is mutated.

@example
mmux_asciizcp_t     orgpath = "/path/to/file.ext";
mmux_usize_t        orglen;
mmux_asciizcp_t     pathname;
mmux_asciizcp_t     dirname;

mmux_libc_strlen(&orglen, orgpath);
assert(false == mmux_libc_malloc_and_copy(&pathname, orgpath, orglen));
assert(false == mmux_libc_dirname(&dirname, pathname));
@{
  bool      result;
  assert(false == mmux_libc_strequ(&result, dirname, "/path/to"));
  assert(true  == result);
@}
@end example
@end deftypefn

@c page
@node characters
@chapter Character operations


@menu
* characters classes::          Character classes.
* characters capital::          Character capitalisation.
@end menu

@c page
@node characters classes
@section Character classes


@deftypefun bool mmux_libc_islower (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{islower}.

@example
auto      it = mmux_char_literal('a');
bool      result;

assert(false == mmux_libc_islower(&result, it));
assert(true  == result);
@end example
@end deftypefun


@deftypefun bool mmux_libc_isupper (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isupper}.

@example
auto      it = mmux_char_literal('a');
bool      result;

assert(false == mmux_libc_isupper(&result, it));
assert(false == result);
@end example
@end deftypefun


@deftypefun bool mmux_libc_isalpha (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isalpha}.

@example
auto      it = mmux_char_literal('A');
bool      result;

assert(false == mmux_libc_isalpha(&result, it));
assert(true  == result);
@end example
@end deftypefun


@deftypefun bool mmux_libc_isdigit (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isdigit}.

@example
auto      it = mmux_char_literal('7');
bool      result;

assert(false == mmux_libc_isdigit(&result, it));
assert(true  == result);
@end example
@end deftypefun


@deftypefun bool mmux_libc_isalnum (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isalnum}.
@end deftypefun


@deftypefun bool mmux_libc_isxdigit (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isxdigit}.
@end deftypefun


@deftypefun bool mmux_libc_ispunct (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{ispunct}.
@end deftypefun


@deftypefun bool mmux_libc_isspace (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isspace}.
@end deftypefun


@deftypefun bool mmux_libc_isblank (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isblank}.
@end deftypefun


@deftypefun bool mmux_libc_isgraph (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isgraph}.
@end deftypefun


@deftypefun bool mmux_libc_isprint (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isprint}.
@end deftypefun


@deftypefun bool mmux_libc_iscntrl (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{iscntrl}.
@end deftypefun


@deftypefun bool mmux_libc_isascii (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isascii}.
@end deftypefun

@c page
@node characters capital
@section Character capitalisation


@deftypefun bool mmux_libc_tolower (mmux_char_t * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{tolower}.
@end deftypefun


@deftypefun bool mmux_libc_toupper (mmux_char_t * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{toupper}.
@end deftypefun

@c page
@node time
@chapter Times and dates


@menu
* time timeval::                The @objtype{mmux_libc_timeval_t} type.
* time timespec::               The @objtype{mmux_libc_timespec_t} type.
* time tm::                     The @objtype{mmux_libc_tm_t} type.
* time acquiring::              Acquiring the current time.
* time epoch time::             Converting from Epoch time to other formats.
* time broken time::            Converting from broken time to other formats.
* time format::                 Formatting string timestamps.
* time parsing::                Converting from string timestamps to other formats.
* time sleeping::               Suspending a process for a time.
@end menu

@c page
@node time timeval
@section The @objtype{mmux_libc_timeval_t} type


To initialise and inspect a value of type @objtype{mmux_libc_timeval_t} we do:

@example
mmux_libc_timeval_t  TV[1];

/* setters */
@{
  auto      sec  = mmux_time_literal(12);
  auto      usec = mmux_slong_literal(34);

  mmux_libc_tv_sec_set  (TV, sec);
  mmux_libc_tv_usec_set (TV, usec);
@}

/* getters */
@{
  mmux_time_t       sec;
  mmux_slong_t      usec;

  mmux_libc_tv_sec_ref  (&sec,  TV);
  mmux_libc_tv_usec_ref (&usec, TV);
@}

/* another setter */
@{
  auto    sec  = mmux_time_literal(56);
  auto    usec = mmux_slong_literal(78);

  mmux_libc_timeval_set(TV, sec, usec);
@}

/* dumping */
@{
  mmux_libc_fd_t    fd;

  mmux_libc_stder(fd);
  if (mmux_libc_timeval_dump(fd, TV, NULL)) @{
    /* error */
  @}
@}
@print{} struct timeval = 0x7ffea9a701f0
@print{} struct timeval->tv_sec = 56 [seconds]
@print{} struct timeval->tv_usec = 78 [microseconds]
@end example


@MmuxCStructOpaqueTypedef{timeval}
@MmuxSetterGetter{timeval, tv_sec,  mmux_time_t}
@MmuxSetterGetter{timeval, tv_usec, mmux_slong_t}
@MmuxStructDumper{timeval}


@deftypefun bool mmux_libc_timeval_set (mmux_libc_timeval_t * @var{timeval_p}, mmux_time_t @var{seconds}, mmux_slong_t @var{microseconds})
Initialise the fields of a @MmuxCStruct{timeval}.
@end deftypefun

@c page
@node time timespec
@section The @objtype{mmux_libc_timespec_t} type


To have more expressive names: in this @api{} we ``rename'' the fields @samp{tv_sec} and
@samp{tv_nsec} of @MmuxCStruct{timespec} to @samp{ts_sec} and @samp{ts_nsec}.

To initialise and inspect a value of type @objtype{mmux_libc_timespec_t} we do:

@example
mmux_libc_timespec_t  TS[1];

/* setters */
@{
  auto    sec  = mmux_time_literal(12);
  auto    nsec = mmux_slong_literal(34);

  mmux_libc_ts_sec_set  (TS, sec);
  mmux_libc_ts_nsec_set (TS, nsec);
@}

/* getters */
@{
  mmux_time_t     sec;
  mmux_slong_t    nsec;

  mmux_libc_ts_sec_ref  (&sec,  TS);
  mmux_libc_ts_nsec_ref (&nsec, TS);
@}

/* another setter */
@{
  auto    sec  = mmux_time_literal(56);
  auto    nsec = mmux_slong_literal(78);

  mmux_libc_timespec_set(TS, sec, nsec);
@}

/* dumping */
@{
  mmux_libc_fd_t    fd;

  mmux_libc_stder(fd);
  if (mmux_libc_timespec_dump(fd, TS, NULL)) @{
    /* error */
  @}
@}
@end example


@MmuxCStructOpaqueTypedef{timespec}
@MmuxSetterGetter{timespec, ts_sec,  mmux_time_t}
@MmuxSetterGetter{timespec, ts_nsec, mmux_slong_t}
@MmuxStructDumper{timespec}


@deftypefun bool mmux_libc_timespec_set (mmux_libc_timeval_t * @var{timeval_p}, mmux_time_t @var{seconds}, mmux_slong_t @var{nanoseconds})
Initialise the fields of a @MmuxCStruct{timespec}.
@end deftypefun

@c page
@node time tm
@section The @objtype{mmux_libc_tm_t} type


To acquire and dump an instance of @objtype{mmux_libc_tm_t} we do:

@example
mmux_time_t     T;
mmux_libc_tm_t  TM[1];

mmux_libc_time(&T);
mmux_libc_localtime_r(TM, T);
@{
  mmux_libc_fd_t    fd;

  mmux_libc_stder(fd);
  if (mmux_libc_tm_dump(fd, TM, NULL)) @{
    /* error */
  @}
@}
@end example


@MmuxCStructOpaqueTypedef{tm}
@MmuxSetterGetter{tm, tm_sec,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_min,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_hour,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_mday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_mon,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_year,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_wday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_yday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_isdst,       mmux_sint_t}
@MmuxSetterGetter{tm, tm_gmtoff,      mmux_slong_t}
@MmuxSetterGetter{tm, tm_zone,        mmux_asciizcp_t}
@MmuxStructDumper{tm}


@deftypefun bool mmux_libc_tm_reset (mmux_libc_tm_t * @var{TM_P})
Reset the fields to:

@example
tm_sec    = 0
tm_min    = 0
tm_hour   = 0
tm_mday   = 1
tm_mon    = 0
tm_year   = 0
tm_wday   = 0
tm_yday   = 0
tm_isdst  = 0
tm_gmtoff = 0
tm_zone   = NULL
@end example
@end deftypefun

@c page
@node time acquiring
@section Acquiring the current time


@deftypefun bool mmux_libc_time (mmuc_time_t * @var{result_p})
@MmuxCInterface{time}.

@example
mmux_time_t  T;

mmux_libc_time(&T);
@{
  mmux_libc_fd_t    fd;

  mmux_libc_stder(fd);
  if (mmux_libc_dprintf_time(fd, T)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node time epoch time
@section Converting from Epoch time to other formats


@deftypefun bool mmux_libc_localtime (mmux_libc_tm_t * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{localtime}.  Store in the variable referenced by @var{result_p} a pointer to a
statically allocated @objtype{mmux_libc_tm_t} that will be overwritten by future calls to time
functions; we should just use @cfunc{mmux_libc_localtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t *        BT;

mmux_libc_time(&T);
mmux_libc_localtime(&BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_localtime_r (mmux_libc_tm_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{localtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t          BT[1];

mmux_libc_time(&T);
mmux_libc_localtime_r(BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_gmtime (mmux_libc_tm_t * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{gmtime}.  Store in the variable referenced by @var{result_p} a pointer to a
statically allocated @objtype{mmux_libc_tm_t} that will be overwritten by future calls to time
functions; we should just use @cfunc{mmux_libc_gmtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t *        BT;

mmux_libc_time(&T);
mmux_libc_gmtime(&BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_gmtime_r (mmux_libc_tm_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{gmtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t          BT[1];

mmux_libc_time(&T);
mmux_libc_gmtime_r(BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_ctime (mmux_asciizcp_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{ctime}.  The variable referenced by @var{result_p} is set to a pointer to a
statically allocated string, which will be overwritten by future calls to time functions; we should
just use @cfunc{mmux_libc_ctime_r}.

@example
mmux_time_t         T;
mmux_asciizcp_t     bufptr;

mmux_libc_time(&T);
mmux_libc_asctime(&bufptr, T);
if (mmux_libc_dprintfer("the timestamp from ctime is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_ctime_r (mmux_asciizp_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{ctime_r}.

@example
constexpr auto  buflen = mmux_standard_usize_literal(512);
char            bufptr[buflen];
mmux_time_t     T;

mmux_libc_time(&T);
mmux_libc_asctime_r(bufptr, T);
if (mmux_libc_dprintfer("the timestamp from ctime_r is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node time broken time
@section Converting from broken time to other formats


@deftypefun bool mmux_libc_mktime (mmux_time_t * @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{mktime}.

@example
mmux_time_t     T1, T2;
mmux_libc_tm_t  BT[1];

mmux_libc_time(&T1);
mmux_libc_localtime_r(BT, T1);
mmux_libc_mktime(&T2, BT);
@{
  mmux_libc_fd_t    fd;

  mmux_libc_libou(fd);
  if (mmux_libc_dprintf_time(fd, T2)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_timegm (mmux_time_t * @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{timegm}.

@example
mmux_time_t     T1, T2;
mmux_libc_tm_t  BT[1];

mmux_libc_time(&T1);
mmux_libc_localtime_r(BT, T1);
mmux_libc_timegm(&T2, BT);
@{
  mmux_libc_fd_t    fd;

  mmux_libc_libou(fd);
  if (mmux_libc_dprintf_time(fd, T2)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_asctime (mmux_asciizcp_t * @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{asctime}.  The variable referenced by @var{result_p} is set to a pointer to a
statically allocated string, which will be overwritten by future calls to time functions; we should
just use @cfunc{mmux_libc_asctime_r}.

@example
mmux_time_t         T;
mmux_libc_tm_t      BT[1];
mmux_asciizcp_t     bufptr;

mmux_libc_time(&T);
mmux_libc_localtime_r(BT, T);
mmux_libc_asctime(&bufptr, BT);
if (mmux_libc_dprintfer("the timestamp from asctime is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_asctime_r (mmux_asciizcp_t @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{asctime_r}.

@example
mmux_time_t         T;
mmux_libc_tm_t      BT[1];
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK            512
char                bufptr[IS_THIS_ENOUGH_QUESTION_MARK];

mmux_libc_time(&T);
mmux_libc_localtime_r(BT, T);
mmux_libc_asctime_r(bufptr, BT);
if (mmux_libc_dprintfer("the timestamp from asctime_r is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node time format
@section Formatting string timestamps


@deftypefun bool mmux_libc_strftime_required_nbytes_including_nil (mmux_usize_t * @var{required_nbytes_including_nil_p}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
When successful: store in the variable referenced by @var{required_nbytes_including_nil_p} the
number of bytes, @strong{including} the terminating zero, required to hold the string generated by
@cfunc{strftime} when applied to @var{template} to format a time specification from the broken time
@var{BT}.
@end deftypefun


@anchor{mmux_libc_strftime}
@deftypefun bool mmux_libc_strftime (mmux_usize_t * @var{generated_nbytes_without_zero_p}, mmux_asciizp_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{strftime}.  Format an output string representation of the timestamp referenced by
@var{BT} according to @var{template}, and store it in the buffer referenced by @var{bufptr}; at
most @var{buflen} characters, including the terminating zero, will be written to @var{bufptr}.

When successful: the generated string length, without the terminating zero, is stored in the
variable referenced by @var{generated_nbytes_without_zero_p}.

It is sometimes better to use the function @cfunc{mmux_libc_dprintf_strftime},
@ref{mmux_libc_dprintf_strftime} for details.

@example
mmux_asciizcp_t   template = "%Y-%m-%dT%H:%M:%S%z";
mmux_time_t       T;
mmux_libc_tm_t    BT[1];
mmux_usize_t      required_nbytes_including_nil;

mmux_libc_time(&T);
mmux_libc_localtime_r(BT, T);

if (mmux_libc_strftime_required_nbytes_including_nil(&required_nbytes_including_nil, template, BT) @{
  /* error */
@} else @{
  char          bufptr[required_nbytes_including_nil.value];
  mmux_usize_t  generated_nbytes_without_zero;

  if (mmux_libc_strftime(&generated_nbytes_without_zero, bufptr, required_nbytes_including_nil, template, BT)) @{
    /* error */
  @}
@}
mmux_libc_dprintfou("%s\n", bufptr);
@end example
@end deftypefun

@c page
@node time parsing
@section Converting from string timestamps to other formats


@deftypefun bool mmux_libc_strptime (mmux_asciizpp_t @var{first_unprocessed_after_timestamp_p}, mmux_asciizcp_t @var{input_string}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{strptime}.

@example
mmux_asciizcp_t         template     = "The timestamp is: %a, %d %b %Y %H:%M:%S %z";
mmux_asciizcp_t         input_string = "The timestamp is: Fri, 15 Nov 2024 23:11:20 +0100, and that's it!";
mmux_libc_tm_t          BT[1];
mmux_asciizp_t          first_unprocessed_after_timestamp;

if (mmux_libc_strptime(&first_unprocessed_after_timestamp, input_string, template, BT)) @{
  /* error */
@}

@{
  mmux_libc_fd_t    fd;

  mmux_libc_stder(&fd);
  mmux_libc_tm_dump(fd, BT, NULL);
@}
@end example
@end deftypefun

@c page
@node time sleeping
@section Suspending a process for a time


@deftypefun bool mmux_libc_sleep (mmux_uint_t * @var{leftover_result_p}, mmux_uint_t @var{seconds})
@MmuxCInterface{sleep}.

@example
auto         seconds = mmux_uint_literal(2);
mmux_uint_t  leftover;

mmux_libc_sleep(&leftover, seconds);
@end example
@end deftypefun


@deftypefun bool mmux_libc_nanosleep (mmux_libc_timespec_t * @var{requested_time}, mmux_libc_timespec_t * @var{remaining_time})
@MmuxCInterface{nanosleep}.

@example
mmux_libc_timespec_t    requested_time;
mmux_libc_timespec_t    remaining_time;

@{
  auto      seconds     = mmux_time_constant_zero(0);
  auto      nanoseconds = mmux_slong_literal(34);
  mmux_libc_timespec_set(&requested_time, seconds, nanoseconds);
@}
if (mmux_libc_nanosleep(&requested_time, &remaining_time)) @{
  /* error or interruption */
@}
@end example
@end deftypefun

@c page
@node system
@chapter System configuration


@menu
* system configuration parameters::  System configuration parameters.
* system configuration strings::     System configuration strings.
* system configuration fs::          System configuration for file system parameters.
* system configuration limits::      System configuration limits.
@end menu

@c page
@node system configuration parameters
@section System configuration parameters


@cindex @samp{MMUX_LIBC__SC_} constants
@cindex Constants @samp{MMUX_LIBC__SC_}


@deftp {Struct Typedef} mmux_libc_sysconf_parameter_t
Data structure type representing the selector of a configurable parameter whose value fits into a
@objtype{mmux_slong_t}.  The constants @code{MMUX_LIBC__SC_*} are expressions which evaluate to
instances of this type.
@end deftp


@deftypefun bool mmux_libc_sysconf (mmux_slong_t * @var{result_p}, mmux_libc_sysconf_parameter_t @var{parameter})
@MmuxCInterface{sysconf}.  @var{parameter} must be one of the @samp{MMUX_LIBC__SC_*} constants.

@example
mmux_slong_t    result;

if (mmux_libc_sysconf(&result, MMUX_LIBC__SC_PAGESIZE)) @{
  /* error */
@} else @{
  /* the result is in "result" */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineSystemParameterConstant{NAME}
@defvr {Constant} @value{PackageApiPrefixUpper}\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{@value{PackageApiPrefixUpper}\NAME\} evaluates to an instance of
@objtype{mmux_libc_sysconf_parameter_t}; it can be defined or not depending on the features of the
underlying platform.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbol
@samp{@value{PackageApiPrefixUpper}\NAME\} is available.
@end defvr

@end macro

@MmuxDefineSystemParameterConstant{_SC_2_CHAR_TERM}
@MmuxDefineSystemParameterConstant{_SC_2_C_BIND}
@MmuxDefineSystemParameterConstant{_SC_2_C_DEV}
@MmuxDefineSystemParameterConstant{_SC_2_C_VERSION}
@MmuxDefineSystemParameterConstant{_SC_2_FORT_DEV}
@MmuxDefineSystemParameterConstant{_SC_2_FORT_RUN}
@MmuxDefineSystemParameterConstant{_SC_2_LOCALEDEF}
@MmuxDefineSystemParameterConstant{_SC_2_PBS}
@MmuxDefineSystemParameterConstant{_SC_2_PBS_ACCOUNTING}
@MmuxDefineSystemParameterConstant{_SC_2_PBS_CHECKPOINT}
@MmuxDefineSystemParameterConstant{_SC_2_PBS_LOCATE}
@MmuxDefineSystemParameterConstant{_SC_2_PBS_MESSAGE}
@MmuxDefineSystemParameterConstant{_SC_2_PBS_TRACK}
@MmuxDefineSystemParameterConstant{_SC_2_SW_DEV}
@MmuxDefineSystemParameterConstant{_SC_2_UPE}
@MmuxDefineSystemParameterConstant{_SC_2_VERSION}
@MmuxDefineSystemParameterConstant{_SC_ADVISORY_INFO}
@MmuxDefineSystemParameterConstant{_SC_AIO_LISTIO_MAX}
@MmuxDefineSystemParameterConstant{_SC_AIO_MAX}
@MmuxDefineSystemParameterConstant{_SC_AIO_PRIO_DELTA_MAX}
@MmuxDefineSystemParameterConstant{_SC_ARG_MAX}
@MmuxDefineSystemParameterConstant{_SC_ASYNCHRONOUS_IO}
@MmuxDefineSystemParameterConstant{_SC_ATEXIT_MAX}
@MmuxDefineSystemParameterConstant{_SC_AVPHYS_PAGES}
@MmuxDefineSystemParameterConstant{_SC_BARRIERS}
@MmuxDefineSystemParameterConstant{_SC_BASE}
@MmuxDefineSystemParameterConstant{_SC_BC_BASE_MAX}
@MmuxDefineSystemParameterConstant{_SC_BC_DIM_MAX}
@MmuxDefineSystemParameterConstant{_SC_BC_SCALE_MAX}
@MmuxDefineSystemParameterConstant{_SC_BC_STRING_MAX}
@MmuxDefineSystemParameterConstant{_SC_CHARCLASS_NAME_MAX}
@MmuxDefineSystemParameterConstant{_SC_CHAR_BIT}
@MmuxDefineSystemParameterConstant{_SC_CHAR_MAX}
@MmuxDefineSystemParameterConstant{_SC_CHAR_MIN}
@MmuxDefineSystemParameterConstant{_SC_CHILD_MAX}
@MmuxDefineSystemParameterConstant{_SC_CLK_TCK}
@MmuxDefineSystemParameterConstant{_SC_CLOCK_SELECTION}
@MmuxDefineSystemParameterConstant{_SC_COLL_WEIGHTS_MAX}
@MmuxDefineSystemParameterConstant{_SC_CPUTIME}
@MmuxDefineSystemParameterConstant{_SC_C_LANG_SUPPORT}
@MmuxDefineSystemParameterConstant{_SC_C_LANG_SUPPORT_R}
@MmuxDefineSystemParameterConstant{_SC_DELAYTIMER_MAX}
@MmuxDefineSystemParameterConstant{_SC_DEVICE_IO}
@MmuxDefineSystemParameterConstant{_SC_DEVICE_SPECIFIC}
@MmuxDefineSystemParameterConstant{_SC_DEVICE_SPECIFIC_R}
@MmuxDefineSystemParameterConstant{_SC_EQUIV_CLASS_MAX}
@MmuxDefineSystemParameterConstant{_SC_EXPR_NEST_MAX}
@MmuxDefineSystemParameterConstant{_SC_FD_MGMT}
@MmuxDefineSystemParameterConstant{_SC_FIFO}
@MmuxDefineSystemParameterConstant{_SC_FILE_ATTRIBUTES}
@MmuxDefineSystemParameterConstant{_SC_FILE_LOCKING}
@MmuxDefineSystemParameterConstant{_SC_FILE_SYSTEM}
@MmuxDefineSystemParameterConstant{_SC_FSYNC}
@MmuxDefineSystemParameterConstant{_SC_GETGR_R_SIZE_MAX}
@MmuxDefineSystemParameterConstant{_SC_GETPW_R_SIZE_MAX}
@MmuxDefineSystemParameterConstant{_SC_HOST_NAME_MAX}
@MmuxDefineSystemParameterConstant{_SC_INT_MAX}
@MmuxDefineSystemParameterConstant{_SC_INT_MIN}
@MmuxDefineSystemParameterConstant{_SC_IOV_MAX}
@MmuxDefineSystemParameterConstant{_SC_IPV6}
@MmuxDefineSystemParameterConstant{_SC_JOB_CONTROL}
@MmuxDefineSystemParameterConstant{_SC_LEVEL1_DCACHE_ASSOC}
@MmuxDefineSystemParameterConstant{_SC_LEVEL1_DCACHE_LINESIZE}
@MmuxDefineSystemParameterConstant{_SC_LEVEL1_DCACHE_SIZE}
@MmuxDefineSystemParameterConstant{_SC_LEVEL1_ICACHE_ASSOC}
@MmuxDefineSystemParameterConstant{_SC_LEVEL1_ICACHE_LINESIZE}
@MmuxDefineSystemParameterConstant{_SC_LEVEL1_ICACHE_SIZE}
@MmuxDefineSystemParameterConstant{_SC_LEVEL2_CACHE_ASSOC}
@MmuxDefineSystemParameterConstant{_SC_LEVEL2_CACHE_LINESIZE}
@MmuxDefineSystemParameterConstant{_SC_LEVEL2_CACHE_SIZE}
@MmuxDefineSystemParameterConstant{_SC_LEVEL3_CACHE_ASSOC}
@MmuxDefineSystemParameterConstant{_SC_LEVEL3_CACHE_LINESIZE}
@MmuxDefineSystemParameterConstant{_SC_LEVEL3_CACHE_SIZE}
@MmuxDefineSystemParameterConstant{_SC_LEVEL4_CACHE_ASSOC}
@MmuxDefineSystemParameterConstant{_SC_LEVEL4_CACHE_LINESIZE}
@MmuxDefineSystemParameterConstant{_SC_LEVEL4_CACHE_SIZE}
@MmuxDefineSystemParameterConstant{_SC_LINE_MAX}
@MmuxDefineSystemParameterConstant{_SC_LOGIN_NAME_MAX}
@MmuxDefineSystemParameterConstant{_SC_LONG_BIT}
@MmuxDefineSystemParameterConstant{_SC_MAPPED_FILES}
@MmuxDefineSystemParameterConstant{_SC_MB_LEN_MAX}
@MmuxDefineSystemParameterConstant{_SC_MEMLOCK}
@MmuxDefineSystemParameterConstant{_SC_MEMLOCK_RANGE}
@MmuxDefineSystemParameterConstant{_SC_MEMORY_PROTECTION}
@MmuxDefineSystemParameterConstant{_SC_MESSAGE_PASSING}
@MmuxDefineSystemParameterConstant{_SC_MONOTONIC_CLOCK}
@MmuxDefineSystemParameterConstant{_SC_MQ_OPEN_MAX}
@MmuxDefineSystemParameterConstant{_SC_MQ_PRIO_MAX}
@MmuxDefineSystemParameterConstant{_SC_MULTI_PROCESS}
@MmuxDefineSystemParameterConstant{_SC_NETWORKING}
@MmuxDefineSystemParameterConstant{_SC_NGROUPS_MAX}
@MmuxDefineSystemParameterConstant{_SC_NL_ARGMAX}
@MmuxDefineSystemParameterConstant{_SC_NL_LANGMAX}
@MmuxDefineSystemParameterConstant{_SC_NL_MSGMAX}
@MmuxDefineSystemParameterConstant{_SC_NL_NMAX}
@MmuxDefineSystemParameterConstant{_SC_NL_SETMAX}
@MmuxDefineSystemParameterConstant{_SC_NL_TEXTMAX}
@MmuxDefineSystemParameterConstant{_SC_NPROCESSORS_CONF}
@MmuxDefineSystemParameterConstant{_SC_NPROCESSORS_ONLN}
@MmuxDefineSystemParameterConstant{_SC_NZERO}
@MmuxDefineSystemParameterConstant{_SC_OPEN_MAX}
@MmuxDefineSystemParameterConstant{_SC_PAGESIZE}
@MmuxDefineSystemParameterConstant{_SC_PAGE_SIZE}
@MmuxDefineSystemParameterConstant{_SC_PASS_MAX}
@MmuxDefineSystemParameterConstant{_SC_PHYS_PAGES}
@MmuxDefineSystemParameterConstant{_SC_PII}
@MmuxDefineSystemParameterConstant{_SC_PII_INTERNET}
@MmuxDefineSystemParameterConstant{_SC_PII_INTERNET_DGRAM}
@MmuxDefineSystemParameterConstant{_SC_PII_INTERNET_STREAM}
@MmuxDefineSystemParameterConstant{_SC_PII_OSI}
@MmuxDefineSystemParameterConstant{_SC_PII_OSI_CLTS}
@MmuxDefineSystemParameterConstant{_SC_PII_OSI_COTS}
@MmuxDefineSystemParameterConstant{_SC_PII_OSI_M}
@MmuxDefineSystemParameterConstant{_SC_PII_SOCKET}
@MmuxDefineSystemParameterConstant{_SC_PII_XTI}
@MmuxDefineSystemParameterConstant{_SC_PIPE}
@MmuxDefineSystemParameterConstant{_SC_POLL}
@MmuxDefineSystemParameterConstant{_SC_PRIORITIZED_IO}
@MmuxDefineSystemParameterConstant{_SC_PRIORITY_SCHEDULING}
@MmuxDefineSystemParameterConstant{_SC_RAW_SOCKETS}
@MmuxDefineSystemParameterConstant{_SC_READER_WRITER_LOCKS}
@MmuxDefineSystemParameterConstant{_SC_REALTIME_SIGNALS}
@MmuxDefineSystemParameterConstant{_SC_REGEXP}
@MmuxDefineSystemParameterConstant{_SC_REGEX_VERSION}
@MmuxDefineSystemParameterConstant{_SC_RE_DUP_MAX}
@MmuxDefineSystemParameterConstant{_SC_RTSIG_MAX}
@MmuxDefineSystemParameterConstant{_SC_SAVED_IDS}
@MmuxDefineSystemParameterConstant{_SC_SCHAR_MAX}
@MmuxDefineSystemParameterConstant{_SC_SCHAR_MIN}
@MmuxDefineSystemParameterConstant{_SC_SELECT}
@MmuxDefineSystemParameterConstant{_SC_SEMAPHORES}
@MmuxDefineSystemParameterConstant{_SC_SEM_NSEMS_MAX}
@MmuxDefineSystemParameterConstant{_SC_SEM_VALUE_MAX}
@MmuxDefineSystemParameterConstant{_SC_SHARED_MEMORY_OBJECTS}
@MmuxDefineSystemParameterConstant{_SC_SHELL}
@MmuxDefineSystemParameterConstant{_SC_SHRT_MAX}
@MmuxDefineSystemParameterConstant{_SC_SHRT_MIN}
@MmuxDefineSystemParameterConstant{_SC_SIGNALS}
@MmuxDefineSystemParameterConstant{_SC_SIGQUEUE_MAX}
@MmuxDefineSystemParameterConstant{_SC_SINGLE_PROCESS}
@MmuxDefineSystemParameterConstant{_SC_SPAWN}
@MmuxDefineSystemParameterConstant{_SC_SPIN_LOCKS}
@MmuxDefineSystemParameterConstant{_SC_SPORADIC_SERVER}
@MmuxDefineSystemParameterConstant{_SC_SSIZE_MAX}
@MmuxDefineSystemParameterConstant{_SC_STREAMS}
@MmuxDefineSystemParameterConstant{_SC_STREAM_MAX}
@MmuxDefineSystemParameterConstant{_SC_SYMLOOP_MAX}
@MmuxDefineSystemParameterConstant{_SC_SYNCHRONIZED_IO}
@MmuxDefineSystemParameterConstant{_SC_SYSTEM_DATABASE}
@MmuxDefineSystemParameterConstant{_SC_SYSTEM_DATABASE_R}
@MmuxDefineSystemParameterConstant{_SC_THREADS}
@MmuxDefineSystemParameterConstant{_SC_THREAD_ATTR_STACKADDR}
@MmuxDefineSystemParameterConstant{_SC_THREAD_ATTR_STACKSIZE}
@MmuxDefineSystemParameterConstant{_SC_THREAD_CPUTIME}
@MmuxDefineSystemParameterConstant{_SC_THREAD_DESTRUCTOR_ITERATIONS}
@MmuxDefineSystemParameterConstant{_SC_THREAD_KEYS_MAX}
@MmuxDefineSystemParameterConstant{_SC_THREAD_PRIORITY_SCHEDULING}
@MmuxDefineSystemParameterConstant{_SC_THREAD_PRIO_INHERIT}
@MmuxDefineSystemParameterConstant{_SC_THREAD_PRIO_PROTECT}
@MmuxDefineSystemParameterConstant{_SC_THREAD_PROCESS_SHARED}
@MmuxDefineSystemParameterConstant{_SC_THREAD_SAFE_FUNCTIONS}
@MmuxDefineSystemParameterConstant{_SC_THREAD_SPORADIC_SERVER}
@MmuxDefineSystemParameterConstant{_SC_THREAD_STACK_MIN}
@MmuxDefineSystemParameterConstant{_SC_THREAD_THREADS_MAX}
@MmuxDefineSystemParameterConstant{_SC_TIMEOUTS}
@MmuxDefineSystemParameterConstant{_SC_TIMERS}
@MmuxDefineSystemParameterConstant{_SC_TIMER_MAX}
@MmuxDefineSystemParameterConstant{_SC_TRACE}
@MmuxDefineSystemParameterConstant{_SC_TRACE_EVENT_FILTER}
@MmuxDefineSystemParameterConstant{_SC_TRACE_INHERIT}
@MmuxDefineSystemParameterConstant{_SC_TRACE_LOG}
@MmuxDefineSystemParameterConstant{_SC_TTY_NAME_MAX}
@MmuxDefineSystemParameterConstant{_SC_TYPED_MEMORY_OBJECTS}
@MmuxDefineSystemParameterConstant{_SC_TZNAME_MAX}
@MmuxDefineSystemParameterConstant{_SC_T_IOV_MAX}
@MmuxDefineSystemParameterConstant{_SC_UCHAR_MAX}
@MmuxDefineSystemParameterConstant{_SC_UINT_MAX}
@MmuxDefineSystemParameterConstant{_SC_UIO_MAXIOV}
@MmuxDefineSystemParameterConstant{_SC_ULONG_MAX}
@MmuxDefineSystemParameterConstant{_SC_USER_GROUPS}
@MmuxDefineSystemParameterConstant{_SC_USER_GROUPS_R}
@MmuxDefineSystemParameterConstant{_SC_USHRT_MAX}
@MmuxDefineSystemParameterConstant{_SC_V6_ILP32_OFF32}
@MmuxDefineSystemParameterConstant{_SC_V6_ILP32_OFFBIG}
@MmuxDefineSystemParameterConstant{_SC_V6_LP64_OFF64}
@MmuxDefineSystemParameterConstant{_SC_V6_LPBIG_OFFBIG}
@MmuxDefineSystemParameterConstant{_SC_VERSION}
@MmuxDefineSystemParameterConstant{_SC_WORD_BIT}
@MmuxDefineSystemParameterConstant{_SC_XBS5_ILP32_OFF32}
@MmuxDefineSystemParameterConstant{_SC_XBS5_ILP32_OFFBIG}
@MmuxDefineSystemParameterConstant{_SC_XBS5_LP64_OFF64}
@MmuxDefineSystemParameterConstant{_SC_XBS5_LPBIG_OFFBIG}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_CRYPT}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_ENH_I18N}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_LEGACY}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_REALTIME}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_REALTIME_THREADS}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_SHM}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_UNIX}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_VERSION}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_XCU_VERSION}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_XPG2}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_XPG3}
@MmuxDefineSystemParameterConstant{_SC_XOPEN_XPG4}

@c page
@node system configuration strings
@section System configuration strings


@cindex @samp{MMUX_LIBC__CS_} constants
@cindex Constants @samp{MMUX_LIBC__CS_}


@deftp {Struct Typedef} mmux_libc_sysconf_string_parameter_t
Data structure type representing the selector of a configurable parameter whose value is represented
by an @MmuxAsciiZ{} string.  The constants @code{MMUX_LIBC__CS_*} are expressions which evaluate to
instances of this type.
@end deftp


@deftypefun bool mmux_libc_confstr_size (mmux_usize_t * @var{result_required_nbytes_p}, mmux_libc_sysconf_string_parameter_t @var{parameter})
@deftypefunx bool mmux_libc_confstr (mmux_asciizp_t @var{result_bufptr}, mmux_usize_t @var{provided_nbytes}, mmux_libc_sysconf_string_parameter_t @var{parameter})
@MmuxCInterface{confstr}.  @var{parameter} must be one of the @samp{MMUX_LIBC__CS_*} constants.

@example
auto          parameter = MMUX_LIBC__CS_PATH;
mmux_usize_t  required_nbytes;

if (mmux_libc_confstr_size(&required_nbytes, parameter)) @{
  /* error */
@} else @{
  char  value[required_nbytes.value];

  if (mmux_libc_confstr(value, required_nbytes, parameter)) @{
    /* error */
  @} else @{
    /* the result is in "value" */
  @}
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineSystemStringParameterConstant{NAME}
@defvr {Constant} @value{PackageApiPrefixUpper}\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{@value{PackageApiPrefixUpper}\NAME\} evaluates to an instance of
@objtype{mmux_libc_sysconf_string_parameter_t}; it can be defined or not depending on the features
of the underlying platform.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbol
@samp{@value{PackageApiPrefixUpper}\NAME\} is available.
@end defvr

@end macro

@MmuxDefineSystemStringParameterConstant{_CS_LFS64_CFLAGS}
@MmuxDefineSystemStringParameterConstant{_CS_LFS64_LDFLAGS}
@MmuxDefineSystemStringParameterConstant{_CS_LFS64_LIBS}
@MmuxDefineSystemStringParameterConstant{_CS_LFS64_LINTFLAGS}
@MmuxDefineSystemStringParameterConstant{_CS_LFS_CFLAGS}
@MmuxDefineSystemStringParameterConstant{_CS_LFS_LDFLAGS}
@MmuxDefineSystemStringParameterConstant{_CS_LFS_LIBS}
@MmuxDefineSystemStringParameterConstant{_CS_LFS_LINTFLAGS}
@MmuxDefineSystemStringParameterConstant{_CS_PATH}

@c page
@node system configuration fs
@section System configuration for file system parameters


@cindex @samp{MMUX_LIBC__PC_} constants
@cindex Constants @samp{MMUX_LIBC__PC_}


@deftp {Struct Typedef} mmux_libc_sysconf_pathname_parameter_t
Data structure type representing the selector of a configurable file system parameter whose value
fits into a @objtype{mmux_slong_t}.  The constants @code{MMUX_LIBC__PC_*} are expressions which
evaluate to instances of this type.
@end deftp


@deftypefun bool mmux_libc_pathconf (mmux_slong_t * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{fs_ptn}, mmux_libc_sysconf_pathname_parameter_t @var{parameter})
@MmuxCInterface{pathconf}.  When successful: if the variable referenced by @var{result_p} is set to
@samp{-1}, the system does not impose a limit on the specified parameter.

@example
mmux_libc_fs_ptn_t  fs_ptn;
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, "/path/to/file.ext")) @{
    /* error */
  @}
@}
@{
  mmux_slong_t  result;

  if (mmux_libc_pathconf(&result, fs_ptn, MMUX_LIBC__PC_LINK_MAX)) @{
  /* error */
  @} else if (mmux_libc_dprintfer("%s: pc_link_max is: '%lu'\n", __func__, result.value)) @{
    /* error */
  @}
@}
mmux_libc_unmake_file_system_pathname(fs_ptn);
@end example
@end deftypefun


@deftypefun bool mmux_libc_fpathconf (mmux_slong_t * @var{result_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_sysconf_pathname_parameter_t @var{parameter})
@MmuxCInterface{fpathconf}.  When successful: if the variable referenced by @var{result_p} is set to
@samp{-1}, the system does not impose a limit on the specified parameter.

@example
mmux_libc_fd_t  fd;
@{
  mmux_libc_fs_ptn_t  fs_ptn;
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, "/path/to/file.ext")) @{
      /* error */
    @}
  @}
  /* Open the file. */
  @{
    auto    flags = mmux_libc_open_flags(MMUX_LIBC_O_RDWR);
    auto    mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}

@{
  mmux_slong_t  result;

  if (mmux_libc_fpathconf(&result, fd, MMUX_LIBC__PC_LINK_MAX)) @{
    /* error */
  @} else if (mmux_libc_dprintfer("%s: pc_link_max is: '%lu'\n", __func__, result.value)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineFileSystemParameterConstant{NAME}
@defvr {Constant} @value{PackageApiPrefixUpper}\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{@value{PackageApiPrefixUpper}\NAME\} evaluates to an instance of
@objtype{mmux_libc_sysconf_string_parameter_t}; it can be defined or not depending on the features
of the underlying platform.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbol
@samp{@value{PackageApiPrefixUpper}\NAME\} is available.
@end defvr

@end macro

@MmuxDefineFileSystemParameterConstant{_PC_ASYNC_IO}
@MmuxDefineFileSystemParameterConstant{_PC_CHOWN_RESTRICTED}
@MmuxDefineFileSystemParameterConstant{_PC_FILESIZEBITS}
@MmuxDefineFileSystemParameterConstant{_PC_LINK_MAX}
@MmuxDefineFileSystemParameterConstant{_PC_MAX_CANON}
@MmuxDefineFileSystemParameterConstant{_PC_MAX_INPUT}
@MmuxDefineFileSystemParameterConstant{_PC_NAME_MAX}
@MmuxDefineFileSystemParameterConstant{_PC_NO_TRUNC}
@MmuxDefineFileSystemParameterConstant{_PC_PATH_MAX}
@MmuxDefineFileSystemParameterConstant{_PC_PIPE_BUF}
@MmuxDefineFileSystemParameterConstant{_PC_PRIO_IO}
@MmuxDefineFileSystemParameterConstant{_PC_REC_INCR_XFER_SIZE}
@MmuxDefineFileSystemParameterConstant{_PC_REC_MAX_XFER_SIZE}
@MmuxDefineFileSystemParameterConstant{_PC_REC_MIN_XFER_SIZE}
@MmuxDefineFileSystemParameterConstant{_PC_REC_XFER_ALIGN}
@MmuxDefineFileSystemParameterConstant{_PC_SYNC_IO}
@MmuxDefineFileSystemParameterConstant{_PC_VDISABLE}

@c page
@node system configuration limits
@section System configuration limits


@cindex @samp{MMUX_LIBC_RLIMIT_} constants
@cindex Constants @samp{MMUX_LIBC_RLIMIT_}


To initialise and inspect an object of type @objtype{mmux_libc_rlimit_t} we do:

@example
auto                cur = mmux_libc_rlim_literal(12);
auto                max = mmux_libc_rlim_literal(34);
mmux_libc_rlimit_t  RL[1];

mmux_libc_rlim_cur_set(RL, cur);
mmux_libc_rlim_max_set(RL, max);
@{
  mmux_libc_fd_t    er;

  mmux_libc_stder(er);
  if (mmux_libc_rlimit_dump(er, RL, NULL)) @{
    /* error */
  @}
@}

@{
  mmux_libc_rlim_t  cur1, max1;

  mmux_libc_rlim_cur_ref(&cur1, RL);
  mmux_libc_rlim_max_ref(&max1, RL);
  ...
@}
@end example


@MmuxCStructOpaqueTypedef{rlimit}
@MmuxSetterGetter{rlimit, rlim_cur, mmux_libc_rlim_t}
@MmuxSetterGetter{rlimit, rlim_max, mmux_libc_rlim_t}
@MmuxStructDumper{rlimit}


@deftypefun bool mmux_libc_rlimit_set (mmux_libc_rlimit_t * @var{rlimit_p}, mmux_libc_rlim_t @var{cur}, mmux_libc_rlim_t @var{max})
Setter for the fields of @objtype{mmux_libc_rlimit_t}.

@example
auto                cur = mmux_libc_rlim_literal(12);
auto                max = mmux_libc_rlim_literal(34);
mmux_libc_rlimit_t  RL[1];

mmux_libc_rlimit_set(RL, cur, max);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftp {Struct Typedef} mmux_libc_sysconf_resource_limit_t
Data structure type representing the selector of a system/process parameter whose value fits into an
object of type @objtype{mmux_libc_rlimit_t}.  The constants @code{MMUX_LIBC_RLIMIT_*} are
expressions which evaluate to instances of this type.
@end deftp


@deftypefun bool mmux_libc_getrlimit (mmux_libc_rlimit_t * @var{result_rlimit_p}, mmux_libc_sysconf_resource_limit_t @var{resource})
@MmuxCInterface{getrlimit}.

@example
mmux_libc_rlimit_t  RL[1];

if (mmux_libc_getrlimit(RL, MMUX_LIBC_RLIMIT_FSIZE))  @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_setrlimit (mmux_libc_sysconf_resource_limit_t @var{resource}, mmux_libc_rlimit_t * @var{new_rlimit_p})
@MmuxCInterface{setrlimit}.

@example
auto                cur = mmux_libc_rlim_literal(12);
auto                max = mmux_libc_rlim_literal(34);
mmux_libc_rlimit_t  RL[1];

mmux_libc_rlimit_set(RL, cur, max);
if (mmux_libc_setrlimit(MMUX_LIBC_RLIMIT_FSIZE, RL))  @{
  /* error */
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_prlimit (mmux_libc_rlimit_t * @var{old_rlimit_p}, mmux_libc_pid_t @var{pid}, mmux_libc_sysconf_resource_limit_t @var{resource}, mmux_libc_rlimit_t * @var{new_rlimit_p})
@MmuxCInterface{prlimit}.

The argument @var{old_rlimit_p} is the first because it is a result of the function call.

The argument @var{new_rlimit_p} is the last because it is an argument of the function call.

@example
/* setting and getting */
@{
  auto                cur = mmux_libc_rlim_literal(1000000);
  auto                max = mmux_libc_rlim_literal(1100000);
  mmux_libc_rlimit_t  old_RL[1], new_RL[1];
  mmux_libc_pid_t     pid;

  mmux_libc_getpid(&pid);
  mmux_libc_rlimit_set(new_RL, cur, max);
  if (mmux_libc_prlimit(old_RL, pid, MMUX_LIBC_RLIMIT_STACK, new_RL))  @{
    /* error */
  @}
@}

/* only setting and only getting */
@{
  auto                cur = mmux_libc_rlim_literal(1000000);
  auto                max = mmux_libc_rlim_literal(1100000);
  mmux_libc_rlimit_t  new_RL[1], old_RL[1];
  mmux_libc_pid_t     pid;

  mmux_libc_getpid(&pid);
  mmux_libc_rlimit_set(new_RL, cur, max);
  if (mmux_libc_prlimit(NULL, pid, MMUX_LIBC_RLIMIT_STACK, new_RL))  @{
    /* error */
  @}
  if (mmux_libc_prlimit(old_RL, pid, MMUX_LIBC_RLIMIT_STACK, NULL))  @{
    /* error */
  @}
@}
@end example
@end deftypefn

@c ------------------------------------------------------------------------

@macro MmuxDefineResourceLimitParameterConstant{NAME}
@defvr {Constant} @value{PackageApiPrefixUpper}\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{@value{PackageApiPrefixUpper}\NAME\} evaluates to an instance of
@objtype{mmux_libc_sysconf_resource_limit_t}; it can be defined or not depending on the features of
the underlying platform.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbol
@samp{@value{PackageApiPrefixUpper}\NAME\} is available.
@end defvr

@end macro

@MmuxDefineResourceLimitParameterConstant{RLIMIT_AS}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_CORE}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_CPU}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_DATA}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_FSIZE}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_LOCKS}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_MEMLOCK}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_MSGQUEUE}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_NICE}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_NOFILE}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_NPROC}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_RSS}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_RTPRIO}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_RTTIME}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_SIGPENDING}
@MmuxDefineResourceLimitParameterConstant{RLIMIT_STACK}


@defvr {Preprocessor Symbol} MMUX_LIBC_RLIM_INFINITY
Evaluates to an instance of @objtype{mmux_libc_rlim_t} representing the value of the C constant
@samp{MMUX_LIBC_RLIM_INFINITY}.
@end defvr

@c page
@node persona
@chapter Persona operations


@menu
* persona uids::                Representing UIDs.
* persona gids::                Representing GIDs.
* persona getting::             Getting users and groups.
* persona setting::             Setting users and groups.
* persona login::               Identifying who logged in.
* persona database user::       User database.
* persona database group::      Group database.
@end menu

@c page
@node persona uids
@section Representing UIDs


@cindex @objtype{mmux_libc_uid_t}, type definition
@cindex Structure type @objtype{mmux_libc_uid_t}
@cindex Type @objtype{mmux_libc_uid_t}


Under @value{PACKAGE}: user identifier values are represented by objects of type
@objtype{mmux_libc_uid_t} which are defined by the external package @mmux{} CC Types; many core
operations are defined for this type.  To obtain a UID value and print its string representation to
@stderr{}, we can do:

@example
mmux_libc_uid_t  the_uid;
mmux_libc_fd_t   fd;

mmux_libc_getuid(&the_uid);

mmux_libc_stder(fd);
if (mmux_libc_dprintf_libc_uid(fd, uid)) @{
  /* error */
@}
@end example

@noindent
to just define a variable from a literal value, we do:

@example
auto    the_uid = mmux_libc_uid_literal(1000);
@end example


@deftypefun bool mmux_libc_make_uid (mmux_libc_uid_t * @var{result_p}, mmux_standard_libc_uid_t @var{uid_num})
Constructor for @objtype{mmux_libc_uid_t} values; it is equivalent to using @cfunc{mmux_libc_uid},
but it follows the calling convention of @value{PACKAGE}.

@example
mmux_libc_uid_t  the_uid;

mmux_libc_make_uid(&the_uid, 1000);
@end example
@end deftypefun

@c page
@node persona gids
@section Representing GIDs


@cindex @objtype{mmux_libc_gid_t}, type definition
@cindex Structure type @objtype{mmux_libc_gid_t}
@cindex Type @objtype{mmux_libc_gid_t}


Under @value{PACKAGE}: group identifier values are represented by objects of type
@objtype{mmux_libc_gid_t} which are defined by the external package @mmux{} CC Types; many core
operations are defined for this type.  To obtain a GID value and print its string representation to
@stderr{}, we can do:

@example
mmux_libc_gid_t  the_gid;
mmux_libc_fd_t   fd;

mmux_libc_getgid(&the_gid);

mmux_libc_stder(fd);
if (mmux_libc_dprintf_libc_gid(fd, gid)) @{
  /* error */
@}
@end example

@noindent
to just define a variable from a literal value, we do:

@example
auto    the_gid = mmux_libc_gid_literal(1000);
@end example


@deftypefun bool mmux_libc_make_gid (mmux_libc_gid_t * @var{result_p}, mmux_standard_libc_gid_t @var{gid_num})
Constructor for @objtype{mmux_libc_gid_t} values; it is equivalent to using @cfunc{mmux_libc_gid},
but it follows the calling convention of @value{PACKAGE}.

@example
mmux_libc_gid_t  the_gid;

mmux_libc_make_gid(&the_gid, 1000);
@end example
@end deftypefun

@c page
@node persona getting
@section Getting users and groups


@deftypefun bool mmux_libc_getuid (mmux_libc_uid_t * @var{result_p})
@MmuxCInterface{getuid}.

@example
mmux_libc_uid_t  uid;

mmux_libc_getuid(&uid);
@end example
@end deftypefun


@deftypefun bool mmux_libc_getgid (mmux_libc_gid_t * @var{result_p})
@MmuxCInterface{getgid}.

@example
mmux_libc_gid_t  gid;

mmux_libc_getgid(&gid);
@end example
@end deftypefun


@deftypefun bool mmux_libc_geteuid (mmux_libc_uid_t * @var{result_p})
@MmuxCInterface{geteuid}.

@example
mmux_libc_uid_t  euid;

mmux_libc_geteuid(&euid);
@end example
@end deftypefun


@deftypefun bool mmux_libc_getegid (mmux_libc_gid_t * @var{result_p})
@MmuxCInterface{getegid}.

@example
mmux_libc_gid_t  egid;

mmux_libc_getegid(&egid);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_getgroups_size (mmux_usize_t * @var{result_ngroups_p})
Determine the number of supplementary groups of the current process and store it in the location
referenced by @var{ngroups_p}.  This function is meant to be used with @cfunc{mmux_libc_getgroups}.
@end deftypefun


@deftypefun bool mmux_libc_getgroups (mmux_usize_t * @var{ngroups_p}, mmux_libc_gid_t * @var{groups_p})
@MmuxCInterface{getgroups}.  Fill the array referenced by @var{groups_p} with values representing
the supplementary groups of the current process.

@itemize
@item
Upon entering the function call: the array must have a number of elements equal to the value
referenced by @var{ngroups_p}.

@item
Upon returning from the function call: the location referenced by @var{ngroups_p} is updated with
the actual number of values stored in the array.
@end itemize

To retrieve the supplementary groups of the current process we do:

@example
mmux_usize_t  ngroups;

if (mmux_libc_getgroups_size(&ngroups)) @{
  /* error */
@} else @{
  mmux_libc_gid_t  gids[ngroups.value];

  if (mmux_libc_getgroups(&ngroups, gids)) @{
    /* error */
  @} else @{
    /* do something with gids */
  @}
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_getgrouplist_size (mmux_usize_t * @var{result_ngroups_p}, mmux_asciizcp_t @var{username}, mmux_libc_gid_t @var{gid})
Determine the number of groups a user belongs to and store it in the location referenced by
@var{ngroups_p}.  This function is meant to be used with @cfunc{mmux_libc_getgrouplist}.
@end deftypefun


@deftypefun bool mmux_libc_getgrouplist (mmux_libc_gid_t * @var{result_groups_p}, mmux_usize_t * @var{ngroups_p}, mmux_asciizcp_t @var{username}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{getgrouplist}.  Fill the array referenced by @var{result_groups_p} with values
representing the groups a user belongs to.

@itemize
@item
Upon entering the function call: the array must have a number of elements equal to the value
referenced by @var{ngroups_p}.

@item
Upon returning from the function call: the location referenced by @var{ngroups_p} is updated with
the actual number of values stored in the array.
@end itemize

To retrieve the groups a user belongs to we do:

@example
mmux_libc_uid_t       uid;
mmux_libc_passwd_t *  PW;

mmux_libc_getuid(&uid);
if (mmux_libc_getpwuid(&PW, uid)) @{
  /* error */
@} else @{
  mmux_asciizcp_t  name;
  mmux_libc_gid_t  gid;
  mmux_usize_t     ngroups;

  mmux_libc_pw_name_ref (&name, PW);
  mmux_libc_pw_gid_ref  (&gid,  PW);

  if (mmux_libc_getgrouplist_size(&ngroups, name, gid)) @{
    /* error */
  @} else @{
    mmux_libc_gid_t  gids[ngroups.value];

    if (mmux_libc_getgrouplist(gids, &ngroups, name, gid)) @{
      /* error */
    @} else @{
     /* do something with "gids" */
    @}
  @}
@}
@end example
@end deftypefun

@c page
@node persona setting
@section Setting users and groups


@deftypefun bool mmux_libc_setuid (mmux_libc_uid_t @var{uid})
@MmuxCInterface{setuid}.

@example
mmux_libc_uid_t     uid;

if (mmux_libc_getuid(&uid)) @{
  /* error */
@}
if (mmux_libc_setuid(uid)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_seteuid (mmux_libc_uid_t @var{uid})
@MmuxCInterface{seteuid}.

@example
mmux_libc_uid_t     euid;

if (mmux_libc_geteuid(&euid)) @{
  /* error */
@}
if (mmux_libc_seteuid(euid)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_setreuid (mmux_libc_uid_t @var{uid}, mmux_libc_uid_t @var{euid})
@MmuxCInterface{setreuid}.

@example
mmux_libc_uid_t     uid;

if (mmux_libc_geteuid(&uid)) @{
  /* error */
@}
if (mmux_libc_setreuid(uid, uid)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_setgid (mmux_libc_gid_t @var{gid})
@MmuxCInterface{setgid}.

@example
mmux_libc_gid_t     gid;

if (mmux_libc_getgid(&gid)) @{
  /* error */
@}
if (mmux_libc_setgid(gid)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_setegid (mmux_libc_gid_t @var{gid})
@MmuxCInterface{setegid}.

@example
mmux_libc_gid_t     gid;

if (mmux_libc_getegid(&gid)) @{
  /* error */
@}
if (mmux_libc_setegid(gid)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_setregid (mmux_libc_gid_t @var{gid}, mmux_libc_gid_t @var{egid})
@MmuxCInterface{setregid}.

@example
mmux_libc_gid_t     gid;

if (mmux_libc_getegid(&gid)) @{
  /* error */
@}
if (mmux_libc_setregid(gid, gid)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node persona login
@section Identifying who logged in


@deftypefun bool mmux_libc_getlogin (mmux_asciizcpp_t @var{result_username_p})
@MmuxCInterface{getlogin}.

@example
mmux_asciizcp_t     name;

if (mmux_libc_getlogin(&name)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getlogin_r (mmux_asciizp_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{getlogin_r}.

@example
auto  buflen = mmux_usize_literal(64);
char  bufptr[buflen.value];

if (mmux_libc_getlogin_r(bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node persona database user
@section User database


To print the whole @file{/etc/passwd} database using the non--reentrant function
@cfunc{mmux_libc_getpwent} we do:

@example
mmux_libc_setpwent();
@{
  mmux_libc_passwd_t *  PW;
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(fd);
  for (;;) @{
    mmux_libc_getpwent(&PW);
    if (NULL == PW) @{
      break;
    @} else if (mmux_libc_passwd_dump(fd, PW, NULL)) @{
      /* error */
    @}
  @}
@}
mmux_libc_endpwent();
@end example


@MmuxCStructOpaqueTypedef{passwd}
@MmuxSetterGetter{passwd,	pw_name,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_passwd,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_uid,		mmux_libc_uid_t}
@MmuxSetterGetter{passwd,	pw_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{passwd,	pw_gecos,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_dir,		mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_shell,	mmux_asciizcp_t}
@MmuxStructDumper{passwd}


@deftypefun bool mmux_libc_setpwent (void)
@MmuxCInterface{setpwent}.
@end deftypefun


@deftypefun bool mmux_libc_endpwent (void)
@MmuxCInterface{endpwent}.
@end deftypefun


@deftypefun bool mmux_libc_getpwent (mmux_libc_passwd_t * * @var{result_passwd_pp})
@MmuxCInterface{getpwent}.
@end deftypefun


@deftypefun bool mmux_libc_getpwuid (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_libc_uid_t @var{uid})
@MmuxCInterface{getpwuid}.

@example
mmux_libc_uid_t       uid;
mmux_libc_passwd_t *  PW;
mmux_libc_fd_t        fd;

mmux_libc_stdou(fd);
if (mmux_libc_getuid(&uid)) @{
  /* error */
@} else if (mmux_libc_getpwuid(&PW, uid)) @{
  /* error */
@} else if (PW && mmux_libc_passwd_dump(fd, PW, NULL)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getpwnam (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_asciizcp_t @var{username})
@MmuxCInterface{getpwnam}.

@example
mmux_asciizcp_t       name = "root";
mmux_libc_passwd_t *  PW;
mmux_libc_fd_t        fd;

mmux_libc_stdou(fd);
if (mmux_libc_getpwnam(&PW, name)) @{
  /* error */
@} else if (PW && mmux_libc_passwd_dump(fd, PW, NULL)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node persona database group
@section Group database


To print the whole @file{/etc/group} database using the non--reentrant function
@cfunc{mmux_libc_getgrent} we do:

@example
mmux_libc_setgrent();
@{
  mmux_libc_group_t *  GR;
  mmux_libc_fd_t       fd;

  mmux_libc_stdou(fd);
  for (;;) @{
    mmux_libc_getgrent(&GR);
    if (NULL == GR) @{
      break;
    @} else if (mmux_libc_group_dump(fd, GR, NULL)) @{
      /* error */
    @}
  @}
@}
mmux_libc_endgrent();
@end example


@MmuxCStructOpaqueTypedef{group}
@MmuxSetterGetter{group,	gr_name,	mmux_asciizcp_t}
@MmuxSetterGetter{group,	gr_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{group,	gr_mem,		mmux_asciizcp_t*}
@MmuxStructDumper{group}


@deftypefun bool mmux_libc_setgrent (void)
@MmuxCInterface{setgrent}.
@end deftypefun


@deftypefun bool mmux_libc_endgrent (void)
@MmuxCInterface{endgrent}.
@end deftypefun


@deftypefun bool mmux_libc_getgrent (mmux_libc_group_t * * @var{result_group_pp})
@MmuxCInterface{getgrent}.
@end deftypefun


@deftypefun bool mmux_libc_getgrgid (mmux_libc_group_t * * @var{result_group_pp}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{getgrgid}.

@example
mmux_libc_gid_t      gid;
mmux_libc_group_t *  GR;
mmux_libc_fd_t       fd;

mmux_libc_stdou(fd);
if (mmux_libc_getgid(&gid)) @{
  /* error */
@} else if (mmux_libc_getgrgid(&GR, gid)) @{
  /* error */
@} else if (GR && mmux_libc_group_dump(fd, GR, NULL)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getgrnam (mmux_libc_group_t * * @var{result_group_pp}, mmux_asciizcp_t @var{groupname})
@MmuxCInterface{getgrnam}.

@example
mmux_asciizcp_t      name = "root";
mmux_libc_group_t *  GR;
mmux_libc_fd_t       fd;

mmux_libc_stdou(fd);
if (mmux_libc_getgrnam(&GR, name)) @{
  /* error */
@} else if (GR && mmux_libc_group_dump(fd, GR, NULL)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_group_member (bool * @var{result_is_member_p}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{group_member}.

@example
mmux_libc_gid_t  gid;
bool             this_process_belongs_to_group;

if (mmux_libc_getgid(&gid)) @{
  /* error */
@} else if (mmux_libc_group_member(&this_process_belongs_to_group, gid)) @{
  /* error */
@} else if (this_process_belongs_to_group) @{
  /* it belongs */
@} else @{
  /* it does not belong */
@}
@end example
@end deftypefn

@c page
@node processes
@chapter Processes


@menu
* processes pids::              Representing PIDs.
* processes getting::           Getting PIDs.
* processes statuses::          Representing process completion--statuses.
* processes forking::           Forking processes.
* processes waiting::           Waiting for process completion.
* processes exiting::           Exiting processes.
@end menu

@c page
@node processes pids
@section Representing PIDs


@cindex @objtype{mmux_libc_pid_t}, type definition
@cindex Structure type @objtype{mmux_libc_pid_t}
@cindex Type @objtype{mmux_libc_pid_t}


Under @value{PACKAGE}: process identifier values are represented by objects of type
@objtype{mmux_libc_pid_t} which are defined by the external package @mmux{} CC Types; many core
operations are defined for this type.  To obtain a PID value and print its string representation to
@stderr{}, we can do:

@example
mmux_libc_pid_t  the_pid;
mmux_libc_fd_t   fd;

mmux_libc_getpid(&the_pid);

mmux_libc_stder(fd);
if (mmux_libc_dprintf_libc_pid(fd, pid)) @{
  /* error */
@}
@end example

@noindent
to just define a variable from a literal value, we do:

@example
auto    the_pid = mmux_libc_pid_literal(1000);
@end example


@deftypefun bool mmux_libc_make_pid (mmux_libc_pid_t * @var{result_p}, mmux_standard_libc_pid_t @var{pid_num})
Constructor for @objtype{mmux_libc_pid_t} values; it is equivalent to using @cfunc{mmux_libc_pid},
but it follows the calling convention of @value{PACKAGE}.

@example
mmux_libc_pid_t  the_pid;

mmux_libc_make_pid(&the_pid, 1000);
@end example
@end deftypefun


@deftypefun bool mmux_libc_make_pid_zero (mmux_libc_pid_t * @var{result_p})
Build a new value of type @objtype{mmux_libc_pid_t} whose process identifier equals zero.  This is
useful for neutral initialisation of some data structures like @objtype{mmux_libc_flock_t}.
@end deftypefun


@deftypefun bool mmux_libc_make_pid_minus_one (mmux_libc_pid_t * @var{result_p})
Build a new value of type @objtype{mmux_libc_pid_t} whose process identifier equals @samp{-1}.  This
is useful for special initialisation of some data structures like @objtype{mmux_libc_flock_t}, in
which a process identifier equal to @samp{-1} is used for file description locks, @glibcref{Open
File Description Locks, Open File Description Locks}.
@end deftypefun

@c page
@node processes getting
@section Getting PIDs


@deftypefun bool mmux_libc_getpid  (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gitpid}.

@example
mmux_libc_pid_t	pid;

mmux_libc_getpid(&pid);
@end example
@end deftypefun


@deftypefun  bool mmux_libc_getppid (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gitppid}.

@example
mmux_libc_pid_t	pid;

mmux_libc_getppid(&pid);
@end example
@end deftypefun


@deftypefun bool mmux_libc_gettid (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gittid}.

@example
mmux_libc_pid_t	pid;

mmux_libc_gettid(&pid);
@end example
@end deftypefun

@c page
@node processes statuses
@section Representing process completion--statuses


@menu
* processes statuses typedef::     Process completion--status type.
* processes statuses operations::  Process completion--status operations.
@end menu

@c page
@node processes statuses typedef
@subsection Process completion--status type


A process can obtain a process completion--status exact integer as result of waiting for another
process completion with the @cfunc{mmux_libc_waitpid} and @cfunc{mmux_libc_wait} functions.  Once
obtained, the completion--status can be inspected using the @cfunc{mmux_libc_W*} functions,
@ref{processes statuses operations} for details.


@deftp {Opaque Struct Typedef} mmux_libc_process_completion_status_t
Opaque data structure type representing a process completion--status.
@end deftp


@deftypefun bool mmux_libc_make_process_completion_status (mmux_libc_process_completion_status_t * @var{result_p}, mmux_standard_sint_t @var{status_num})
Build a new value of type @objtype{mmux_libc_process_completion_status_t}.

@example
mmux_libc_process_completion_status_t   pcs;

mmux_libc_make_process_completion_status(&psc, 123);
@end example
@end deftypefun


@deftypefun bool mmux_libc_process_completion_status_equal (bool * @var{result_p}, mmux_libc_process_completion_status_t @vari{status}, mmux_libc_process_completion_status_t @varii{status})
Store @ctrue{} in the variable referenced by @var{result_p} if @vari{status} and @varii{status} are
equal; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_process_completion_status_not_equal (bool * @var{result_p}, mmux_libc_process_completion_status_t @vari{status}, mmux_libc_process_completion_status_t @varii{status})
Store @cfalse{} in the variable referenced by @var{result_p} if @vari{status} and @varii{status} are
equal; otherwise store @ctrue{}.
@end deftypefun

@c page
@node processes statuses operations
@subsection Process completion--status operations


@deftypefun bool mmux_libc_WIFEXITED (bool * @var{result_p}, mmux_libc_process_completion_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFEXITED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WEXITSTATUS (mmux_sint_t * @var{result_p}, mmux_libc_process_completion_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WEXITSTATUS,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WIFSIGNALED (bool * @var{result_p}, mmux_libc_process_completion_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFSIGNALED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WTERMSIG (mmux_libc_interprocess_signal_t * @var{result_p}, mmux_libc_process_completion_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WTERMSIG,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WCOREDUMP (bool * @var{result_p}, mmux_libc_process_completion_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WCOREDUMP,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WIFSTOPPED (bool * @var{result_p}, mmux_libc_process_completion_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFSTOPPED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WSTOPSIG (mmux_libc_interprocess_signal_t * @var{result_p}, mmux_libc_process_completion_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WSTOPSIG,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WIFCONTINUED (bool * @var{result_p}, mmux_libc_process_completion_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFCONTINUED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun

@c page
@node processes forking
@section Forking processes


To fork the current process into two processes, parent and child, we do:

@example
bool             this_is_the_parent_process;
mmux_libc_pid_t  child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  mmux_libc_errno_t  errnum;

  mmux_libc_errno_consume(&errnum);
  ... /* handle the error */
@} else if (this_is_the_parent_process) @{
  ... /* do something in the parent process, maybe using "child_pid" */
@} else @{
  ... /* do something in the child process */
@}
@end example


@deftypefun bool mmux_libc_fork (bool * @var{this_is_the_parent_process_p}, mmux_libc_pid_t * @var{child_process_pid_p})
@MmuxCInterface{fork}.

Regarding the argument @var{this_is_the_parent_process_p}: the referenced variable is mutated only
when a call is successful, otherwise it is left untouched.

@itemize
@item
In the parent process: the referenced variable is set to @ctrue{}.

@item
In the child process: the referenced variable is set to @cfalse{}.
@end itemize

Regarding the argument @var{child_process_pid_p}: the referenced variable is mutated only in the
parent process and when a call is successful, otherwise it is left untouched.

@itemize
@item
In the parent process: the referenced variable is set to the child process identifier.

@item
In the child process: the referenced variable is left untouched.
@end itemize
@end deftypefun

@c page
@node processes waiting
@section Waiting for process completion


@menu
* processes waiting args::      Conventions for common arguments.
* processes waiting options::   Process completion waiting options.
* processes waiting waitpid::   Waiting with @cfunc{waitpid}.
* processes waiting other::     Waiting with other functions.
@end menu

@c page
@node processes waiting args
@subsection Conventions for common arguments


This section documents the common arguments in calls to process--completion waiting--functions; to
make sense of these arguments, we need to remember that:

@itemize
@item
it is possible to wait for the completion of one among a set of processes; we do not know of which
of those we will collect the completion--status;

@item
it is possible to test if a process completion--status is available without blocking the execution
until it is actually available.
@end itemize

@table @code
@item bool * @var{process_completion_status_is_available_p}
This argument is a pointer which cannot be @cnull{}; when the function call is successful:

@itemize
@item
if we have collected the completion--status of a process: the referenced variable is set to
@ctrue{};

@item
if no completion--status was collected: the referenced variable is set to @cfalse{};
@end itemize

@noindent
when the function call is a failure: the referenced variable is left untouched;

@item mmux_libc_pid_t * @var{completed_process_pid_p}
This argument is a pointer which cannot be @cnull{}; when the function call is successful and we
have collected the completion--status of a process: the PID of the completed process is stored in
the referenced variable, otherwise the variable is left untouched;

@item mmux_libc_process_completion_status_t * @var{process_completion_status_p}
This argument is a pointer which cannot be @cnull{}; when the function call is successful and we
have collected the completion--status of a process: such status is stored in the referenced
variable, otherwise the variable is left untouched.
@end table

@c page
@node processes waiting options
@subsection Process completion waiting options


@deftp {Opaque Data Structure} mmux_libc_process_completion_waiting_options_t
Data structure type representing process--completion waiting--options.  It must contain a bitwise OR
combination of the constants listed below.
@end deftp


@deftypefun mmux_libc_process_completion_waiting_options_t mmux_libc_process_completion_waiting_options (mmux_standard_sint_t @var{waiting_options})
Build and return a new instance of @objtype{mmux_libc_process_completion_waiting_options_t}, for
details @MmuxCFuncpage{waitpid}.

@example
auto  waiting_options =
  mmux_libc_process_completion_waiting_options(MMUX_LIBC_WNOHANG | MMUX_LIBC_WEXITED);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineProcessCompletionWaitingOptionConstant{NAME}
@defvr {Constant} @value{PackageApiPrefixUpper}\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{@value{PackageApiPrefixUpper}\NAME\} evaluates to the C language constant @code{\NAME\}; it can be
either a preprocessor symbol or an enumerated symbol; it can be defined or not depending on the
features of the underlying platform.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbol
@samp{@value{PackageApiPrefixUpper}\NAME\} is available.
@end defvr

@end macro

@MmuxDefineProcessCompletionWaitingOptionConstant{WEXITED}
@MmuxDefineProcessCompletionWaitingOptionConstant{WNOHANG}
@MmuxDefineProcessCompletionWaitingOptionConstant{WNOWAIT}
@MmuxDefineProcessCompletionWaitingOptionConstant{WSTOPPED}
@MmuxDefineProcessCompletionWaitingOptionConstant{WCONTINUED}
@MmuxDefineProcessCompletionWaitingOptionConstant{WUNTRACED}

@c page
@node processes waiting waitpid
@subsection Waiting with @cfunc{waitpid}


For the documentation of the common arguments see @ref{processes waiting args, Convention for common
arguments}.


@deftypefun bool mmux_libc_wait_any_process (bool * @var{process_completion_status_is_available_p}, mmux_libc_process_completion_status_t * @var{process_completion_status_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_process_completion_waiting_options_t @var{waiting_options})
@MmuxCInterface{waitpid}.  Wait for the termination of any child process.

@example
bool                                    process_completion_status_is_available;
mmux_libc_process_completion_status_t   process_completion_status;
mmux_libc_pid_t                         completed_process_pid;
auto  waiting_options = mmux_libc_process_completion_waiting_options(MMUX_LIBC_WNOHANG);

if (mmux_libc_wait_any_process(&process_completion_status_is_available,
                               &process_completion_status,
                               &completed_process_pid,
                               waiting_options)) @{
  ... /* handle the error */
@} else if (process_completion_status_is_available) @{
  ... /* do something with "process_completion_status" */
@} else @{
  ... /* no completed process status was collected */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_my_process_group (bool * @var{process_completion_status_is_available_p}, mmux_libc_process_completion_status_t * @var{process_completion_status_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_process_completion_waiting_options_t @var{waiting_options})
@MmuxCInterface{waitpid}.  Wait for the termination of any child process in the same process group
of the calling process.

@example
bool                                   process_completion_status_is_available;
mmux_libc_process_completion_status_t  process_completion_status;
mmux_libc_pid_t                        completed_process_pid;
auto  waiting_options = mmux_libc_process_completion_waiting_options(MMUX_LIBC_WNOHANG);

if (mmux_libc_wait_my_process_group(&process_completion_status_is_available,
                                    &process_completion_status,
                                    &completed_process_pid,
                                    waiting_options)) @{
  ... /* handle the error */
@} else if (process_completion_status_is_available) @{
  ... /* do something with "process_completion_status" */
@} else @{
  ... /* no completed process status was collected */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_process_id (bool * @var{process_completion_status_is_available_p}, mmux_libc_process_completion_status_t * @var{process_completion_status_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_pid_t @var{pid}, mmux_libc_process_completion_waiting_options_t @var{waiting_options})
@MmuxCInterface{waitpid}.  Wait for the termination of a specific process whose process identifier
is @var{pid}.

@example
bool                    this_is_the_parent_process;
mmux_libc_pid_t         child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  ... /* handle the error */
@} else if (this_is_the_parent_process) @{
  bool                                   process_completion_status_is_available;
  mmux_libc_process_completion_status_t  process_completion_status;
  mmux_libc_pid_t                        completed_process_pid;
  auto  waiting_options = mmux_libc_process_completion_waiting_options(MMUX_LIBC_WNOHANG);

  if (mmux_libc_wait_process_id(&process_completion_status_is_available,
                                &process_completion_status,
                                &completed_process_pid,
                                child_pid, waiting_options)) @{
    ... /* handle the error */
  @} else if (process_completion_status_is_available) @{
    ... /* do something with "process_completion_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@} else @{
  ... /* do something in the child process */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_group_id (bool * @var{process_completion_status_is_available_p}, mmux_libc_process_completion_status_t * @var{process_completion_status_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_gid_t @var{gid}, mmux_libc_process_completion_waiting_options_t @var{waiting_options})
@MmuxCInterface{waitpid}.  Wait for the termination of any process belonging to the process group
@var{gid}.

@example
mmux_libc_gid_t       the_gid;

if (mmux_libc_getgid(&the_gid)) @{
  ... /* handle the error */
@} else @{
  bool                                   process_completion_status_is_available;
  mmux_libc_process_completion_status_t  process_completion_status;
  mmux_libc_pid_t                        completed_process_pid;
  auto  waiting_options = mmux_libc_process_completion_waiting_options(MMUX_LIBC_WNOHANG);

  if (mmux_libc_wait_group_id(&process_completion_status_is_available,
                              &process_completion_status,
                              &completed_process_pid,
                              the_gid, waiting_options)) @{
    ... /* handle the error */
  @} else if (process_completion_status_is_available) @{
    ... /* do something with "process_completion_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@}
@end example
@end deftypefun

@c page
@node processes waiting other
@subsection Waiting with other functions


For the documentation of the common arguments see @ref{processes waiting args, Convention for common
arguments}.


@deftypefun bool mmux_libc_wait (bool * @var{process_completion_status_is_available_p}, mmux_libc_process_completion_status_t * @var{process_completion_status_p}, mmux_libc_pid_t * @var{completed_process_pid_p})
@MmuxCInterface{wait}.  Wait for the termination of any child process.

@example
bool                                   process_completion_status_is_available;
mmux_libc_process_completion_status_t  completed_process_status;
mmux_libc_pid_t                        completed_process_pid;

if (mmux_libc_wait(&process_completion_status_is_available,
                   &completed_process_status
                   &completed_process_pid)) @{
  ... /* handle the error */
@} else if (process_completion_status_is_available) @{
  ... /* do something with "completed_process_status" */
@} else @{
  ... /* no completed process status was collected */
@}
@end example
@end deftypefun

@c page
@node processes exiting
@section Exiting processes


@deftp {Struct Typedef} mmux_libc_process_exit_status_t
Type of the exit status constants.
@end deftp


@deftypefun mmux_libc_process_exit_status_t mmux_libc_process_exit_status (mmux_standard_sint_t @var{status_num})
@deftypefunx bool mmux_libc_make_process_exit_status (mmux_libc_process_exit_status_t * @var{status_p}, mmux_standard_sint_t @var{exit_status_num})
Constructor for objects of type @objtype{mmux_libc_process_exit_status}.

@example
auto  status1 = mmux_libc_process_exit_status(77);
mmux_libc_process_exit_status_t  status2;

mmux_libc_make_process_exit_status(&status2, 77)
@end example
@end deftypefun


@deftypefun bool mmux_libc_exit (mmux_libc_process_exit_status_t @var{status})
@MmuxCInterface{exit}.
@end deftypefun


@deftypefun bool mmux_libc_exit_success (void)
@deftypefunx bool mmux_libc_exit_failure (void)
Wrappers for @cfunc{mmux_libc_exit} that terminate the current process with, respectively, the
status @code{MMUX_LIBC_EXIT_SUCCESS} or @code{MMUX_LIBC_EXIT_FAILURE}.
@end deftypefun


@deftypefun bool mmux_libc__exit (mmux_libc_process_exit_status_t @var{status})
@MmuxCInterface{_exit}.
@end deftypefun


@deftypefun bool mmux_libc_atexit (void (* @var{function_pointer}) (void))
@MmuxCInterface{atexit}.
@end deftypefun

@c page
@node signals
@chapter Interprocess signals handling


@menu
* signals signals::             Representing interprocess signals.
* signals delivering::          Delivering interprocess signals.
* signals bub::                 Block/unblock interprocess signals handling.
* signals handling::            Other interprocess signals delivering methods.
@end menu

@c page
@node signals signals
@section Representing interprocess signals


@deftp {Struct Typedef} mmux_libc_interprocess_signal_t
Opaque data structure type representing an interprocess signal number.  It has a single anonymous
field of type @objtype{mmux_sint_t}, so we can access the numeric value of the signal with:

@example
auto  ipxsig = MMUX_LIBC_SIGUSR1;

mmux_libc_dprintf("%s\n", ipxsig.value);
@end example

@noindent
or code like:

@example
mmux_libc_interprocess_signal_t  ipxsig;

mmux_libc_WTERMSIG(&ipxsig, process_completion_status);
if (ipxsig.value == MMUX_LIBC_SIGUSR1.value) @{
  ...
@}
@end example

@noindent
or code like:

@example
mmux_libc_interprocess_signal_t  ipxsig, expected_ipxsig = MMUX_LIBC_SIGUSR1;
bool                             the_signal_is_the_expected_one;

mmux_libc_WTERMSIG(&ipxsig, process_completion_status);
mmux_sint_equal_p(&the_signal_is_the_expected_one, &ipxsig, &expected_ipxsig);
if (the_signal_is_the_expected_one) @{
  ...
@}
@end example
@end deftp


@deftypefun bool mmux_libc_interprocess_signal_dump (mmux_libc_fd_arg_t @var{fd}, mmux_libc_interprocess_signal_t @var{ipxsig})
Write to @var{fd} a string representation of the given signal.

@example
auto            ipxsig = MMUX_LIBC_SIGUSR1;
mmux_libc_fd_t  fd;

mmux_libc_stder(fd);
mmux_libc_interprocess_signal_dump(fd, ipxsig);
@print{} SIGUSR1
@end example
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signal_parse (mmux_libc_interprocess_signal_t * @var{ipxsig_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse a string which is meant to be the representation of an interprocess signal symbol; when
successful store the result in the variable referenced by @var{ipxsig_p}, then return @cfalse{};
otherwise leave @var{ipxsig_p} untouched and return @ctrue{}.

In case of failure: if @var{who} is not @cnull{}, print on @stderr{} a message describing the
parsing error; @var{who} must reference an @MmuxAsciiZ{} string representing the entity that requested
the parsing operation, for example: the name of a C function.

@example
mmux_asciizcp_t                  input_string = "SIGUSR1";
mmux_libc_interprocess_signal_t  ipxsig;

if (mmux_libc_interprocess_signal_parse(&ipxsig, input_string, __func__)) @{
  /* error */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineInterprocessSignalConstant{NAME}
@defvr {Constant} @value{PackageApiPrefixUpper}\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{@value{PackageApiPrefixUpper}\NAME\} evaluates to an instance of
@objtype{mmux_libc_interprocess_signal_t} representing the signal number @samp{\NAME\}.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbol
@samp{@value{PackageApiPrefixUpper}\NAME\} is available.
@end defvr

@end macro

@MmuxDefineInterprocessSignalConstant{NSIG}
@MmuxDefineInterprocessSignalConstant{SIGFPE}
@MmuxDefineInterprocessSignalConstant{SIGILL}
@MmuxDefineInterprocessSignalConstant{SIGSEGV}
@MmuxDefineInterprocessSignalConstant{SIGBUS}
@MmuxDefineInterprocessSignalConstant{SIGABRT}
@MmuxDefineInterprocessSignalConstant{SIGIOT}
@MmuxDefineInterprocessSignalConstant{SIGTRAP}
@MmuxDefineInterprocessSignalConstant{SIGEMT}
@MmuxDefineInterprocessSignalConstant{SIGSYS}
@MmuxDefineInterprocessSignalConstant{SIGTERM}
@MmuxDefineInterprocessSignalConstant{SIGINT}
@MmuxDefineInterprocessSignalConstant{SIGQUIT}
@MmuxDefineInterprocessSignalConstant{SIGKILL}
@MmuxDefineInterprocessSignalConstant{SIGHUP}
@MmuxDefineInterprocessSignalConstant{SIGALRM}
@MmuxDefineInterprocessSignalConstant{SIGVRALRM}
@MmuxDefineInterprocessSignalConstant{SIGPROF}
@MmuxDefineInterprocessSignalConstant{SIGIO}
@MmuxDefineInterprocessSignalConstant{SIGURG}
@MmuxDefineInterprocessSignalConstant{SIGPOLL}
@MmuxDefineInterprocessSignalConstant{SIGCHLD}
@MmuxDefineInterprocessSignalConstant{SIGCLD}
@MmuxDefineInterprocessSignalConstant{SIGCONT}
@MmuxDefineInterprocessSignalConstant{SIGSTOP}
@MmuxDefineInterprocessSignalConstant{SIGTSTP}
@MmuxDefineInterprocessSignalConstant{SIGTTIN}
@MmuxDefineInterprocessSignalConstant{SIGTTOU}
@MmuxDefineInterprocessSignalConstant{SIGPIPE}
@MmuxDefineInterprocessSignalConstant{SIGLOST}
@MmuxDefineInterprocessSignalConstant{SIGXCPU}
@MmuxDefineInterprocessSignalConstant{SIGXSFZ}
@MmuxDefineInterprocessSignalConstant{SIGUSR1}
@MmuxDefineInterprocessSignalConstant{SIGUSR2}
@MmuxDefineInterprocessSignalConstant{SIGWINCH}
@MmuxDefineInterprocessSignalConstant{SIGINFO}

@c page
@node signals delivering
@section Delivering interprocess signals


@deftypefun bool mmux_libc_raise (mmux_libc_interprocess_signal_t @var{ipxsignal})
@MmuxCInterface{raise}.

To deliver a signal to the calling process we do:

@example
if (mmux_libc_raise(MMUX_LIBC_SIGUSR1)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_kill (mmux_libc_pid_t pid, mmux_libc_interprocess_signal_t @var{ipxsignal})
@MmuxCInterface{kill}.

To deliver the signal @samp{SIGUSR1} to a child process we do:

@example
bool                    this_is_the_parent_process;
mmux_libc_pid_t         child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  /* error */
@} else if (this_is_the_parent_process) @{
  if (mmux_libc_kill(child_pid, MMUX_LIBC_SIGUSR1)) @{
    /* error */
  @}
@} else @{
  ... /* do something in the child process */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_kill_all_processes_in_same_group (mmux_libc_interprocess_signal_t @var{ipxsignal})
Call the C library function @cfunc{signal} setting the first argument to @samp{0}: it delivers the
signal to all the processes in the same group as the delivering process.
@end deftypefun


@deftypefun bool mmux_libc_kill_group (mmux_libc_gid_t @var{gid}, mmux_libc_interprocess_signal_t @var{ipxsignal})
Deliver the signal to all the processes in the group @var{gid}.
@end deftypefun


@deftypefun bool mmux_libc_kill_all_processes (mmux_libc_interprocess_signal_t @var{ipxsignal})
Call the C library function @cfunc{signal} setting the first argument to @samp{-1}: it delivers the
signal to ``all'' processes, see the documentation for details.  @glibcref{Signaling Another
Process, Signaling Another Process}.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_tgkill (mmux_libc_pid_t @var{pid}, mmux_libc_pid_t @var{tid}, mmux_libc_interprocess_signal_t @var{ipxsignal})
@MmuxCInterface{tgkill}.  Deliver the signal to thread @var{tid} belonging to the process @var{pid}.
@end deftypefn

@c page
@node signals bub
@section Block/unblock interprocess signals handling


@cindex @bub{} interprocess signals @api{}
@cindex @bub{} signals @api{}
@cindex Block/unblock interprocess signals @api{}
@cindex Interprocess signals, block/unblock @api{}
@cindex Signals, block/unblock @api{}


The block/unblock (@bub{}) @api{} is a simplified interface to detect the arrival of interprocess
signals; if it does not suit the application's model, we should just ignore it.  It is impossible to
use the @bub{} @api{} along with other interprocess signal @api{}s.  Here is a meaningless usage
example:

@example
if (mmux_libc_interprocess_signals_bub_init()) @{
  /* error */
@}

/* Deliver a signal to the calling process. */
if (mmux_libc_raise(MMUX_LIBC_SIGUSR1)) @{
  /* error */
@}

/* Unblock all the signals, then block them again. */
if (mmux_libc_interprocess_signals_bub_acquire()) @{
  /* error */
@}

/* Check if the signal was delivered. */
@{
  bool  delivered;

  if (mmux_libc_interprocess_signals_bub_delivered(&result, MMUX_LIBC_SIGUSR1)) @{
    /* error */
  @}
  if (delivered) @{
    /* react to the signal */
  @}
@}

if (mmux_libc_interprocess_signals_bub_final()) @{
  /* error */
@}
@end example


@deftypefun bool mmux_libc_interprocess_signals_bub_init (void)
Block all the signals and initialise the @bub{} interface.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signals_bub_final (void)
Set all the signal handlers to @code{SIG_IGN}, then unblock all the signals and finalise the @bub{}
interface.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signals_bub_acquire (void)
Unblock all the signals, then block them again.  This should allow all the pending signals to be
delivered to the process.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signals_bub_delivered (bool * @var{result_p}, mmux_libc_interprocess_signal_t @var{ipxsignal})
When successful: store @ctrue{} in the variable referenced by @var{result_p} if the signal
@var{ipxsignal} has been delivered at least once @strong{before} the last call to
@cfunc{mmux_libc_interprocess_signal_bub_acquire}.

Calling this function with @var{ipxsignal} clears the internal flag for this signal, so calling it
again without acquiring new signals always stores @false{} in the variable referenced by
@var{result_p}.
@end deftypefun

@c page
@node signals handling
@section Other interprocess signals delivering methods


@deftypefn {Function Type} bool mmux_libc_sighandler_t (mmux_sint_t @var{signum})
Type of functions to be used as interprocess signal handlers.
@end deftypefn


@deftypefun bool mmux_libc_retrieve_signal_handler_SIG_DFL (mmux_libc_sighandler_t ** @var{result_p})
@deftypefunx bool mmux_libc_retrieve_signal_handler_SIG_IGN (mmux_libc_sighandler_t ** @var{result_p})
@deftypefunx bool mmux_libc_retrieve_signal_handler_SIG_ERR (mmux_libc_sighandler_t ** @var{result_p})
Store in the variable referenced by @var{result_p} the corresponding signal handling action.

The value @samp{SIG_ERR} is a special value used by @cfunc{signal} to return error, but it is
provided in this @api{} for completeness.
@end deftypefun


@deftypefun bool mmux_libc_signal (mmux_libc_sighandler_t ** @var{result_p}, mmux_libc_interprocess_signal_t @var{ipxsignal}, mmux_libc_sighandler_t @var{action})
@MmuxCInterface{signal}.  When successful: store in the variable referenced by @var{result_p} the
action that was previously set for @var{ipxsignal}.

To set the default action for @samp{SIGUSR1} we do:

@example
@{
  mmux_libc_interprocess_signal_t       ipxsignal;
  mmux_libc_sighandler_t *              the_old_handler;
  mmux_libc_sighandler_t *              the_new_handler;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  mmux_libc_retrieve_signal_handler_SIG_DFL(&the_new_handler);
  if (mmux_libc_signal(&the_old_hadler, ipxsignal, the_new_handler)) @{
    /* error */
  @}
@}
@end example

To set a custom action for @samp{SIGUSR1} we do:

@example
static void
my_handler (mmux_sint_t signum)
@{
  ...
@}

@{
  mmux_libc_interprocess_signal_t       ipxsignal;
  mmux_libc_sighandler_t *              the_old_handler;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  if (mmux_libc_signal(&the_old_handler, ipxsignal, my_handler)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pause (void)
@MmuxCInterface{pause}.

It is usually not useful to check the return value of @cfunc{pause}, but we need to remember that,
by convention: the successful execution of @cfunc{mmux_libc_pause} is to pause the process forever;
so, it if returns, it is considered a failure.

After calling @cfunc{mmux_libc_pause}:

@itemize
@item
if the current process receives a signal for which a handler was registered: the handler will be
invoked, then @cfunc{mmux_libc_pause} will return @ctrue{};

@item
if the current process receives a signal for which @strong{no} handler was registered: the process
will terminate and @cfunc{mmux_libc_pause} will @strong{not} return.
@end itemize
@end deftypefun

@c page
@node fds
@chapter File descriptors


File descriptors are used to represent data sources and data destinations for the process's input
and output facilities.  As simple example, to write a formatted string to @stdout{} we do:

@example
mmux_libc_fd_t  fd;

mmux_libc_stdou(fd);
if (mmux_libc_dprintf(fd, "the integer is: %d\n", 123)) @{
  /* error */
@}
@end example

@menu
* fds fds::                     File descriptors type.
* fds dirfds::                  Directory file descriptors type.
* fds standard::                Standard file descriptors.
* fds printing::                Printing formatted output.
* fds opening::                 Opening file descriptors.
* fds closing::                 Closing file descriptors.
* fds reading::                 Reading from file descriptors.
* fds writing::                 Writing to file descriptors.
* fds seeking::                 Seeking position in file descriptors.
* fds duplicating::             Duplicating file descriptors.
* fds piping::                  Opening file descriptor pipes.
* fds selecting::               Selecting file descriptors.
* fds scatter-gather::          Scatter--gather input and output.
* fds copying::                 Copying ranges from file to file.
* fds flock::                   File locks.
* fds fun control::             File descriptors functionality control.
* fds io control::              File descriptors input/output control.
* fds memfd::                   Memory-mapped file descriptors.
* fds predicates::              File predicates with file descriptors.
* fds attributes::              Inspecting file attributes through file descriptors.
@end menu

@c page
@node fds fds
@section File descriptors type


@deftp {Struct Type} mmux_libc_file_descriptor_t
@deftpx {Parent Struct Type} mmux_sint_t
Data structure type representing file descriptors.
@end deftp


@deftp {Struct Pointer Type} mmux_libc_fd_t
Pointer type defined as:

@example
typedef mmux_libc_file_descriptor_t  mmux_libc_fd_t[1];
@end example

@noindent
it is meant to be used to define local variables and as type of result in function calls that open a
new file descriptor or retrieve an already opened file descriptor, so the referenced
@objtype{mmux_libc_file_descriptor_t} instance must be mutable.
@end deftp


@deftp {Struct Pointer Type} mmux_libc_fd_arg_t
Pointer type defined as:

@example
typedef mmux_libc_file_descriptor_t const *  mmux_libc_fd_arg_t;
@end example

@noindent
it is meant to be used as type of immutable arguments to functions.
@end deftp


@deftypefun bool mmux_libc_make_fd (mmux_libc_fd_t @var{fd}, mmux_standard_sint_t @var{fd_num})
Make a new file descriptor value.  If @var{fd_num} is negative: @var{fd} is left untouched and the
return value is @ctrue{}.

@example
mmux_libc_fd_t  in, ou, er;

mmux_libc_make_fd(&in, STDIN_FILENO);
mmux_libc_make_fd(&ou, STDOUT_FILENO);
mmux_libc_make_fd(&er, STDERR_FILENO);
@end example
@end deftypefun

@c page
@node fds dirfds
@section Directory file descriptors type


Directory file descriptors are represented as instances of
@objtype{mmux_libc_directory_file_descriptor_t}; we can open a file descriptor referencing a file
system directory with the opening functions like @func{mmux_libc_open} using the flag
@samp{MMUX_LIBC_O_DIRECTORY}; we are required to use directory file descriptors with functions like
@cfunc{mmux_libc_openat} and similar.


@deftp {Struct Type} mmux_libc_directory_file_descriptor_t
@deftpx {Parent Struct Type} mmux_libc_file_descriptor_t
Data structure type representing directory file descriptors.
@end deftp


@deftp {Struct Pointer Type} mmux_libc_dirfd_t
Pointer type defined as:

@example
typedef mmux_libc_directory_file_descriptor_t  mmux_libc_dirfd_t[1];
@end example

@noindent
it is meant to be used to define local variables and as type of result in function calls that open a
new directory file descriptor or retrieve an already opened file descriptor, so the referenced
@objtype{mmux_libc_directory_file_descriptor_t} instance must be mutable.
@end deftp


@deftp {Struct Pointer Type} mmux_libc_dirfd_arg_t
Pointer type defined as:

@example
typedef mmux_libc_directory_file_descriptor_t const *  mmux_libc_dirfd_arg_t;
@end example

@noindent
it is meant to be used as type of immutable arguments to functions.
@end deftp


@deftypefun bool mmux_libc_at_fdcwd (mmux_libc_dirfd_t @var{dirfd})
Store in the variable referenced by @var{dirfd} the directory file descriptor associated to the
constant @code{AT_FDCWD}.  We can use it with @cfunc{mmux_libc_openat} and similar functions.
@end deftypefun


@deftypefun bool mmux_libc_make_dirfd (mmux_libc_dirfd_t @var{dirfd}, mmux_standard_sint_t @var{dirfd_num})
Make a new file descriptor value representing a file system directory.  If @var{dirfd_num} is
negative: @var{dirfd} is left untouched and the return value is @ctrue{}.
@end deftypefun

@c page
@node fds standard
@section Standard file descriptors


@cindex Standard input file descriptor
@cindex Standard output file descriptor
@cindex Standard error file descriptor
@cindex File descriptor for standard input
@cindex File descriptor for standard output
@cindex File descriptor for standard error
@cindex @stdin{} file descriptor
@cindex @stdout{} file descriptor
@cindex @stderr{} file descriptor


@deftypefun bool mmux_libc_stdin (mmux_libc_fd_t @var{fd})
Retrieve the file descriptor value associated to the standard input.
@end deftypefun


@deftypefun bool mmux_libc_stdou (mmux_libc_fd_t @var{fd})
Retrieve the file descriptor value associated to the standard output.
@end deftypefun


@deftypefun bool mmux_libc_stder (mmux_libc_fd_t @var{fd})
Retrieve the file descriptor value associated to the standard error.
@end deftypefun

@c page
@node fds printing
@section Printing formatted output


To print a formatted string to a file descriptor, we do:

@example
mmux_libc_fd_t  fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_asciizcp_t             ptn_asciiz = "/path/to/file.ext";
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open an existing file for writing. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_WRONLY);
    auto  mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    if (mmux_libc_unmake_file_system_pathname(fs_ptn)) @{
      /* error */
    @}
  @}
@}

/* Print something to the file. */
@{
  if (mmux_libc_dprintf(fd, "the number is %d\n", 123)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example

To print to @stdout{} and @stderr{}:

@example
if (mmux_libc_dprintfou("the number is %d\n", 123)) @{
  /* error */
@}
if (mmux_libc_dprintfer("the number is %d\n", 456)) @{
  /* error */
@}
@end example


@deftypefun bool mmux_libc_dprintf (mmux_libc_fd_arg_t @var{fd}, mmux_asciizcp_t @var{template}, ...)
@deftypefunx bool mmux_libc_dprintfou (mmux_asciizcp_t template, ...)
@deftypefunx bool mmux_libc_dprintfer (mmux_asciizcp_t template, ...)
@MmuxCInterface{dprintf}.  Print the message to, respectively: @var{fd}, @stdout{}, @stderr{}.
@end deftypefun


@deftypefun bool mmux_libc_vdprintf (mmux_libc_fs_arg_t @var{fd}, mmux_asciizcp_t @var{template}, va_list @var{ap})
@deftypefunx bool mmux_libc_vdprintfou (mmux_asciizcp_t @var{template}, va_list @var{ap})
@deftypefunx bool mmux_libc_vdprintfer (mmux_asciizcp_t @var{template}, va_list @var{ap})
@MmuxCInterface{vdprintf}.  Print the message to, respectively: @var{fd}, @stdout{}, @stderr{}.
Notice that @file{stdarg.h} is already included by @value{PackageHeaderFile}.

@example
bool
my_print_error (mmux_asciizcp_t template, ...)
@{
  bool          rv;
  va_list       ap;

  va_start(ap, template);
  @{
    rv = mmux_libc_vdprintfer(template, ap);
  @}
  va_end(ap);
  return rv;
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_dprintf_newline (mmux_libc_fd_arg_t @var{fd})
@deftypefunx bool mmux_libc_dprintfou_newline (void)
@deftypefunx bool mmux_libc_dprintfer_newline (void)
Print a single newline character to, respectively: @var{fd}, @stdout{}, @stderr{}.
@end deftypefun


@anchor{mmux_libc_dprintf_strerror}
@deftypefun bool mmux_libc_dprintf_strerror (mmux_libc_fd_arg_t @var{fd}, mmux_libc_errno_t @var{errnum})
Wrapper for @cfunc{mmux_libc_dprintf} that prints to @var{fd} the @MmuxAsciiZ{} string resulting
from a call to @cfunc{mmux_libc_strerror}.
@end deftypefun


@anchor{mmux_libc_dprintf_strftime}
@deftypefun bool mmux_libc_dprintf_strftime (mmux_libc_fd_arg_t @var{fd}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
Wrapper for @cfunc{mmux_libc_dprintf} that prints to @var{fd} the timestamp representation of
@var{BT} formatted according to @var{template} using @cfunc{mmux_libc_strftime},
@ref{mmux_libc_strftime} for details.
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineTypePrinterFunc{STEM}
@anchor{mmux_libc_dprintf_\STEM\}
@deftypefun bool mmux_libc_dprintf_\STEM\ (mmux_libc_fd_arg_t @var{fd}, mmux_\STEM\_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun

@end macro

@MmuxDefineTypePrinterFunc{pointer}

@MmuxDefineTypePrinterFunc{schar}
@MmuxDefineTypePrinterFunc{uchar}
@MmuxDefineTypePrinterFunc{sshort}
@MmuxDefineTypePrinterFunc{ushort}
@MmuxDefineTypePrinterFunc{sint}
@MmuxDefineTypePrinterFunc{uint}
@MmuxDefineTypePrinterFunc{slong}
@MmuxDefineTypePrinterFunc{ulong}
@MmuxDefineTypePrinterFunc{sllong}
@MmuxDefineTypePrinterFunc{ullong}

@MmuxDefineTypePrinterFunc{sint8}
@MmuxDefineTypePrinterFunc{uint8}
@MmuxDefineTypePrinterFunc{sint16}
@MmuxDefineTypePrinterFunc{uint16}
@MmuxDefineTypePrinterFunc{sint32}
@MmuxDefineTypePrinterFunc{uint32}
@MmuxDefineTypePrinterFunc{sint64}
@MmuxDefineTypePrinterFunc{uint64}

@MmuxDefineTypePrinterFunc{usize}
@MmuxDefineTypePrinterFunc{ssize}

@MmuxDefineTypePrinterFunc{sintmax}
@MmuxDefineTypePrinterFunc{uintmax}
@MmuxDefineTypePrinterFunc{sintptr}
@MmuxDefineTypePrinterFunc{uintptr}
@MmuxDefineTypePrinterFunc{ptrdiff}
@MmuxDefineTypePrinterFunc{libc_mode}
@MmuxDefineTypePrinterFunc{off}
@MmuxDefineTypePrinterFunc{libc_pid}
@MmuxDefineTypePrinterFunc{libc_uid}
@MmuxDefineTypePrinterFunc{libc_gid}
@MmuxDefineTypePrinterFunc{wchar}
@MmuxDefineTypePrinterFunc{wint}
@MmuxDefineTypePrinterFunc{time}
@MmuxDefineTypePrinterFunc{libc_socklen}
@MmuxDefineTypePrinterFunc{libc_rlim}
@MmuxDefineTypePrinterFunc{libc_ino}
@MmuxDefineTypePrinterFunc{libc_dev}
@MmuxDefineTypePrinterFunc{libc_nlink}
@MmuxDefineTypePrinterFunc{libc_blkcnt}

@MmuxDefineTypePrinterFunc{flonumfl}
@MmuxDefineTypePrinterFunc{flonumdb}
@MmuxDefineTypePrinterFunc{flonumldb}

@MmuxDefineTypePrinterFunc{flonumf32}
@MmuxDefineTypePrinterFunc{flonumf64}
@MmuxDefineTypePrinterFunc{flonumf128}

@MmuxDefineTypePrinterFunc{flonumf32x}
@MmuxDefineTypePrinterFunc{flonumf64x}
@MmuxDefineTypePrinterFunc{flonumf128x}

@MmuxDefineTypePrinterFunc{flonumd32}
@MmuxDefineTypePrinterFunc{flonumd64}
@MmuxDefineTypePrinterFunc{flonumd128}

@MmuxDefineTypePrinterFunc{flonumcfl}
@MmuxDefineTypePrinterFunc{flonumcdb}
@MmuxDefineTypePrinterFunc{flonumcldb}

@MmuxDefineTypePrinterFunc{flonumcf32}
@MmuxDefineTypePrinterFunc{flonumcf64}
@MmuxDefineTypePrinterFunc{flonumcf128}

@MmuxDefineTypePrinterFunc{flonumcf32x}
@MmuxDefineTypePrinterFunc{flonumcf64x}
@MmuxDefineTypePrinterFunc{flonumcf128x}

@MmuxDefineTypePrinterFunc{flonumcd32}
@MmuxDefineTypePrinterFunc{flonumcd64}
@MmuxDefineTypePrinterFunc{flonumcd128}

@anchor{mmux_libc_dprintf_libc_fd}
@deftypefun bool mmux_libc_dprintf_libc_fd (mmux_libc_fd_arg_t @var{fd}, mmux_libc_fd_arg_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_fs_ptn}
@deftypefun bool mmux_libc_dprintf_fs_ptn (mmux_libc_fd_arg_t @var{fd}, mmux_libc_fs_ptn_arg_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_fs_ptn_extension}
@deftypefun bool mmux_libc_dprintf_fs_ptn_extension (mmux_libc_fd_arg_t @var{fd}, mmux_libc_fs_ptn_extension_arg_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_fs_ptn_segment}
@deftypefun bool mmux_libc_dprintf_fs_ptn_segment (mmux_libc_fd_arg_t @var{fd}, mmux_libc_fs_ptn_segment_arg_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_libc_process_completion_status}
@deftypefun bool mmux_libc_dprintf_libc_process_completion_status (mmux_libc_fd_arg_t @var{fd}, mmux_libc_process_completion_status_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_libc_interprocess_signal}
@deftypefun bool mmux_libc_dprintf_libc_interprocess_signal (mmux_libc_fd_arg_t @var{fd}, mmux_libc_interprocess_signal_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun

@c page
@node fds opening
@section Opening file descriptors


@menu
* fds opening standard::        Standard file descriptor opening.
* fds opening extended::        Extended file descriptor opening.
@end menu

@c page
@node fds opening standard
@subsection Standard file descriptor opening


@deftp {Struct Type} mmux_libc_open_flags_t
Data structure representing a bitwise OR combination of flags for opening file descriptors.
@end deftp


@deftypefun mmux_libc_open_flags_t mmux_libc_open_flags (mmux_standard_sint_t @var{value})
Build and return a new instance of @objtype{mmux_libc_open_flags_t}.
@end deftypefun


@deftypefun bool mmux_libc_open (mmux_libc_fd_t @var{fd_result}, mmux_libc_fs_ptn_arg_t @var{fs_ptn}, mmux_libc_open_flags_t @var{flags}, mmux_libc_mode_t @var{mode})
@MmuxCInterface{open}.

@example
mmux_libc_fd_t  fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_asciizcp_t             ptn_asciiz = "/path/to/file.ext";
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open a file for writing. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);
    auto  mode  = mmux_libc_mode(MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    if (mmux_libc_unmake_file_system_pathname(fs_ptn)) @{
      /* error */
    @}
  @}
@}

@{
  /* Do something with "fd". */
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_openat (mmux_libc_fd_t @var{fd_result}, mmux_libc_dirfd_arg_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{fs_ptn}, mmux_libc_open_flags_t @var{flags}, mmux_libc_mode_t @var{mode})
@MmuxCInterface{openat}.

@example
mmux_libc_fd_t  fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_asciizcp_t             ptn_asciiz = "/path/to/file.ext";
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open a file for writing. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);
    auto  mode  = mmux_libc_mode(MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

    mmux_libc_at_fdcwd(&dirfd);
    if (mmux_libc_openat(fd, dirfd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    if (mmux_libc_unmake_file_system_pathname(fs_ptn)) @{
      /* error */
    @}
  @}
@}

@{
  /* Do something with "fd". */
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fds opening extended
@subsection Extended file descriptor opening


The function @cfunc{openat2} and the data structure @code{struct open_how} are system extensions
implemented by the Linux kernel.  Under @value{PACKAGE}: the data structure type is aliased by the
object type @objtype{mmux_libc_file_descriptor_open_how_t}.

To define then dump the contents of @code{mmux_libc_file_descriptor_open_how_t} we can do:

@example
mmux_libc_open_how_t  open_how;

mmux_libc_open_how_memzero(open_how);

mmux_libc_open_how_flags_set(open_how, \
  MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);

mmux_libc_open_how_mode_set(open_how, \
  MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

mmux_libc_open_how_resolve_set(open_how,  \
  MMUX_LIBC_RESOLVE_BENEATH             | \
  MMUX_LIBC_RESOLVE_NO_MAGICLINKS       | \
  MMUX_LIBC_RESOLVE_NO_SYMLINKS         | \
  MMUX_LIBC_RESOLVE_NO_XDEV);

@{
  mmux_libc_fd_t  er;

  mmux_libc_stder(er);
  if (mmux_libc_open_how_dump(er, open_how, NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
notice how the Linux kernel demands the data structure to be reset to zero before use; this code
prints:

@example
struct open_how = 0x7ffca7af5b80
struct open_how->flags = 194 (O_CREAT | O_EXCL | O_RDWR)
struct open_how->mode = 384 (S_IRUSR | S_IRWXU | S_IWUSR)
struct open_how->resolve = 15 (RESOLVE_BENEATH | RESOLVE_NO_MAGICLINKS | RESOLVE_NO_SYMLINKS | RESOLVE_NO_XDEV)
@end example


@deftp {Opaque Struct Typedef} mmux_libc_file_descriptor_open_how_t
@deftpx {Struct Pointer Typedef} mmux_libc_open_how_t
@deftpx {Struct Pointer Typedef} mmux_libc_open_how_arg_t
An opaque alias for @MmuxCStruct{open_how}.  The pointer types are defined as:

@example
typedef mmux_libc_file_descriptor_open_how_t            mmux_libc_open_how_t[1];
typedef mmux_libc_file_descriptor_open_how_t const *    mmux_libc_open_how_arg_t;
@end example

@noindent
the type @objtype{mmux_libc_open_how_t} is used to define local variables and to declare mutable
arguments to functions; the type @objtype{mmux_libc_open_how_arg_t} is used to declare immutable
arguments to functions.
@end deftp


@deftypefun bool mmux_libc_open_how_flags_set (mmux_libc_open_how_t @var{open_how}, mmux_uint64_t @var{flags})
@deftypefunx bool mmux_libc_open_how_flags_ref (mmux_uint64_t * @var{result_p}, mmux_libc_open_how_arg_t @var{open_how})
Setter and getter for the field @code{flags} of @objtype{mmux_libc_file_descriptor_open_how_t_t}.
@end deftypefun


@deftypefun bool mmux_libc_open_how_mode_set (mmux_libc_open_how_t @var{open_how}, mmux_uint64_t @var{mode})
@deftypefunx bool mmux_libc_open_how_mode_ref (mmux_uint64_t * @var{result_p}, mmux_libc_open_how_arg_t @var{open_how})
Setter and getter for the field @code{mode} of @objtype{mmux_libc_file_descriptor_open_how_t_t}.
@end deftypefun


@deftypefun bool mmux_libc_open_how_resolve_set (mmux_libc_open_how_t @var{open_how}, mmux_uint64_t @var{resolve})
@deftypefunx bool mmux_libc_open_how_resolve_ref (mmux_uint64_t * @var{result_p}, mmux_libc_open_how_arg_t @var{open_how})
Setter and getter for the field @code{resolve} of @objtype{mmux_libc_file_descriptor_open_how_t_t}.
@end deftypefun


@deftypefun bool mmux_libc_open_how_dump (mmux_libc_fd_arg_t @var{fd}, mmux_libc_open_how_arg_t @var{open_how}, mmux_asciizcp_t @var{struct_name})
Write to @var{fd} a description of the fields of the @MmuxCStruct{open_how} referenced by
@var{open_how}.  @var{struct_name} must be a pointer to an @MmuxAsciiZ{} string representing the
name of the data structure used in the description; when @cnull{}: it defaults to
@samp{struct open_how}.
@end deftypefun


@deftypefun bool mmux_libc_open_how_memzero (mmux_libc_open_how_t @var{open_how})
Reset to zero the whole data structure referenced by @var{open_how}.  This is demanded by the Linux
kernel before using the data structure itself.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_openat2 (mmux_libc_fd_t @var{fd_result}, mmux_libc_dirfd_arg_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{fs_ptn}, mmux_libc_open_how_arg_t @var{open_how})
@MmuxCInterface{openat2}.

@example
mmux_acsciizcp_t  ptn_asciiz = "/path/to/file.ext";
mmux_libc_fd_t    fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t    fs_ptn;
  mmux_libc_open_how_t  open_how;

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Configure the opening. */
  @{
    mmux_libc_open_how_memzero(open_how);

    mmux_libc_open_how_flags_set(open_how,
      mmux_uint64(MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL));
    mmux_libc_open_how_mode_set(open_how,
      mmux_uint64(MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR));
    mmux_libc_open_how_resolve_set(open_how,
      mmux_uint64(MMUX_LIBC_RESOLVE_BENEATH        | \
                  MMUX_LIBC_RESOLVE_NO_MAGICLINKS  | \
                  MMUX_LIBC_RESOLVE_NO_SYMLINKS    | \
                  MMUX_LIBC_RESOLVE_NO_XDEV));
  @}

  /* Open the file. */
  @{
    mmux_libc_dirfd_t       dirfd;

    mmux_libc_at_fdcwd(dirfd);
    if (mmux_libc_openat2(fd, dirfd, fs_ptn, open_how)) @{
      /* error */
    @}
  @}

  /* Local cleanup */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

@{
  /* Do something with "fd". a*/
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fds closing
@section Closing file descriptors


@deftypefun bool mmux_libc_close (mmux_libc_fd_t @var{fd})
@MmuxCInterface{close}.
@end deftypefun

@c page
@node fds reading
@section Reading from file descriptors


@deftypefun bool mmux_libc_read (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_fd_arg_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{read}.

@example
mmux_libc_fd_t         fd;
mmux_usize_t           nbytes_done;
auto                   buflen = mmux_usize_literal(4096);
mmux_standard_octet_t  bufptr[buflen.value];

mmux_libc_stdin(fd);
if (mmux_libc_read(&nbytes_done, fd, bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pread (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_fd_arg_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_off_t @var{offset})
@MmuxCInterface{pread}.

@example
mmux_libc_fd_t         fd;
mmux_usize_t           nbytes_done;
auto                   buflen = mmux_usize_literal(4096);
mmux_standard_octet_t  bufptr[buflen.value];
auto                   offset = mmux_off_literal(123);

gimme_an_fd(fd);
if (mmux_libc_pread(&nbytes_done, fd, bufptr, buflen, offset)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds writing
@section Writing to file descriptors


@deftypefun bool mmux_libc_write (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_fd_arg_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{write}.

@example
mmux_libc_fd_t   fd;
mmux_usize_t     nbytes_done;
mmux_usize_t     buflen;
mmux_asciizcp_t  bufptr = "ciao";

mmux_libc_strlen(&buflen, bufptr);
mmux_libc_stdou(fd);
if (mmux_libc_write(&nbytes_done, fd, bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pwrite (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_fd_arg_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_off_t @var{offset})
@MmuxCInterface{pwrite}.

@example
mmux_libc_fd_t   fd;
mmux_usize_t     nbytes_done;
mmux_usize_t     buflen;
mmux_asciizcp_t  bufptr = "ciao";
auto             offset = mmux_off_literal(123);

mmux_libc_strlen(&buflen, bufptr);
gimme_an_fd(fd);
if (mmux_libc_pwrite(&nbytes_done, fd, bufptr, buflen, offset)) @{
  /* error */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_write_buffer (mmux_libc_fd_arg_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@deftypefunx bool mmux_libc_write_buffer_to_stdou (mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@deftypefunx bool mmux_libc_write_buffer_to_stder (mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
Like @cfunc{mmux_libc_write}, but write a buffer to the file descriptor, respectively: @var{fd},
@stdout{}, @stderr{}.  If the number of written bytes equals @var{buflen}: return @cfalse{},
otherwise return @ctrue{}.

These functions exist mostly as tools in debugging code.

@example
mmux_usize_t     buflen;
mmux_asciizcp_t  bufptr = "ciao";

mmux_libc_strlen(&buflen, bufptr);

if (mmux_libc_write_buffer_to_stdou(bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds seeking
@section Seeking position in file descriptors


@deftp {Struct Type} mmux_libc_seek_whence_t
@deftpx {Parent Struct Type} mmux_sshort_t
Data structure type representing values for the @var{whence} argument to @cfunc{mmux_libc_lseek}.
@end deftp


@deftypefun bool mmux_libc_lseek (mmux_libc_fd_arg_t @var{fd}, mmux_off_t * @var{offset_p}, mmux_libc_seek_whence_t @var{whence})
@MmuxCInterface{lseek}.

Upon calling this function: @var{offset_p} must reference a variable whose value represents the
offset from the position selected by @var{whence}.

Upon successfully returning from this function: the variable referenced by @var{offset_p} has been
updated to represent the resulting position, measured in bytes, from the beginning of the file.

@example
mmux_libc_fd_t  fd;
auto            offset = mmux_off_constant_zero();
auto            whence = MMUX_LIBC_SEEK_SET;

gimme_an_fd(fd);
if (mmux_libc_lseek(fd, &offset, whence)) @{
  /* error */
@}

/* now "offset" has been updated */
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineSeekWhenceConstant{NAME}
@defvr {Constant Struct} MMUX_LIBC_\NAME\
@defvrx {Preprocessor Symbol} MMUX_LIBC_VALUEOF_\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{MMUX_LIBC_\NAME\} evaluates to a C language constant of type
@objtype{mmux_libc_seek_whence_t} representing the standard value @code{\NAME\}.

The symbol @samp{MMUX_LIBC_VALUEOF_\NAME\} evaluates to the standard @code{\NAME\} value as exact
integer.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbols
@samp{MMUX_LIBC_\NAME\} and @samp{MMUX_LIBC_VALUEOF_\NAME\} are available.
@end defvr

@end macro

@MmuxDefineSeekWhenceConstant{SEEK_CUR}
@MmuxDefineSeekWhenceConstant{SEEK_DATA}
@MmuxDefineSeekWhenceConstant{SEEK_END}
@MmuxDefineSeekWhenceConstant{SEEK_HOLE}
@MmuxDefineSeekWhenceConstant{SEEK_SET}

@c page
@node fds duplicating
@section Duplicating file descriptors


@deftypefun bool mmux_libc_dup (mmux_libc_fd_t @var{new_fd}, mmux_libc_fd_arg_t @var{old_fd})
@MmuxCInterface{dup}.
@end deftypefun


@deftypefun bool mmux_libc_dup2 (mmux_libc_fd_t @var{new_fd}, mmux_libc_fd_arg_t @var{old_fd})
@MmuxCInterface{dup2}.
@end deftypefun


@deftypefun bool mmux_libc_dup3 (mmux_libc_fd_t @var{new_fd}, mmux_libc_fd_arg_t @var{old_fd}, mmux_libc_open_flags_t @var{flags})
@MmuxCInterface{dup3}.

@example
mmux_libc_fd_t      fd1, fd2;

/* Obtain the source file descriptor. */
@{
  mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file descriptor pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the source file descriptor. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);
    auto  mode  = mmux_libc_mode(MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

    if (mmux_libc_open(fd1, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Duplicate the file descriptor. */
@{
  auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_CLOEXEC);

  /* I'm so dirty. */
  mmux_libc_make_fd(fd2, 5);

  if (mmux_libc_dup3(fd2, fd1, flags)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd1)) @{
    /* error */
  @}
  if (mmux_libc_close(fd2)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fds piping
@section Opening file descriptor pipes


@deftypefun bool mmux_libc_pipe (mmux_libc_file_descriptor_t @var{fds}[2])
@MmuxCInterface{pipe}.

@example
@{
  bool                this_is_the_paren_process;
  mmux_libc_pid_t     child_pid;
  mmux_libc_fd_t      paren_to_child_fds[2];
  mmux_libc_fd_t      paren_fr_child_fds[2];

  if (mmux_libc_pipe(paren_to_child_fds)) @{
    /* error */
  @}

  if (mmux_libc_pipe(paren_fr_child_fds)) @{
    /* error */
  @}

  if (mmux_libc_fork(&this_is_the_paren_process, &child_pid)) @{
    /* error */
  @}

  if (this_is_the_paren_process) @{
    paren_play(paren_fr_child_fds[0], paren_to_child_fds[1], child_pid);
  @} else @{
    child_play(paren_to_child_fds[0], paren_fr_child_fds[1]);
  @}
@}
void
paren_play (mmux_libc_fd_arg_t read_fr_child_fd, mmux_libc_fd_arg_t writ_to_child_fd, mmux_libc_pid_t child_pid)
@{
  ...
@}
void
child_play (mmux_libc_fd_arg_t read_fr_paren_fd, mmux_libc_fd_arg_t writ_to_paren_fd)
@{
  ...
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_close_pipe (mmux_libc_file_descriptor_t @var{fds}[2])
Close both the file descriptors in @var{fds}.  If both closures succeed: return @cfalse{}; otherwise
return @ctrue{}.  If closing the first fails: this function still closes the second.

This function might be useful when an error occurs after we have created a pipe.
@end deftypefun

@c page
@node fds selecting
@section Selecting file descriptors


Example:

@example
mmux_libc_fd_set_t      read_fd_set[1], writ_fd_set[1], exce_fd_set[1];
mmux_uint_t             nfds_ready;
mmux_uint_t             maximum_nfds_to_check = MMUX_LIBC_FD_SETSIZE;
mmux_libc_timeval_t     timeout[1];
mmux_libc_fd_t          in, ou;
bool                    isset;

mmux_libc_stdin(&in);
mmux_libc_stdou(&ou);

mmux_libc_FD_ZERO(read_fd_set);
mmux_libc_FD_ZERO(writ_fd_set);
mmux_libc_FD_ZERO(exce_fd_set);

mmux_libc_FD_SET(in, read_fd_set);
mmux_libc_FD_SET(ou, writ_fd_set);

mmux_libc_timeval_set(timeout, 1, 0);

if (mmux_libc_select(&nfds_ready, maximum_nfds_to_check,
                     read_fd_set, writ_fd_set, exce_fd_set,
                     timeout)) @{
  /* error */
@}

mmux_libc_FD_ISSET(&isset, in, read_fd_set);
if (isset) @{
  /* do something */
@}

mmux_libc_FD_ISSET(&isset, ou, writ_fd_set);
if (isset) @{
  /* do something */
@}

mmux_libc_FD_ISSET(&isset, in, exce_fd_set);
if (isset) @{
  /* do something */
@}
@end example


@deftypefun bool mmux_libc_FD_ZERO (mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_ZERO}.
@end deftypefun


@deftypefun bool mmux_libc_FD_SET (mmux_libc_fd_arg_t @var{fd}, mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_SET}.
@end deftypefun


@deftypefun bool mmux_libc_FD_CLR (mmux_libc_fd_arg_t @var{fd}, mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_CLR}.
@end deftypefun


@deftypefun bool mmux_libc_FD_ISSET (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_fd_set_t const * @var{fd_set_p})
@MmuxCInterface{FD_ISSET}.
@end deftypefun


@deftypefun bool mmux_libc_select (mmux_uint_t * @var{nfds_ready_p}, mmux_uint_t @var{maximum_nfds_to_check}, mmux_libc_fd_set_t * @var{read_fd_set_p}, mmux_libc_fd_set_t * @var{writ_fd_set_p}, mmux_libc_fd_set_t * @var{exce_fd_set_p}, mmux_libc_timeval_t * @var{timeout_p})
@MmuxCInterface{select}.

Each of the arguments @var{read_fd_set_p}, @var{writ_fd_set_p}, @var{exce_fd_set_p} can be @cnull{}
if we are not interested in selecting the corresponding events.

The argument @var{timeout_p} can be @cnull{} if we want to set a timeout of infinite time.

After a successful call: the variable referenced by @var{nfds_ready_p} is set to the number of file
descriptors that are ready for an action.

The argument @var{maximum_nfds_to_check} must represent the maximum number of file descriptors to
check for events: if we want to check up to file descriptor @samp{10}, we have to set
@var{maximum_nfds_to_check} to @samp{11}; it is usually just set to the constant
@code{MMUX_LIBC_FD_SETSIZE}.
@end deftypefun


@deftypefun bool mmux_libc_select_fd_for_reading (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_timeval_t * @var{timeout_p})
@deftypefunx bool mmux_libc_select_fd_for_writing (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_timeval_t * @var{timeout_p})
@deftypefunx bool mmux_libc_select_fd_for_exception (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_timeval_t * @var{timeout_p})
Like @cfunc{mmux_libc_select}, but select a single event for a single file descriptor; if the file
descriptor is ready the variable referenced by @var{result_p} is set to @ctrue{}, otherwise it is
set to @cfalse{}.

@example
mmux_libc_fd_t  fd;
bool            is_ready;

gimme_an_fd(&fd);

if (mmux_libc_select_fd_for_reading(&is_ready, fd, NULL)) @{
  /* error */
@}
if (is_ready) @{
  /* the fd is ready for reading */
@}
@end example
@end deftypefun

@c page
@node fds scatter-gather
@section Scatter--gather input and output


@menu
* fds scatter-gather types::    Scatter--gather type definitions.
* fds scatter-gather buffer::   The input/output buffer data structure.
* fds scatter-gather array::    The input/output array data structure.
* fds scatter-gather reading::  Reading with the input/output vector programming interface.
* fds scatter-gather writing::  Writing with the input/output vector programming interface.
@end menu

@c page
@node fds scatter-gather types
@subsection Scatter--gather type definitions


@deftp {Struct Typedef} mmux_libc_scatter_gather_flags_t
@deftpx {Parent Struct Typedef} mmux_sint_t
Data structure type representing a bitwise OR combination of flags to be used to configure a
scatter--gather operation with the functions @cfunc{mmux_libc_preadv2} and
@cfunc{mmux_libc_pwritev2}.

The flags are the @code{MMUX_LIBC_RWF_*} ones.
@end deftp


@deftypefun mmux_libc_scatter_gather_flags_t mmux_libc_scatter_gather_flags (mmux_standard_sint_t @var{flags})
Build and return a new instance of @objtype{mmux_libc_scatter_gather_flags_t}.
@end deftypefun

@c page
@node fds scatter-gather buffer
@subsection The input/output buffer data structure


Data to be read from or written to a file descriptor using the scatter--gather facilities must be
stored in multiple buffers; a single buffer of data is represented by the data structure
@objtype{mmux_libc_iovec_t}.  To instantiate and inspect such data structure we do:

@example
mmux_usize_t const      bufnum = 16;
mmux_usize_t const      buflen = 4096;
mmux_octet_t            bufptr[bufnum][buflen];
mmux_libc_iovec_t       iov[bufnum];

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(fd);
  if (mmux_libc_iovec_dump(fd, &(iov[0]), NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
this code dumps to @stdout{} a string representation of a single @objtype{mmux_libc_iovec_t}:

@example
struct iovec = 0x7ffe8c4309d0
struct iovec->iov_base = 0x7ffe8c4209c0
struct iovec->iov_len = 4096
@end example


@MmuxCStructOpaqueTypedef{iovec}


@MmuxSetterGetter{iovec, iov_base, mmux_pointer_t}
@MmuxSetterGetter{iovec, iov_len,  mmux_usize_t}
@MmuxStructDumper{iovec}

@c page
@node fds scatter-gather array
@subsection The input/output array data structure


Data to be read from or written to a file descriptor using the scatter--gather facilities must be
stored in multiple buffers; an array of these buffers is represented by the data structure
@objtype{mmux_libc_iovec_array_t}.  To instantiate and inspect such data structure we do:

@example
mmux_usize_t const      bufnum = 16;
mmux_usize_t const      buflen = 4096;
mmux_octet_t            bufptr[bufnum][buflen];
mmux_libc_iovec_t       iov[bufnum];
mmux_libc_iovec_array_t iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(fd);
  if (mmux_libc_iovec_array_dump(fd, &iova, NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
this code dumps to @stdout{} a string representation of a single @objtype{mmux_libc_iovec_array_t}:

@example
mmux_libc_iovec_array_t = 0x7ffcd9306550
mmux_libc_iovec_array_t->iova_base = 0x7ffcd9306560
mmux_libc_iovec_array_t->iova_len = 4
mmux_libc_iovec_array_t->iova_base[0] = 0x7ffcd9306560
mmux_libc_iovec_array_t->iova_base[0]->iov_base = 0x7ffcd9302540
mmux_libc_iovec_array_t->iova_base[0]->iov_len = 4096
mmux_libc_iovec_array_t->iova_base[1] = 0x7ffcd9306570
mmux_libc_iovec_array_t->iova_base[1]->iov_base = 0x7ffcd9303540
mmux_libc_iovec_array_t->iova_base[1]->iov_len = 4096
mmux_libc_iovec_array_t->iova_base[2] = 0x7ffcd9306580
mmux_libc_iovec_array_t->iova_base[2]->iov_base = 0x7ffcd9304540
mmux_libc_iovec_array_t->iova_base[2]->iov_len = 4096
mmux_libc_iovec_array_t->iova_base[3] = 0x7ffcd9306590
mmux_libc_iovec_array_t->iova_base[3]->iov_base = 0x7ffcd9305540
mmux_libc_iovec_array_t->iova_base[3]->iov_len = 4096
@end example


@deftp {Opaque Struct Typedef} mmux_libc_iovec_array_t
Data structure type representing an array of @objtype{mmux_libc_iovec_t} data structures.  It has
the following fields:

@table @code
@item mmux_libc_iovec_t * iova_base
Pointer to an array of @objtype{mmux_libc_iovec_t} data structures.

@item mmux_usize_t iova_len
Number of items in the array referenced by @code{iova_base}.
@end table
@end deftp


@MmuxSetterGetter{iovec_array, iova_base, mmux_libc_iovec_t *}
@MmuxSetterGetter{iovec_array, iova_len,  mmux_usize_t}
@MmuxStructDumperTwo{iovec_array, mmux_libc_iovec_array_t}

@c page
@node fds scatter-gather reading
@subsection Reading with the input/output vector programming interface


@deftypefun bool mmux_libc_readv (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p})
@MmuxCInterface{readv}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

/* Perform the reading. */
@{
  mmux_usize_t      nbytes_done;

  if (mmux_libc_readv(&nbytes_done, mfd, &iova)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_preadv (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset})
@MmuxCInterface{preadv}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

/* Perform the reading. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;

  if (mmux_libc_preadv(&nbytes_done, mfd, &iova, offset)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_preadv2 (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset}, mmux_libc_scatter_gather_flags_t @var{flags})
@MmuxCInterface{preadv2}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

/* Perform the reading. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;
  mmux_sint_t   flags  = MMUX_LIBC_RWF_HIPRI;

  if (mmux_libc_preadv2(&nbytes_done, mfd, &iova, offset, flags)) @{
    /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fds scatter-gather writing
@subsection Writing with the input/output vector programming interface


@deftypefun bool mmux_libc_writev (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p})
@MmuxCInterface{writev}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

fill_buffers(iova);

/* Perform the writing. */
@{
  mmux_usize_t      nbytes_done;

  if (mmux_libc_writev(&nbytes_done, mfd, &iova)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pwritev (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset})
@MmuxCInterface{pwritev}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

fill_buffers(iova);

/* Perform the writing. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;

  if (mmux_libc_pwritev(&nbytes_done, mfd, &iova, offset)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_pwritev2 (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset}, mmux_libc_scatter_gather_flags_t @var{flags})
@MmuxCInterface{pwritev2}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

fill_buffers(iova);

/* Perform the writing. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;
  mmux_sint_t   flags  = MMUX_LIBC_RWF_HIPRI;

  if (mmux_libc_pwritev2(&nbytes_done, mfd, &iova, offset, flags)) @{
    /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fds copying
@section Copying ranges from file to file


@deftypefun bool mmux_libc_copy_file_range (mmux_usize_t * @var{number_of_bytes_copied_p}, mmux_libc_file_descriptor_t @var{input_fd}, mmux_sint64_t * @var{input_position_p}, mmux_libc_file_descriptor_t @var{ouput_fd}, mmux_sint64_t * @var{ouput_position_p}, mmux_usize_t @var{number_of_bytes_to_copy}, mmux_sint_t @var{flags})
@MmuxCInterface{copy_file_range}.
@end deftypefun


Here is an example to understand the mechanics of the function call:

@example
mmux_libc_file_descriptor_t     src_fd;
mmux_libc_file_descriptor_t     dst_fd;

/* Open the source and destination files. */
@{
  mmux_libc_fs_ptn_t    src_ptn;
  mmux_libc_fs_ptn_t    dst_ptn;
  mmux_sint_t  flags = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
  mmux_libc_mode_t  mode  = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

  if (mmux_libc_make_file_system_pathname(src_ptn, "source.ext")) @{
    /* error */
  @}
  if (mmux_libc_open(&src_fd, src_ptn, flags, mode)) @{
    /* error */
  @}

  if (mmux_libc_make_file_system_pathname(dst_ptn, "destination.ext")) @{
    /* error */
  @}

  if (mmux_libc_open(&dst_fd, dst_ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Write data to the source file. */
@{
  mmux_usize_t        nbytes_done;
  //                            01234567890123456789012345678901234567890
  //                            0         1         2         3         4
  mmux_asciizcp_t     bufptr = "0123456789abcdefghilmnopqrstuvz0123456789";
  mmux_usize_t        buflen;

  mmux_libc_strlen(&buflen, bufptr);

  if (mmux_libc_write(&nbytes_done, src_fd, bufptr, buflen)) @{
    /* error */
  @}
  if (nbytes_done != buflen) @{
    /* it is an error for our purposes */
  @}
@}

/* Copy the alpha range of data "abcdefghilmnopqrstuvz" from the source
   file to the destination file. */
@{
  mmux_usize_t        nbytes_done;
  mmux_sint64_t       src_position = 10;
  mmux_sint64_t       dst_position = 0;
  mmux_usize_t        number_of_bytes_to_copy = 21;
  mmux_sint_t         flags = 0;

  if (mmux_libc_copy_file_range(&nbytes_done,
                                src_fd, &src_position,
                                dst_fd, &dst_position,
                                number_of_bytes_to_copy, flags)) @{
    /* error */
  @}
@}

if (mmux_libc_close(src_fd)) @{
  /* error */
@}
if (mmux_libc_close(dst_fd)) @{
  /* error */
@}
@end example

If we need to copy data between file descriptors, and we cannot use
@cfunc{mmux_libc_copy_file_range}, we can adapt the following code template:

@example
mmux_libc_fd_t                  infd, oufd;

static mmux_usize_t const       read_buflen = 1024;
mmux_octet_t                    read_bufptr[read_buflen];
mmux_usize_t                    nbytes_read;

gimme_an_input_fd(&infd);
gimme_an_ouput_fd(&oufd);

/* Loop reading while the number of bytes read is positive. */
do @{
  if (mmux_libc_read(&nbytes_read, infd, read_bufptr, read_buflen)) @{
    /* error */
  @}

  if (nbytes_read > 0) @{
    mmux_octet_t *  write_bufptr    = read_bufptr;
    mmux_usize_t    write_buflen    = nbytes_read;
    mmux_usize_t    nbytes_written  = 0;

    /* Loop writing until we have written all the bytes from the buffer. */
    do @{
      if (mmux_libc_write(&nbytes_written, oufd, write_bufptr, write_buflen)) @{
        /* error */
      @}

      if (nbytes_written < write_buflen) @{
        write_bufptr += nbytes_written;
        write_buflen -= nbytes_written;
      @}
    @} while (nbytes_written < write_buflen);
  @}
@} while (nbytes_read > 0);
@end example

@c page
@node fds flock
@section File locks


Data structures of type @objtype{mmux_libc_flock_t} are used to describe a file lock in some calls
to @cfunc{mmux_libc_fcntl}.  To declare and inspect such data structures we do:

@example
mmux_libc_flock_t     flo;
mmux_libc_pid_t       pid;

mmux_libc_make_pid_zero(&pid); /* should not fail */

mmux_libc_l_type_set   (&flo, MMUX_LIBC_F_RDLCK);
mmux_libc_l_whence_set (&flo, MMUX_LIBC_SEEK_SET);
mmux_libc_l_start_set  (&flo, mmux_off_literal(11));
mmux_libc_l_len_set    (&flo, mmux_off_literal(33));
mmux_libc_l_pid_set    (&flo, pid);

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(fd);
  if (mmux_libc_flock_dump(fd, &flo, NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
which will print:

@example
struct flock = "0x7ffcf5d55170"
struct flock.l_type = "0" (F_RDLCK)
struct flock.l_whence = "0" (SEEK_SET)
struct flock.l_start = "11"
struct flock.l_len = "33"
struct flock.l_pid = "0"
@end example


@MmuxCStructOpaqueTypedef{flock}
@MmuxSetterGetter{flock, l_type,   mmux_libc_file_lock_type_t}
@MmuxSetterGetter{flock, l_whence, mmux_libc_seek_whence_t}
@MmuxSetterGetter{flock, l_start,  mmux_off_t}
@MmuxSetterGetter{flock, l_len,    mmux_off_t}
@MmuxSetterGetter{flock, l_pid,    mmux_libc_pid_t}
@MmuxStructDumper{flock}

@deftypefun bool mmux_libc_flag_to_symbol_struct_flock_l_type (mmux_asciizcpp_t @var{str_p}, mmux_libc_file_lock_type_t @var{flag})
Identify @var{flag} as a value for the field @code{l_type} of @objtype{mmux_libc_flock_t}; store in
the variable referenced by @var{str_p} a pointer to a statically allocated @MmuxAsciiZ{} string
representing the name of the value.
@end deftypefun

@c page
@node fds fun control
@section File descriptors functionality control


@deftypefun bool mmux_libc_fcntl (mmux_libc_fd_arg_t @var{fd}, mmux_sint_t @var{command}, mmux_pointer_t @var{parameter_p})
@MmuxCInterface{fcntl}.  Arguments:

@table @var
@item fd
A file descriptor.

@item command
A constant representing a command for @cfunc{fcntl}.

@item parameter_p
Pointer to a variable representing a parameter that can be input or output depending on the
@var{command}.
@end table
@end deftypefun


@deftypefun bool mmux_libc_fcntl_command_flag_to_symbol (mmux_asciizcp_t* @var{str_p}, mmux_sint_t @var{command})
Identify @var{command} as a command argument for @cfunc{mmux_libc_fcntl}; store in the variable
referenced by @var{str_p} a pointer to a statically allocated @MmuxAsciiZ{} string representing a string
representation of the @var{command}.
@end deftypefun

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_DUPFD
Duplicate a file descriptor; @var{parameter_p} must reference a variable of type
@objtype{mmux_libc_file_descriptor_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETFD
Get file descriptor flags, like @samp{MMUX_LIBC_FD_CLOEXEC}; @var{parameter_p} must reference a variable
of type @objtype{mmux_sint_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETFD
Set file descriptor flags, like @samp{MMUX_LIBC_FD_CLOEXEC}; @var{parameter_p} must reference a variable
of type @objtype{mmux_sint_t} holding a bitwise OR combination of flags.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETFL
Get open file descriptor flags, like @samp{O_RDWR}; @var{parameter_p} must reference a variable of
type @objtype{mmux_sint_t}.

To set blocking mode for a file descriptor we do:

@example
mmux_libc_fd_t  fd;
mmux_sint_t     parameter;

/* Acquire current file descriptor flags. */
if (mmux_libc_fcntl(in, MMUX_LIBC_F_GETFL, &parameter)) @{
  /* error */
@}

/* Null the non-block flag. */
parameter &= (~ MMUX_LIBC_O_NONBLOCK);

/* Set the new flags. */
if (mmux_libc_fcntl(in, MMUX_LIBC_F_SETFL, &parameter)) @{
  /* error */
@}
@end example
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETFL
Set open file descriptor flags, like @samp{O_APPEND}; @var{parameter_p} must reference a variable of
type @objtype{mmux_sint_t} holding a bitwise OR combination of flags.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETLK
Get a @MmuxCStruct{flock} describing a lock that blocks a requested lock; @var{parameter_p} must
reference a value of type @objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETLK
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETLKW
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_GETLK
Get a @MmuxCStruct{flock} describing a lock that blocks a requested lock; @var{parameter_p} must
reference a value of type @objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_SETLK
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_SETLKW
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETOWN
Get the process or group id that receives the signal @samp{SIGIO}; @var{parameter_p} must reference
a variable of type @objtype{mmux_libc_pid_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETOWN
Set the process or group id that receives the signal @samp{SIGIO}; @var{parameter_p} must reference
a variable of type @objtype{mmux_libc_pid_t}.
@end defvr

@c page
@node fds io control
@section File descriptors input/output control


@deftypefun bool mmux_libc_ioctl (mmux_libc_fd_arg_t @var{fd}, mmux_sint_t @var{command}, mmux_pointer_t @var{parameter_p})
@MmuxCInterface{ioctl}.  Arguments:

@table @var
@item fd
A file descriptor.

@item command
A constant representing a command for @cfunc{ioctl}.

@item parameter_p
Pointer to a variable representing a parameter that can be input or output depending on the
@var{command}.
@end table
@end deftypefun

@c ------------------------------------------------------------------------

@defvr {Iontl Command} MMUX_LIBC_SIOCATMARK
Detect if the data received through a socket has reached the mark; @var{parameter_p} must reference
a variable of type @objtype{mmux_sint_t}.
@end defvr

@c page
@node fds memfd
@section Memory--mapped file descriptors


@cindex Memory--mapped file descriptors
@cindex Memfds


Memory--mapped file descriptors (memfds for short) are constructed by @cfunc{memfd_create},
@MmuxCFuncpage{memfd_create}.  The device underlying a memfd exists only in memory, but we can apply
to it almost all the functions acting upon file descriptors.

@menu
* fds memfd intro::             Introduction to memfds and usage examples.
* fds memfd fds::               Memory-mapped file descriptors types.
* fds memfd makers::            Constructing memfds.
* fds memfd inspect::           Inspecting memfds.
* fds memfd reading::           Special reading operations upon memfds.
* fds memfd writing::           Special writing operations upon memfds.
* fds memfd copying::           Special copying operations upon memfds.
@end menu

@c page
@node fds memfd intro
@subsection Introduction to memfds and usage examples


To use a memory--mapped file descriptor, we do:

@example
mmux_libc_memfd_t  mfd;

if (mmux_libc_make_memfd(&mfd)) @{
  /* error */
@}
@{
  /* Write something. */
  if (mmux_libc_dprintf(mfd, "The value is %d.\n", 123)) @{
    /* error */
  @}

  @{
    auto  rep = mmux_double_literal(1.2);
    auto  imp = mmux_double_literal(3.4);
    auto  Z   = mmux_complexd_make_rectangular(rep, imp);

    mmux_libc_dprintf_complexd(mfd, Z);
  @}

  /* Copy the data to stdout. */
  if (mmux_libc_memfd_copyou(mfd)) @{
    /* error */
  @}
@}
if (mmux_libc_close(mfd)) @{
  /* error */
@}
@end example

@noindent
we can apply to a memfd almost all the functions that act upon ordinary file descriptors.

We need to remember to appropriately shift the input/output position of the underlying device with
@cfunc{mmux_libc_lseek}.  If we need to shift the position, do something, and then restore the
position to its original value, we do:

@example
mmux_libc_memfd_t  mfd;

 /* new position with respect to MMUX_LIBC_SEEK_SET */
auto               position = mmux_off_literal(0);

if (mmux_libc_make_memfd(&mfd)) @{
  /* error */
@}

/* Save the current position then seek to the beginning. */
if (mmux_libc_lseek(mfd, &position, MMUX_LIBC_SEEK_SET)) @{
  /* error */
@}

/* do something with mfd */

/* Restore the original position. */
if (mmux_libc_lseek(mfd, &position, MMUX_LIBC_SEEK_SET)) @{
  /* error */
@}
@end example

@noindent
also we can use @cfunc{mmux_libc_pread} and @cfunc{mmux_libc_pwrite} to read from and write to a
position from the beginning of the underlying device.

@c page
@node fds memfd fds
@subsection Memory--mapped file descriptors types


@deftp {Struct Type} mmux_libc_memory_file_descriptor_t
@deftpx {Parent Struct Type} mmux_libc_file_descriptor_t
Data structure type representing memory--mapped file descriptors.
@end deftp


@deftp {Pointer Type} mmux_libc_memfd_t
@deftpx {Pointer Type} mmux_libc_memfd_arg_t
Pointer types defined as:

@example
typedef mmux_libc_memory_file_descriptor_t        mmux_libc_memfd_t[1];
typedef mmux_libc_memory_file_descriptor_t const  mmux_libc_memfd_arg_t[1];
@end example
@end deftp

@c page
@node fds memfd makers
@subsection Constructing memfds


The core constructor for a memfd is @cfunc{mmux_libc_make_memfd}; we should always pair a call to it
with a call to @cfunc{mmux_libc_close}, which acts as destructor:

@example
mmux_libc_fd_t  mfd;

if (mmux_libc_make_memfd(&mfd)) @{
  /* error */
@}

@{
  /* do something with "mfd" */
@}

if (mmux_libc_close(mfd)) @{
  /* error */
@}
@end example


@deftypefun bool mmux_libc_make_memfd (mmux_libc_file_descriptor_t * @var{mfd_p})
Create a new file descriptor whose underlying device is mapped into ordinary memory; store the
resulting file descriptor in the variable referenced by @var{mfd_p}.
@end deftypefun

@c page
@node fds memfd inspect
@subsection Inspecting memfds


To acquire the number of bytes in the device underlying a memfd, we do:

@example
mmux_libc_fd_t  mfd;
mmux_usize_t    buflen;

if (mmux_libc_memfd_length(&buflen, mfd)) @{
  /* error */
@}
@end example

@noindent
this operation should not fail.

If the data in the device is to be interpreted as an @MmuxAscii{} string, we can allocate a buffer
to contain it as @MmuxAsciiZ{} string as follows:

@example
mmux_libc_fd_t  mfd;
mmux_usize_t    buflen;

if (mmux_libc_memfd_length(&buflen, mfd)) @{
  /* error */
@}

@{
  char  bufptr[1+buflen];

  bufptr[buflen] = '\0';
  ...
@}
@end example


@deftypefun bool mmux_libc_memfd_length (mmux_usize_t * @var{len_p}, mmux_libc_file_descriptor_t @var{mfd})
Store in the variable referenced by @var{len_p} the number of bytes in the device underlying
@var{mfd}.
@end deftypefun

@c page
@node fds memfd reading
@subsection Special reading operations upon memfds


Applying the basic reading operation using @cfunc{mmux_libc_read} to a memfd, looks like this:

@example
mmux_usize_t    buflen = 4094;
mmux_octet_t *  bufptr[buflen];

mmux_libc_fd_t  mfd;
mmux_usize_t    nbytes_done;

gimme_a_memfd(&mfd);

if (mmux_libc_read(&nbytes_done, mfd, bufptr, buflen)) @{
  /* error */
@}
@end example

@noindent
this is quite verbose, and the read operation should not fail if the destination buffer is wide
enough.  So the following functions are implemented.

If the data in the device underlying the memfd is to be considered as an @MmuxAscii{} string, we can
copy it into an external buffer as follows:

@example
mmux_usize_t    buflen;

if (mmux_libc_memfd_length(&buflen, mfd)) @{
  /* error */
@} else @{
  char  bufptr[1+buflen.value];

  bufptr[buflen.value] = '\0';
  if (mmux_libc_memfd_read_buffer(mfd, bufptr, buflen)) @{
    /* error */
  @}
  ...
@}
@end example

@noindent
we take advantage of the fact that we know the data size.


@deftypefun bool mmux_libc_memfd_read_buffer (mmux_libc_fd_t @var{mfd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{maximum_buflen})
Wrapper for @cfunc{mmux_libc_read}.  Copy up to @var{maximum_buflen} bytes from the device
underlying @var{mfd} to the buffer referenced by @var{bufptr}.
@end deftypefun

@c page
@node fds memfd writing
@subsection Special writing operations upon memfds


Applying the basic writing operation using @cfunc{mmux_libc_write} to a memfd, looks like this:

@example
mmux_usize_t    buflen = 4094;
mmux_octet_t *  bufptr[buflen];

mmux_libc_fd_t  mfd;
mmux_usize_t    nbytes_done;

fill_buffer(bufptr, buflen);
gimme_a_memfd(&mfd);

if (mmux_libc_write(&nbytes_done, mfd, bufptr, buflen)) @{
  /* error */
@}
@end example

@noindent
this is quite verbose, but we need to remember that the write operation could fail if there is not
enough memory available to enlarge the underlying device.  Anyway, the following functions are
implemented.


@deftypefun bool mmux_libc_memfd_write_buffer (mmux_libc_file_descriptor_t @var{mfd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
Write @var{buflen} bytes from the buffer @var{bufptr} into the device underlying @var{mfd}, at the
current position.  The return value is @ctrue{} if less than @var{buflen} bytes are written to
@var{mfd}.
@end deftypefun


@deftypefun bool mmux_libc_memfd_write_asciiz (mmux_libc_file_descriptor_t @var{mfd}, mmux_asciizcp_t @var{bufptr})
Write the @MmuxAsciiZ{} string referenced by @var{bufptr} into the device underlying @var{mfd}, at the
current position.  The return value is @ctrue{} if less than the whole string is written to
@var{mfd}.
@end deftypefun


@anchor{mmux_libc_memfd_strerror}
@deftypefun bool mmux_libc_memfd_strerror (mmux_libc_file_descriptor_t @var{mfd}, mmux_sint_t @var{errnum})
Write to @var{mfd}, at the current position for the underlying device, the error string associated
to @var{errnum} and retrieved using @cfunc{mmux_libc_strerror}.  The return value is @ctrue{} if
less than the whole error message is written to @var{mfd}.
@end deftypefun

@c page
@node fds memfd copying
@subsection Special copying operations upon memfds


@deftypefun bool mmux_libc_memfd_copy (mmux_libc_file_descriptor_t @var{oufd}, mmux_libc_file_descriptor_t @var{mfd})
Copy all the data in the device underlying @var{mfd} to the file descriptor @var{oufd}.

This function ignores the current device position, writing all the data from the beginning to the
end of the underlying device.  When successful: the current device position is restored to the
original value, so it is left unchanged.  If an error occurs: the underlying device position is
undefined.

@strong{NOTE} It appears the memfds cannot be used with @cfunc{mmux_libc_copy_file_range}.
@end deftypefun


@deftypefun bool mmux_libc_memfd_copyou (mmux_libc_file_descriptor_t @var{mfd})
@deftypefunx bool mmux_libc_memfd_copyer (mmux_libc_file_descriptor_t @var{mfd})
Wrappers for @cfunc{mmux_libc_memfd_copy} that write the underlying device contents to, respectively:
@stdout{}, @stderr{}.
@end deftypefun

@c page
@node fds predicates
@section File predicates with file descriptors


@deftypefun bool mmux_libc_file_descriptor_is_regular (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
regular file; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_regular;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_libc_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_regular(&the_fd_is_regular, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_symlink (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
symbolic link; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_symlink;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_libc_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_symlink(&the_fd_is_symlink, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_directory (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
directory; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_directory;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_libc_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_directory(&the_fd_is_directory, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_character_special (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
character special device; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_character_special;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_libc_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_character_special(&the_fd_is_character_special, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_block_special (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a block
special device; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_block_special;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_libc_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_block_special(&the_fd_is_block_special, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_fifo (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a FIFO;
otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_fifo;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_libc_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_fifo(&the_fd_is_fifo, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_socket (bool * @var{result_p}, mmux_libc_fd_arg_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
socket; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_socket;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_libc_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_socket(&the_fd_is_socket, ptn)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds attributes
@section Inspecting file attributes through file descriptors


The functions documented in this section retrieve the value of some fields from
@objtype{mmux_libc_stat_t} objects embedding the call to the standard @cfunc{stat} function and its
variants; true control about the resulting values is possible only by explicitly selecting which
@cfunc{stat} variant to call and which arguments to use in the function invocation.  But the
following functions are simpler and sometimes they are enough.


@deftypefun bool mmux_libc_file_descriptor_file_size_ref (mmux_usize_t * @var{result_p}, mmux_libc_fd_arg_t @var{fd})
Invoke @cfunc{mmux_libc_fstat} and retrieve the @code{st_size} field value of the resulting
@objtype{mmux_libc_stat_t}.  Store such field value in the variable referenced by @var{result_p},
casting the @objtype{mmux_off_t} value to @objtype{mmux_usize_t}.

@example
mmux_libc_fs_ptn_t        ptn;
mmux_libc_file_descriptor_t             dirfd;
mmux_libc_file_descriptor_t             fd;
mmux_sint_t                             flags = MMUX_LIBC_O_RDWR;
mmux_libc_mode_t                             mode  = 0;
mmux_usize_t                            size;

mmux_libc_make_file_system_pathname(ptn, "/path/to/file.ext");
mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_openat(&fd, dirfd, ptn, flags, mode) @{
  /* error */
@} else if (mmux_libc_file_descriptor_file_size_ref(&size, fd)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs
@chapter File system


@menu
* fs pathnames::                File system pathnames type definition.
* fs directories::              File system directories.
* fs links::                    Hard and symbolic links.
* fs deleting::                 Deleting links.
* fs renaming::                 Renaming links.
* fs ownership::                File ownership.
* fs permissions::              File access permissions.
* fs attributes::               File attributes.
* fs truncating::               Truncating files.
* fs times::                    File system times.
@end menu

@c page
@node fs pathnames
@section File system pathnames type definition


@menu
* fs pathnames intro::          Introduction to file system pathnames.
* fs pathnames pathnames::      File system full pathnames.
* fs pathnames extensions::     Extensions of file system pathnames.
* fs pathnames segments::       Extensions of file system pathnames.
* fs pathnames examples::       Usage examples for file system pathnames.
@end menu

@c page
@node fs pathnames intro
@subsection Introduction to file system pathnames


A @dfn{file system pathname} is an array of octets terminated by a zero octet, to be interpreted as
@MmuxAsciiZ{} string; file system pathnames are naturally interpreted as representing a tree
superimposed to the union of file systems.  By convention: we consider the bytes in a file system
pathname as unsigned characters, so we refer to them as @dfn{octets}; even though their type,
according to the Unix standards, is @code{char} which does not specify if they are signed or
unsigned.  In this package a file system pathname is represented by the object type
@objtype{mmux_libc_file_system_pathname_t}.

In this package: the empty string is @strong{not} a valid file system pathname representation; in
other words: an array of one zero octet is @strong{not} a valid file system pathname representation.

For security and efficiency reasons: in certain situations, the constructors of the
@objtype{mmux_libc_file_system_pathname_t} object type enforce the arbitrary pathname length limit
of @math{4095} octets plus the terminating zero octet; in total, a file system pathname cannot be
loger than @math{4096} octets.  If a pathname is too long to be represented: an error is raised with
@cerrno{} code @samp{MMUX_LIBC_ENAMETOOLONG}.

Most pathnames are composed of @dfn{segments} separated by the slash character @file{/}, examples:

@example
/path/to/file.ext
/path/to/directory/
./path/to/file.ext
/path/to/.dotfile
file.ext
@end example

@noindent
the segments of @file{/path/to/file.ext} are the three strings:

@example
path
to
file.ext
@end example

@noindent
the ``first segment'' is the leftmost segment @samp{path}; the ``last segment'' is the rightmost
segment @samp{file.ext}.  In this package a file system pathname segment is represented by the
object type @objtype{mmux_libc_file_system_pathname_segment_t}.

By convention, in the rightmost segment of a pathname: if there is a trailing sequence of octets
beginning with a dot character, such sequence is called @dfn{extension}; the extension of
@samp{file.ext} is @samp{.ext} and it includes the dot; the extension is defined only if it follows
other octets, so @file{.dotfile} has empty extension.  In this package a file system pathname
extension is represented by the object type @objtype{mmux_libc_file_system_pathname_extension_t}.

Some file system pathnames are ``special directories'':

@table @file
@item /
the root directory, the top of the tree for file system pathnames; it has no segments; it has no
extension;

@item .
the current directory; it has the single segment @samp{.}; it has no extension;

@item ..
the uplevel directory from the current directory; it has the single segment @samp{..}; it has no
extension.
@end table

When a file system pathname is @strong{not} a special directory:

@itemize
@item
if the file system pathname ends with a slash character: by convention it represents a directory;

@item
if the file system pathname does @strong{not} end with a slash character: it can represent both a
directory or a file.
@end itemize

When a file system pathname begins with a slash character: it is an @dfn{absolute} pathname.
Otherwise it is a @dfn{relative pathname} to be interpreted as child of the current working
directory.

The syntax of file system pathnames allows some freedom, which pushes us to ``normalise'' a pathname
to simplify it and to make it more amenable to processing; examples:

@table @code
@item ///... -> /
a sequence of slash characters can be normalised to a single slash;

@item /./ -> /
a sequence slash, dot, slash can be normalised to a slash;

@item segment/..
a sequence segment, slash, double dot can be normalised to the empty string;

@item ./segment -> segment
a sequence dot, slash, segment can be normalised to the segment.
@end table

@c page
@node fs pathnames pathnames
@subsection File system full pathnames


@menu
* fs pathnames pathnames types::          File system pathname types.
* fs pathnames pathnames constructors::   Building file system pathnames.
* fs pathnames pathnames inspection::     Inspecting file system pathnames.
* fs pathnames pathnames comparison::     Comparing file system pathnames.
* fs pathnames pathnames predicates::     Predicates on file system pathnames.
* fs pathnames pathnames components::     Components of file system pathnames.
* fs pathnames pathnames normalisation::  Normalising file system pathnames.
* fs pathnames pathnames operations::     Operations on file system pathnames.
@end menu

@c page
@node fs pathnames pathnames types
@subsubsection File system pathname types


For examples of how to build a file system pathname object, @ref{fs pathnames examples, Usage
examples for file system pathnames}.


@deftp {Struct Typedef} mmux_libc_file_system_pathname_t
@deftpx {Struct Pointer Type} mmux_libc_fs_ptn_t
@deftpx {Struct Pointer Type} mmux_libc_fs_ptn_arg_t
Structure data type representing a file system pathname as a non--@cnull{} pointer to non--empty
@MmuxAsciiZ{} string.

The pointer types are defined as follows:

@example
typedef struct mmux_libc_file_system_pathname_t          mmux_libc_fs_ptn_t[1];
typedef struct mmux_libc_file_system_pathname_t const *  mmux_libc_fs_ptn_arg_t;
@end example
@end deftp


@deftp {Struct Typedef} mmux_libc_file_system_pathname_factory_t
@deftpx {Struct Pointer Type} mmux_libc_fs_ptn_factory_t
@deftpx {Struct Pointer Type} mmux_libc_fs_ptn_factory_arg_t
Structure data type representing a factory for file system pathnames.  It allows the selection of a
memory allocation strategy to contain file system pathname strings.

The pointer types are defined as follows:

@example
typedef struct mmux_libc_file_system_pathname_factory_t          mmux_libc_fs_ptn_factory_t[1];
typedef struct mmux_libc_file_system_pathname_factory_t const *  mmux_libc_fs_ptn_factory_arg_t;
@end example
@end deftp

@c ------------------------------------------------------------------------

@deftp {Struct Typedef} mmux_libc_file_system_pathname_factory_copying_t
@deftpx {Parent Struct Typedef} mmux_libc_file_system_pathname_factory_t
@deftpx {Struct Pointer Type} mmux_libc_fs_ptn_factory_copying_t
@deftpx {Struct Pointer Type} mmux_libc_fs_ptn_factory_copying_arg_t
Structure data type representing a factory for file system pathnames.  It is like its parent type,
but @strong{always} allocates new memory to contain the file system pathname @MmuxAsciiZ{} string.

The pointer types defined as follows:

@example
typedef struct mmux_libc_file_system_pathname_factory_copying_t          mmux_libc_fs_ptn_factory_copying_t[1];
typedef struct mmux_libc_file_system_pathname_factory_copying_t const *  mmux_libc_fs_ptn_factory_copying_arg_t;
@end example
@end deftp

@c page
@node fs pathnames pathnames constructors
@subsubsection Building file system pathnames


For examples of how to build a file system pathname object, @ref{fs pathnames examples, Usage
examples for file system pathnames}.


@deftypefun bool mmux_libc_file_system_pathname_factory_static (mmux_libc_fs_ptn_factory_t @var{fs_ptn_factory})
Store in the variable referenced by @var{fs_ptn_factory} a reference to the prebuilt ``static'' file
system factory.

When building file system pathnames with this factory: the memory containing the @MmuxAsciiZ{}
string must have been already allocated and initialised, and the new file system pathname object
will reference it; this factory uses the ``fake'' memory allocator, @ref{memory allocators fake,
Fake memory allocator}.  We can use this factory to reference a hard--coded string.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_factory_dynamic (mmux_libc_fs_ptn_factory_copying_t @var{fs_ptn_factory})
Store in the variable referenced by @var{fs_ptn_factory} a reference to the prebuilt ``dynamic''
file system factory.

When building file system pathnames with this factory: the memory containing the @MmuxAsciiZ{}
string is newly allocated using the default memory allocator, @ref{memory allocators default,
Default memory allocator}.  We can use this factory when we need to build a file system pathname by
creating a copy of an existing string.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_factory_swallow (mmux_libc_fs_ptn_factory_t @var{fs_ptn_factory})
Store in the variable referenced by @var{fs_ptn_factory} a reference to the prebuilt ``swallow''
file system factory.

When building file system pathnames with this factory: the memory containing the @MmuxAsciiZ{}
string must have been already allocated using the default memory allocator, and the new file system
pathname object will reference it; this factory uses the default memory allocator, @ref{memory
allocators default, Default memory allocator}.
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_arg_t @var{fs_ptn_factory}, mmux_asciizcp_t @var{ptn_asciiz})
Make a new file system pathname value, using the given @var{fs_ptn_factory}, using the @MmuxAsciiZ{}
string referenced by @var{ptn_asciiz}.  The @MmuxAsciiZ{} string @var{ptn_asciiz} is validated:

@enumerate
@item
@var{ptn_asciiz} itself must not be @cnull{};

@item
the string length must not be zero: the first character must not be null.
@end enumerate
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname2 (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_copying_arg_t @var{fs_ptn_factory}, mmux_asciicp_t @var{ptn_ascii}, mmux_usize_t @var{ptn_len_excluding_nul})
Make a new file system pathname value, using the given @var{fs_ptn_factory}, using the @MmuxAscii{}
string referenced by @var{ptn_ascii}, which must have length @var{ptn_len_excluding_nul} which
itself cannot be zero.

This constructor always allocates new memory and makes a copy of the given @var{ptn_ascii} string,
so the given @var{fs_ptn_factory} must support this operation, otherwise @ctrue{} is returned and
@cerrno{} set to @code{MMUX_LIBC_ENOTSUP}.
@end deftypefun


@deftypefun bool mmux_libc_unmake_file_system_pathname (mmux_libc_fs_ptn_t @var{fs_ptn})
Finalise the file system pathname object referenced by @var{fs_ptn}, appropriately releasing all the
referenced asynchronous resources.
@end deftypefun

@ignore
This is commented out because it is an experimental feature, not correctly implemented.  When using
GCC's extension @code{__cleanup__}: what happens when an error occurs building the pathname?

@deftypefun bool mmux_libc_file_system_pathname_free_variable (mmux_libc_fs_ptn_t * @var{pathname_p})
Release the memory holding the pathname as @MmuxAsciiZ{} string using @cfunc{mmux_libc_free}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn
  __attribute__((__cleanup__(mmux_libc_file_system_pathname_free_variable)));

@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}
@end example
@end deftypefun
@end ignore

@c page
@node fs pathnames pathnames inspection
@subsubsection Inspecting file system pathnames


@deftypefun bool mmux_libc_file_system_pathname_ptr_ref (mmux_asciizcp_t * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
Store in the variable referenced by @var{result_p} a pointer to the first octet in the array
representing the file system pathname.

@example
mmux_libc_fs_ptn_t  fs_ptn;
mmux_asciiz_t       ptn_ptr;

initialise_fs_ptn_in_some_way(fs_ptn);
mmux_libc_file_system_pathname_ptr_ref(&ptr, ptn);
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_len_ref (mmux_usize_t * @var{fs_ptn_len_result_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
Store in the variable referenced by @var{result_p} the number of octets in the pathname @var{fs_ptn}
@strong{excluding} the terminating nul.  A call to this function should never fail, so we can avoid
checking its return value.

@example
mmux_libc_fs_ptn_t  fs_ptn;
mmux_usize_t        len_excluding_nul;

initialise_fs_ptn_in_some_way(fs_ptn);
mmux_libc_file_system_pathname_len_ref(&len_excluding_nul, fs_ptn);
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_len_including_nul_ref (mmux_usize_t * @var{fs_ptn_len_including_nul_result_p}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Store in the variable referenced by @var{result_p} the number of octets in the pathname @var{fs_ptn}
@strong{including} the terminating nul.  A call to this function should never fail, so we can avoid
checking its return value.

@example
mmux_libc_fs_ptn_t  fs_ptn;
mmux_usize_t        len_including_nul;

initialise_fs_ptn_in_some_way(fs_ptn);
mmux_libc_file_system_pathname_len_including_nul_ref(&len_including_nul, fs_ptn);
@end example
@end deftypefun

@c page
@node fs pathnames pathnames comparison
@subsubsection Comparing file system pathnames


@deftypefun bool mmux_libc_file_system_pathname_compare (mmux_ternary_comparison_result_t * @var{cmpnum_result_p}, mmux_libc_fs_ptn_arg_t @vari{ptn}, mmux_libc_fs_ptn_arg_t @varii{ptn})
Compare the @MmuxAsciiZ{} strings of two file system pathnames using @cfunc{mmux_libc_strcmp}, store
the result in the variable referenced by @var{cmpnum_result_p}.

@example
mmux_asciizcp_t     ptn_asciiz_1 = "AAA";
mmux_asciizcp_t     ptn_asciiz_2 = "BBB";
mmux_libc_fs_ptn_t  fs_ptn1, fs_ptn2;

/* Build the file system pathnames. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn1, fs_ptn_factory, ptn_asciiz_1)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname(fs_ptn2, fs_ptn_factory, ptn_asciiz_2)) @{
    /* error */
  @}
@}

/* Compare the file system pathnames. */
@{
  mmux_ternary_comparison_result_t  cmpnum;

  if (mmux_libc_file_system_pathname_compare(&cmpnum, ptn1, ptn2)) @{
    /* error */
  @}
  if (mmux_ternary_comparison_result_is_equal(cmpnum)) @{
    ...
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn1);
  mmux_libc_unmake_file_system_pathname(fs_ptn2);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_equal (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @vari{fs_ptn}, mmux_libc_fs_ptn_arg_t @varii{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the two given pathnames are equal
when compared as @MmuxAsciiZ{} strings; otherwise store @cfalse{}.

@example
mmux_asciizcp_t     ptn_asciiz_1 = "AAA";
mmux_asciizcp_t     ptn_asciiz_2 = "BBB";
mmux_libc_fs_ptn_t  fs_ptn1, fs_ptn2;

/* Build the file system pathnames. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn1, fs_ptn_factory, ptn_asciiz_1)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname(fs_ptn2, fs_ptn_factory, ptn_asciiz_2)) @{
    /* error */
  @}
@}

/* Compare the file system pathnames. */
@{
  bool  result;

  if (mmux_libc_file_system_pathname_equal(&result, ptn1, ptn2)) @{
    /* error */
  @}
  if (result) @{
    ...
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn1);
  mmux_libc_unmake_file_system_pathname(fs_ptn2);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_not_equal (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @vari{fs_ptn}, mmux_libc_fs_ptn_arg_t @varii{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the two given pathnames are different
when compared as @MmuxAsciiZ{} strings; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_less (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @vari{fs_ptn}, mmux_libc_fs_ptn_arg_t @varii{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @samp{@vari{fs_ptn} < @varii{fs_ptn}} when
compared as @MmuxAsciiZ{} strings; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_greater (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @vari{fs_ptn}, mmux_libc_fs_ptn_arg_t @varii{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @samp{@vari{fs_ptn} > @varii{fs_ptn}} when
compared as @MmuxAsciiZ{} strings; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_less_equal (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @vari{fs_ptn}, mmux_libc_fs_ptn_arg_t @varii{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @samp{@vari{fs_ptn} <= @varii{fs_ptn}} when
compared as @MmuxAsciiZ{} strings; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_greater_equal (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @vari{fs_ptn}, mmux_libc_fs_ptn_arg_t @varii{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @samp{@vari{fs_ptn} >= @varii{fs_ptn}} when
compared as @MmuxAsciiZ{} strings; otherwise store @cfalse{}.
@end deftypefun

@c page
@node fs pathnames pathnames predicates
@subsubsection Predicates on file system pathnames


The following predicates work best when applied to file system pathnames that have been previously
normalised, either with @cfunc{mmux_libc_make_file_system_pathname_normalised} or
@cfunc{mmux_libc_realpath} and similar functions.


@deftypefun bool mmux_libc_file_system_pathname_is_standalone_dot (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{fs_ptn} is a standalone dot
(@file{.} or @file{/path/to/.}); otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_standalone_double_dot (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{fs_ptn} is a standalone double dot
(@file{..} or @file{/path/to/..}); otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_standalone_slash (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{fs_ptn} is a standalone slash
(@file{/}); otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_special_directory (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{fs_ptn} is on among: a standalone
slash, a standalone dot, a standalone double dot; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_absolute (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the first octet in @var{fs_ptn}
@strong{does} represent an @MmuxAscii{} slash @samp{/}; otherwise store @cfalse{}.  If the first
octet represents an @MmuxAscii{} slash: the process of finding the file corresponding to @var{fs_ptn} on
the file system, @strong{does not} depend on the current working directory.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_relative (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the first octet in @var{fs_ptn}
@strong{does not} represent an @MmuxAscii{} slash @samp{/}; otherwise store @cfalse{}.  If the first
octet does not represent an @MmuxAscii{} slash: the process of finding the file corresponding to
@var{fs_ptn} on the file system, @strong{does} depend on the current working directory.
@end deftypefun

@c page
@node fs pathnames pathnames components
@subsubsection Components of file system pathnames


All the following component--extracting functions have the same semantics; for example: to extract
the rootname of a file system pathname, we do:

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn, fs_ptn_root;

/* Build the source file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Build the root file system pathname. */
@{
  mmux_libc_fs_ptn_factory_copying_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname_rootname(fs_ptn_root, fs_ptn_factory, fs_ptn)) @{
    /* error */
  @}
@}

@{
  /* Do something. */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
  mmux_libc_unmake_file_system_pathname(fs_ptn_root);
@}
@end example

Remember that we can print a file system pathname to a file descriptor using
@cfunc{mmux_libc_dprintf_fs_ptn}, @ref{mmux_libc_dprintf_fs_ptn} for details.


@deftypefun bool mmux_libc_make_file_system_pathname_rootname (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_copying_arg_t @var{fs_ptn_factory}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Build a new file system pathname representing the rootname of @var{fs_ptn}; store in the variable
referenced by @var{fs_ptn_result} the new pathname object.  The @dfn{rootname} of a file system
pathname is the whole pathname with the extension stripped:

@example
/path/to/file.ext       @result{} /path/to/file
/path/to/file           @result{} /path/to/file
/path/to/dir/           @result{} /path/to/dir
file.ext                @result{} file
.fvwmrc                 @result{} .fvwmrc
.                       @error{} invalid argument
..                      @error{} invalid argument
/                       @error{} invalid argument
@end example

@noindent
if @var{fs_ptn} is the root directory @file{/}, a standalone dot @file{.} or @file{/path/to/.}, a
standalone double dot @file{..} or @file{/path/to/..}, then the function call fails: @code{errno} is
set to @code{MMUX_LIBC_EINVAL} and the return value is @ctrue{}.

The main purpose of extracting the rootname from a file system pathname is to build a new file
system pathname from an existing file system pathname by changing the extension, for example to
build @file{/path/to/file.o} from @file{/path/to/file.c}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_make_file_system_pathname_dirname (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_copying_arg_t @var{fs_ptn_factory}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Build a new file system pathname representing the dirname of @var{fs_ptn}; store in the variable
referenced by @var{fs_ptn_result} the new pathname object.  The @dfn{dirname} of a file system pathname
is its directory part; if the pathname is itself a directory: its dirname is the full pathname
itself.

@example
/path/to/file.ext       @result{} /path/to/
file.ext                @result{} .
/path/to/dir/           @result{} /path/to/dir/
/path/to/.              @result{} /path/to/
/path/to/..             @result{} /path/to/..
.                       @result{} .
..                      @result{} ..
/                       @result{} /
@end example

Any file system pathname has a directory part.

The main purpose of extracting the dirname from a file system pathname is to build a new file system
pathname from an existing file system pathname by changing the filename, for example to build
@file{/path/to/other.ext} from @file{/path/to/some.ext}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_make_file_system_pathname_tailname (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_copying_arg_t @var{fs_ptn_factory}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Build a new file system pathname representing the tailname of @var{fs_ptn}; store in the variable
referenced by @var{fs_ptn_result} the new pathname object.  The @dfn{tailname} of a file system pathname
is the last segment of the input pathname:

@example
/path/to/file.ext       @result{} file.ext
/path/to/dir/           @result{} dir
file.ext                @result{} file.ext
.                       @result{} .
..                      @result{} ..
/                       @result{} /
@end example

The main purpose of extracting the tailname from a file system pathname is to build a new file
system pathname from an existing file system pathname using the same last segment, for example to
build @file{/path/to/this} from @file{/path/from/this}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_make_file_system_pathname_filename (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_copying_arg_t @var{fs_ptn_factory}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Build a new file system pathname representing the filename of @var{fs_ptn}; store in the variable
referenced by @var{fs_ptn_result} the new pathname object.  The @dfn{filename} of a file system pathname
is the relative pathname representing the last segment of the input pathname, if it does not
represent a directory:

@example
/path/to/file.ext       @result{} file.ext
file.ext                @result{} file.ext
/path/to/dir/           @error{}  invalid argument
.                       @error{}  invalid argument
..                      @error{}  invalid argument
/                       @error{}  invalid argument
@end example

@noindent
if @var{fs_ptn} represents a directory, then the function call fails: @code{errno} is set to
@code{MMUX_LIBC_EINVAL} and the returned value is @ctrue{}.

The main purpose of extracting the filename from a file system pathname is to build a new file
system pathname from an existing file system pathname using the same filename, for example to build
@file{/path/to/file.ext} from @file{/path/from/file.ext}.
@end deftypefun

@c page
@node fs pathnames pathnames normalisation
@subsubsection Normalising of file system pathnames


@cindex Normalising file system pathnames
@cindex File system pathnames, normalisation


A @dfn{normalised} file system pathname: has no multiple slashes; has no useless terminating slash;
has no useless single--dot components; has the double--dot components removed as much as possible.
Examples:

@example
/                               @result{} /
file.ext                        @result{} file.ext
/path/to/file.ext               @result{} /path/to/file.ext
//                              @result{} /
/path///to///file.ext           @result{} /path/to/file.ext
/path/to/dir/                   @result{} /path/to/dir/
/path/to/././file.ext           @result{} /path/to/file.ext
/path/to/.                      @result{} /path/to
/path/to/../file.ext            @result{} /path/file.ext
/path/to/../../this/file.ext    @result{} /this/file.ext
path/../../../file.ext          @result{} ../../file.ext
./path/../../../file.ext        @result{} ../../file.ext
.                               @result{} .
..                              @result{} ..
./                              @result{} .
../                             @result{} ..
/.                              @result{} /
/..                             @error{} invalid pathname
/path/../..                     @error{} invalid pathname
@end example

Most of the times we want to normalise a pathname before using it with this package.


@deftypefun bool mmux_libc_make_file_system_pathname_normalised (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_copying_arg_t @var{fs_ptn_factory}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Make a new file system pathname value normalising the pathname @var{fs_ptn}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path///to/.././file.ext";
mmux_libc_fs_ptn_t  fs_ptn, fs_ptn_norm;

/* Build the source file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Build the normalised file system pathname. */
@{
  mmux_libc_fs_ptn_factory_copying_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname_normalised(fs_ptn_norm, fs_ptn_factory, fs_ptn)) @{
    /* error */
  @}
@}

@{
  /* Do something. */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
  mmux_libc_unmake_file_system_pathname(fs_ptn_norm);
@}
@end example
@end deftypefun

@c page
@node fs pathnames pathnames operations
@subsubsection Operations on file system pathnames


@cindex Appending file system pathnames
@cindex Concatenating file system pathnames
@cindex Prefix file system pathnames
@cindex Suffix file system pathnames
@cindex File system pathnames, concatenation
@cindex File system pathnames, appending
@cindex File system pathnames, prefix
@cindex File system pathnames, suffix


@deftypefun bool mmux_libc_make_file_system_pathname_concat (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_copying_arg_t @var{fs_ptn_factory}, mmux_libc_fs_ptn_arg_t @var{prefix}, mmux_libc_fs_ptn_arg_t @var{suffix})
Make a new file system pathname by concatenating the @var{prefix} with the @var{suffix}; the new
pathname is normalised using @cfunc{mmux_libc_make_file_system_pathname_normalised}.

@example
mmux_asciizcp_t     ptn_asciiz_prefix = "/tmp/package-1.2.3";
mmux_asciizcp_t     ptn_asciiz_suffix = "/usr/local/";
mmux_libc_fs_ptn_t  fs_ptn, fs_ptn_prefix, fs_ptn_suffix;

/* Build the prefix and suffix file system pathnames. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_prefix, fs_ptn_factory, ptn_asciiz_prefix)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname(fs_ptn_suffix, fs_ptn_factory, ptn_asciiz_suffix)) @{
    /* error */
  @}
@}

/* Build the whole file system pathname. */
@{
  mmux_libc_fs_ptn_factory_copying_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname_concat(fs_ptn, fs_ptn_factory, fs_ptn_prefix, fs_ptn_suffix)) @{
    /* error */
  @}
@}

@{
  /* Do something. */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
  mmux_libc_unmake_file_system_pathname(fs_ptn_prefix);
  mmux_libc_unmake_file_system_pathname(fs_ptn_suffix);
@}
@end example
@end deftypefun

@c page
@node fs pathnames extensions
@subsection Extensions of file system pathnames


Given that a file system pathname is an array of octets terminated by a zero octet, to be interpreted
as @MmuxAsciiZ{} string: a file system pathname extension is also an array of octets to be interpreted an
@MmuxAscii{} string, but it is @strong{not} necessarily terminated by a zero octet.

Examples defining what a file system pathname extension is:

@example
/path/to/file.ext               @result{} .ext
/path/to/file                   @result{} <empty>
/path/to/file.                  @result{} .
/path/to/file-1.2.3.ext         @result{} .ext
/path/to/.dotfile.ext           @result{} .ext
/path/to/.dotfile               @result{} <empty>
/path/to/directory.d/           @result{} .d
/                               @error{} <invalid pathname>
.                               @error{} <invalid pathname>
..                              @error{} <invalid pathname>
/path/to/.                      @error{} <invalid pathname>
/path/to/..                     @error{} <invalid pathname>
@end example

@noindent
attempting to extract the extension from some file system pathnames will result in an error, because
those special pathnames are defined to not have an extension.  A file system pathname extension is
empty if it has length equal to zero.

Under @value{PACKAGE}: file system pathname extensions are represented with objects of type
@objtype{mmux_libc_file_system_pathname_extension_t}.  Some constructors of this object attempt to
determine the extension of the last portion of a file system pathname even when such pathname is not
normalised; it is the responsibility of the caller to make sure that the pathname can be parsed in
such a way that the correct extension is determined.

@menu
* fs pathnames extensions types::               Data types representing file names extensions.
* fs pathnames extensions inspection::          File system pathname extensions inspection.
* fs pathnames extensions constructors::        Building file system pathname extensions.
* fs pathnames extensions comparison::          Comparing file system pathname extensions.
* fs pathnames extensions predicates::          Predicates for file system pathname extensions.
@end menu

@c page
@node fs pathnames extensions types
@subsubsection Data types representing file names extensions


@deftp {Struct Typedef} mmux_libc_file_system_pathname_extension_t
@deftpx {Struct Pointer Typedef} mmux_libc_fs_ptn_extension_t
@deftpx {Struct Pointer Typedef} mmux_libc_fs_ptn_extension_arg_t
Data structure representing a file system pathname extension.  Instances of this type @strong{do
not} own the memory they reference, either:

@itemize
@item
an instance of @objtype{mmux_libc_file_system_pathname_extension_t} references memory from an object
of type @objtype{mmux_libc_file_system_pathname_t};

@item
an instance of @objtype{mmux_libc_file_system_pathname_extension_t} references memory from a
statically allocated array of characters;

@item
an instance of @objtype{mmux_libc_file_system_pathname_extension_t} references memory from some
@MmuxAscii{} string whose memory is owned by some other object;
@end itemize

@noindent
so this type has constructors but not destructors, instances of this type do not need to be
finalised to release asynchronous resources.

The pointer types are defined as follows:

@example
typedef struct mmux_libc_file_system_pathname_extension_t          mmux_libc_fs_ptn_extension_t[1];
typedef struct mmux_libc_file_system_pathname_extension_t const *  mmux_libc_fs_ptn_extension_arg_t;
@end example

@noindent
the type @objtype{mmux_libc_fs_ptn_extension_t} is used for automatic variables and mutable
arguments to function; the type @objtype{mmux_libc_fs_ptn_extension_arg_t} is used for immutable
arguments to function.

We need to remember that we can print a file system pathname extension to a file descriptor using
the function @cfunc{mmux_libc_dprintf_fs_ptn_extension}, @ref{mmux_libc_dprintf_fs_ptn_extension}
for details.
@end deftp

@c page
@node fs pathnames extensions inspection
@subsubsection File system pathname extensions inspection


To inspect the @MmuxAscii{} string and its length in a file system pathname extension, we do:

@example
mmux_libc_fs_ptn_t            fs_ptn;
mmux_libc_fs_ptn_extension_t  fs_ptn_ext;

/* Build the file system pathname. */
@{
  mmux_asciizcp_t                     ptn_asciiz = "/path/to/file.ext";
  mmux_libc_fs_ptn_factory_copying_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Build the file system pathname extension. */
@{
  if (mmux_libc_make_file_system_pathname_extension(fs_ptn_ext, fs_ptn)) @{
    /* error */
  @}
@}

/* Inspect the fields. */
@{
  mmux_asciicp_t  ptr;
  mmux_usize_t    len;

  mmux_libc_file_system_pathname_extension_ptr_ref(&ptr, fs_ptn_ext);
  mmux_libc_file_system_pathname_extension_len_ref(&len, fs_ptn_ext);
  /* Do something. */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example


@deftypefun bool mmux_libc_file_system_pathname_extension_ptr_ref (mmux_asciicpp_t @var{result_p}, mmux_libc_fs_ptn_extension_arg_t @var{fs_ptn_ext})
Accessor for the pointer to string of @var{fs_ptn_ext}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_len_ref (mmux_usize_t * @var{result_p}, mmux_libc_fs_ptn_extension_arg_t @var{fs_ptn_ext})
Accessor for the number of characters in the string of @var{fs_ptn_ext}.
@end deftypefun

@c page
@node fs pathnames extensions constructors
@subsubsection Building file system pathnames extensions


For all the following constructors: if the pathname is a special directory (@file{/} or @file{.} or
@file{..} or @file{/path/to/.} or @file{/path/to/..}), the constructor sets @code{errno} to
@samp{MMUX_LIBC_EINVAL}, then returns true.


@deftypefun bool mmux_libc_make_file_system_pathname_extension (mmux_libc_fs_ptn_extension_t @var{fs_ptn_ext_result}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
Build a new @objtype{mmux_libc_file_system_pathname_extension_t} object from a file system pathname
object @var{fs_ptn}.  The resulting extension object shares memory with the pathname object.

@example
mmux_libc_fs_ptn_t            fs_ptn;
mmux_libc_fs_ptn_extension_t  fs_ptn_ext;

/* Build the file system pathname. */
@{
  mmux_asciizcp_t                     ptn_asciiz = "/path/to/file.ext";
  mmux_libc_fs_ptn_factory_copying_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Build the file system pathname extension. */
@{
  if (mmux_libc_make_file_system_pathname_extension(fs_ptn_ext, fs_ptn)) @{
    /* error */
  @}
@}

@{
  /* Do something. */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname_extension2 (mmux_libc_ptn_extension_t * @var{result_p}, mmux_asciicp_t ptr, mmux_usize_t @var{len})
Build a new @objtype{mmux_libc_file_system_pathname_extension_t} object from an @MmuxAscii{} string.
The resulting extension object shares memory with the string itself.

@example
auto  ext_len = mmux_usize_literal(4);
char  ext_ascii[ext_len.value] = @{ '.', 'e', 'x', 't' @};
mmux_libc_fs_ptn_extension_t  fs_ptn_ext;

if (mmux_libc_make_file_system_pathname_extension2(fs_ptn_ext, ext_ascii, ext_len)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname_extension1 (mmux_libc_ptn_extension_t * @var{result_p}, mmux_asciizcp_t @var{ptr})
Build a new @objtype{mmux_libc_file_system_pathname_extension_t} object from an @MmuxAsciiZ{}
string.  The resulting extension object shares memory with the string itself.

@example
mmux_asciizcp_t               ext_asciiz = ".ext";
mmux_libc_fs_ptn_extension_t  fs_ptn_ext;

if (mmux_libc_make_file_system_pathname_extension1(fs_ptn_ext, ext_asciiz)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs pathnames extensions comparison
@subsubsection Comparing file system pathname extensions


@deftypefun bool mmux_libc_file_system_pathname_extension_compare (mmux_ternary_comparison_result_t * @var{result_p}, mmux_libc_fs_ptn_extension_arg_t @vari{ext}, mmux_libc_fs_ptn_extension_arg_t @varii{ext})
Compare two extensions and store in the variable referenced by @var{result_p}.  The file system
pathname extensions are compared as strings, using the standard @cfunc{strncmp}:

@itemize
@item
if the extensions have the same length, @cfunc{strncmp} is applied to the whole strings;

@item
if the extensions have different length, @cfunc{strncmp} is applied to portion of the strings of
maximum common length; if these substrings are equal: the shortest is considered less than the
longest.
@end itemize

@example
mmux_asciizcp_t               ext_asciiz1 = ".bak";
mmux_asciizcp_t               ext_asciiz2 = ".cpp";
mmux_libc_fs_ptn_extension_t  ext1, ext2;

/* Build the extensions. */
@{
  if (mmux_libc_make_file_system_pathname_extension1(ext1, ext_asciiz1)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname_extension1(ext2, ext_asciiz2)) @{
    /* error */
  @}
@}

/* Compare the extensions. */
@{
  mmux_ternary_comparison_result_t  cmpnum;

  if (mmux_libc_file_system_pathname_extension_compare(&cmpnum, ext1, ext2)) @{
    /* error */
  @}

  if (mmux_ternary_comparison_result_is_equal(cmpnum)) @{
    ...
  @}
@}
@end example
@end deftypefun


For all the functions below the comparison is performed using
@cfunc{mmux_libc_file_system_pathname_extension_compare}.


@deftypefun bool mmux_libc_file_system_pathname_extension_equal (bool * @var{result_p}, mmux_libc_fs_ptn_extension_arg_t @vari{ext}, mmux_libc_fs_ptn_extension_arg_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} == @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_not_equal (bool * @var{result_p}, mmux_libc_fs_ptn_extension_arg_t @vari{ext}, mmux_libc_fs_ptn_extension_arg_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} != @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_less (bool * @var{result_p}, mmux_libc_fs_ptn_extension_arg_t @vari{ext}, mmux_libc_fs_ptn_extension_arg_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} < @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_greater (bool * @var{result_p}, mmux_libc_fs_ptn_extension_arg_t @vari{ext}, mmux_libc_fs_ptn_extension_arg_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} > @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_less_equal (bool * @var{result_p}, mmux_libc_fs_ptn_extension_arg_t @vari{ext}, mmux_libc_fs_ptn_extension_arg_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} <= @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_greater_equal (bool * @var{result_p}, mmux_libc_fs_ptn_extension_arg_t @vari{ext}, mmux_libc_fs_ptn_extension_arg_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} >= @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun

@c page
@node fs pathnames extensions predicates
@subsubsection Predicates for file system pathname extensions


@deftypefun bool mmux_libc_file_system_pathname_extension_is_empty (bool * @var{result_p}, mmux_libc_fs_ptn_extension_arg_t @var{ext})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{ext} represents the empty file
system pathname extension; otherwise store @cfalse{}.

@example
mmux_libc_fs_ptn_t            fs_ptn;
mmux_libc_fs_ptn_extension_t  fs_ptn_ext;

/* Build file system pathname. */
@{
  mmux_asciizcp_t             ptn_asciiz = "/path/to/file.ext";
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Build file system pathname extension. */
@{
  if (mmux_libc_make_file_system_pathname_extension(fs_ptn_ext, fs_ptn)) @{
    /* error */
  @}
@}

@{
  bool  extension_is_empty;

  mmux_libc_file_system_pathname_extension_is_empty(&extension_is_empty, fs_ptn_ext);
  if (extension_is_empty) @{
    ...
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_has_extension (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{fs_ptn}, mmux_libc_fs_ptn_extension_arg_t @var{fs_ptn_ext})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{fs_ptn} has extension
@var{fs_ptn_ext}; otherwise store @cfalse{}.

@example
mmux_libc_fs_ptn_t            fs_ptn;
mmux_libc_fs_ptn_extension_t  fs_ptn_ext;

/* Build file system pathname. */
@{
  mmux_asciizcp_t             ptn_asciiz = "/path/to/file.ext";
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Build file system pathname extension. */
@{
  if (mmux_libc_make_file_system_pathname_extension(fs_ptn_ext, fs_ptn)) @{
    /* error */
  @}
@}

@{
  bool  has_this_extension;

  mmux_libc_file_system_pathname_has_extension(&has_thi_extension, fs_ptn_ext);
  if (has_thi_extension) @{
    ...
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs pathnames segments
@subsection Extensions of file system pathnames


Given the file system pathname:

@example
/path/to/file.ext
@end example

@noindent
the segments are the strings:

@example
path
to
file.ext
@end example

@noindent
notice that the slash separators are @strong{excluded}.  There is a special case: if the pathname is
a single @samp{/} character, its only segment is a single @samp{/} character.  File system pathname
segments cannot be empty strings.

Given that a file system pathname is an array of octets terminated by a zero octet, to be
interpreted as @MmuxAsciiZ{} string: a file system pathname segment is also an array of octets to be
interpreted an @MmuxAscii{} string, but it is @strong{not} necessarily terminated by a zero octet.

Under @value{PACKAGE}: file system pathname segments are represented with objects of type
@objtype{mmux_libc_file_system_pathname_segment_t}.  Some constructors of this object attempt to
determine the segments of a file system pathname even when such pathname is not normalised; it is
the responsibility of the caller to make sure that the pathname can be parsed in such a way that the
correct segment is determined.

@menu
* fs pathnames segments types::               Data types representing file system pathname segments.
* fs pathnames segments inspection::          File system pathname segments inspection.
* fs pathnames segments constructors::        Building file system pathname segments.
* fs pathnames segments comparison::          Comparing file system pathname segments.
* fs pathnames segments predicates::          Predicates on file system pathname segments.
@end menu

@c page
@node fs pathnames segments types
@subsubsection Data types representing file system pathname segments


@deftp {Struct Typedef} mmux_libc_file_system_pathname_segment_t
@deftpx {Struct Pointer Typedef} mmux_libc_fs_ptn_segment_t
@deftpx {Struct Pointer Typedef} mmux_libc_fs_ptn_segment_arg_t
Data structure representing a file system pathname segment.  Instances of this type @strong{do not}
own the memory they reference, either:

@itemize
@item
an instance of @objtype{mmux_libc_file_system_pathname_segment_t} references memory from an object
of type @objtype{mmux_libc_file_system_pathname_t};

@item
an instance of @objtype{mmux_libc_file_system_pathname_segment_t} references memory from a
statically allocated array of characters;

@item
an instance of @objtype{mmux_libc_file_system_pathname_segment_t} references memory from some
@MmuxAscii{} string whose memory is owned by some other object;
@end itemize

@noindent
so this type has constructors but not destructors, instances of this type do not need to be
finalised to release asynchronous resources.

The pointer types are defined as follows:

@example
typedef struct mmux_libc_file_system_pathname_segment_t          mmux_libc_fs_ptn_segment_t[1];
typedef struct mmux_libc_file_system_pathname_segment_t const *  mmux_libc_fs_ptn_segment_arg_t;
@end example

@noindent
the type @objtype{mmux_libc_fs_ptn_segment_t} is used for automatic variables and mutable arguments
to function; the type @objtype{mmux_libc_fs_ptn_segment_arg_t} is used for immutable arguments to
function.

We need to remember that we can print a file system pathname segment to a file descriptor using
the function @cfunc{mmux_libc_dprintf_fs_ptn_segment}, @ref{mmux_libc_dprintf_fs_ptn_segment}
for details.
@end deftp

@c page
@node fs pathnames segments inspection
@subsubsection File system pathname segments inspection


To inspect the @MmuxAscii{} string and its length in a file system pathname segment, we do:

@example
mmux_libc_fs_ptn_t          fs_ptn;
mmux_libc_fs_ptn_segment_t  fs_ptn_seg;

/* Build the file system pathname. */
@{
  mmux_asciizcp_t                     ptn_asciiz = "/path/to/file.ext";
  mmux_libc_fs_ptn_factory_copying_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Build the file system pathname segment. */
@{
  if (mmux_libc_file_system_pathname_segment_find_last(fs_ptn_seg, fs_ptn)) @{
    /* error */
  @}
@}

/* Inspect the fields. */
@{
  mmux_asciicp_t  ptr;
  mmux_usize_t    len;

  mmux_libc_file_system_pathname_segment_ptr_ref(&ptr, fs_ptn_seg);
  mmux_libc_file_system_pathname_segment_len_ref(&len, fs_ptn_seg);
  /* Do something. */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example


@deftypefun bool mmux_libc_file_system_pathname_segment_ptr_ref (mmux_asciicpp_t @var{result_p}, mmux_libc_fs_ptn_segment_arg_t @var{seg})
Accessor for the pointer to string of @var{fs_ptn_seg}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_len_ref (mmux_usize_t * @var{result_p}, mmux_libc_fs_ptn_segment_arg_t @var{seg})
Accessor for the string length of @var{fs_ptn_seg}.
@end deftypefun

@c page
@node fs pathnames segments constructors
@subsubsection Building file system pathnames segments


@deftypefun bool mmux_libc_file_system_pathname_segment_find_last (mmux_libc_fs_ptn_segment_t @var{fs_ptn_seg_result}, mmux_libc_fs_ptn_t @var{fs_ptn})
Build a new @objtype{mmux_libc_file_system_pathname_segment_t} object from a file system pathname
object @var{fs_ptn}.  The resulting segment object shares memory with the pathname object.

@example
mmux_libc_fs_ptn_t          fs_ptn;
mmux_libc_fs_ptn_segment_t  fs_ptn_seg;

/* Build the file system pathname. */
@{
  mmux_asciizcp_t                     ptn_asciiz = "/path/to/file.ext";
  mmux_libc_fs_ptn_factory_copying_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Build the file system pathname segment. */
@{
  if (mmux_libc_file_system_pathname_segment_find_last(fs_ptn_seg, fs_ptn)) @{
    /* error */
  @}
@}

@{
  /* Do something. */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname_segment2 (mmux_libc_fs_ptn_segment_t @var{fs_ptn_seg_result}, mmux_asciicp_t ptr, mmux_usize_t @var{len})
Build a new @objtype{mmux_libc_file_system_pathname_segment_t} object from an @MmuxAscii{} string.
The resulting segment object shares memory with the string itself.

@example
auto  seg_len = mmux_usize_literal(4);
char  seg_ascii[seg_len.value] = @{ 'c', 'i', 'a', 'o' @};
mmux_libc_fs_ptn_segment_t  fs_ptn_seg;

if (mmux_libc_make_file_system_pathname_segment2(fs_ptn_seg, seg_ascii, seg_len)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname_segment1 (mmux_libc_fs_ptn_segment_t @var{fs_ptn_seg_result}, mmux_asciizcp_t @var{ptr})
Build a new @objtype{mmux_libc_file_system_pathname_segment_t} object from an @MmuxAsciiZ{} string.
The resulting segment object shares memory with the string itself.

@example
mmux_asciizcp_t             seg_asciiz = "ciao";
mmux_libc_fs_ptn_segment_t  fs_ptn_seg;

if (mmux_libc_make_file_system_pathname_segment1(fs_ptn_seg, seg_asciiz)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs pathnames segments comparison
@subsubsection Comparing file system pathname segments


@deftypefun bool mmux_libc_file_system_pathname_segment_compare (mmux_ternary_comparison_result_t * @var{result_p}, mmux_libc_fs_ptn_segment_arg_t @vari{seg}, mmux_libc_fs_ptn_segment_arg_t @varii{seg})
Compare two segments and store in the variable referenced by @var{result_p}.  The file system
pathname segments are compared as strings, using the standard @cfunc{strncmp}:

@itemize
@item
if the segments have the same length, @cfunc{strncmp} is applied to the whole strings;

@item
if the segments have different length, @cfunc{strncmp} is applied to portion of the strings of
maximum common length; if these substrings are equal: the shortest is considered less than the
longest.
@end itemize

@example
mmux_asciizcp_t             seg_asciiz1 = "ciao";
mmux_asciizcp_t             seg_asciiz2 = "hello";
mmux_libc_fs_ptn_segment_t  seg1, seg2;

/* Build the segments. */
@{
  if (mmux_libc_make_file_system_pathname_segment1(seg1, seg_asciiz1)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname_segment1(seg2, seg_asciiz2)) @{
    /* error */
  @}
@}

/* Compare the segments. */
@{
  mmux_ternary_comparison_result_t  cmpnum;

  if (mmux_libc_file_system_pathname_segment_compare(&cmpnum, seg1, seg2)) @{
    /* error */
  @}

  if (mmux_ternary_comparison_result_is_equal(cmpnum)) @{
    ...
  @}
@}
@end example
@end deftypefun


For all the functions below the comparison is performed using
@cfunc{mmux_libc_file_system_pathname_segment_compare}.


@deftypefun bool mmux_libc_file_system_pathname_segment_equal (bool * @var{result_p}, mmux_libc_fs_ptn_segment_arg_t @vari{seg}, mmux_libc_fs_ptn_segment_arg_t @varii{seg})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{seg} == @varii{seg}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_not_equal (bool * @var{result_p}, mmux_libc_fs_ptn_segment_arg_t @vari{seg}, mmux_libc_fs_ptn_segment_arg_t @varii{seg})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{seg} != @varii{seg}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_less (bool * @var{result_p}, mmux_libc_fs_ptn_segment_arg_t @vari{seg}, mmux_libc_fs_ptn_segment_arg_t @varii{seg})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{seg} < @varii{seg}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_greater (bool * @var{result_p}, mmux_libc_fs_ptn_segment_arg_t @vari{seg}, mmux_libc_fs_ptn_segment_arg_t @varii{seg})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{seg} > @varii{seg}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_less_equal (bool * @var{result_p}, mmux_libc_fs_ptn_segment_arg_t @vari{seg}, mmux_libc_fs_ptn_segment_arg_t @varii{seg})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{seg} <= @varii{seg}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_greater_equal (bool * @var{result_p}, mmux_libc_fs_ptn_segment_arg_t @vari{seg}, mmux_libc_fs_ptn_segment_arg_t @varii{seg})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{seg} >= @varii{seg}}; otherwise store @cfalse{}.
@end deftypefun

@c page
@node fs pathnames segments predicates
@subsubsection Predicates on file system pathname segments


@deftypefun bool mmux_libc_file_system_pathname_segment_is_dot (bool * @var{result_p}, mmux_libc_fs_ptn_segment_t @var{fs_ptn_seg})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{fs_ptn_seg} represents the
single dot segment @samp{.}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_is_double_dot (bool * @var{result_p}, mmux_libc_fs_ptn_segment_t @var{fs_ptn_seg})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{fs_ptn_seg} represents the
double dot @samp{..}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_is_slash (bool * @var{result_p}, mmux_libc_fs_ptn_segment_t @var{fs_ptn_seg})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{fs_ptn_seg} represents the
single slash segment @samp{/}; otherwise store @cfalse{}.
@end deftypefun

@c page
@node fs pathnames examples
@subsection Usage examples for file system pathnames


Build a file system pathname from an @MmuxAsciiZ{} string (@strong{with} terminating
nul--character), by allocating dynamic memory and copying the source string into it:

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

@{
  /* Do something with "fs_ptn". */
@}

/* Final cleanup. */
@{
  if (mmux_libc_unmake_file_system_pathname(fs_ptn)) @{
    /* error */
  @}
@}
@end example

@c ------------------------------------------------------------------------

Build a file system pathname from an @MmuxAscii{} string (@strong{without} terminating
nul--character), by allocating dynamic memory and copying the source string into it:

@example
//                                012345678
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
auto                ptn_len    = mmux_usize_literal(9);
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname2(fs_ptn, fs_ptn_factory,
                                           ptn_asciiz, ptn_len)) @{
    /* error */
  @}
@}

@{
  /* Do something with "fs_ptn". */
@}

/* Final cleanup. */
@{
  if (mmux_libc_unmake_file_system_pathname(fs_ptn)) @{
    /* error */
  @}
@}
@end example

@c ------------------------------------------------------------------------

Allocate a buffer containing the file system pathname as @MmuxAsciiZ{} string (@strong{with}
terminating nul--character), then swallow the buffer in the file system pathname object:

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Obtain the file system pathname. */
@{
  mmux_asciizp_t bufptr;

  /* Allocate a new memory block and copy the file system pathname into it,
     with terminating nul-character. */
  @{
    mmux_usize_t  buflen;

    mmux_libc_strlen_plus_nil(&buflen, ptn_asciiz);
    if (mmux_libc_malloc_and_copy(&bufptr, ptn_asciiz, buflen)) @{
      /* error */
    @}
  @}

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_swallow(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname2(fs_ptn, fs_ptn_factory, bufptr)) @{
      /* error */
    @}
  @}
@}

@{
  /* Do something with "fs_ptn". */
@}

/* Final cleanup. */
@{
  if (mmux_libc_unmake_file_system_pathname(fs_ptn)) @{
    /* error */
  @}
@}
@end example

@c ------------------------------------------------------------------------

We can print a file system pathname to a file descriptor using the function
@cfunc{mmux_libc_dprintf_fs_ptn}; @ref{mmux_libc_dprintf_fs_ptn} for details.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Print it. */
@{
  mmux_libc_fd_t  fd;

  mmux_libc_stdou(fd);
  if (mmux_libc_dprintf_fs_ptn(fd, fs_ptn)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_unmake_file_system_pathname(fs_ptn)) @{
    /* error */
  @}
@}
@end example

@c page
@node fs directories
@section File system directories


@menu
* fs directories streams::      Directory inspection objects.
* fs directories entries::      Directory entry objects.
* fs directories inspection::   Inspecting file system directories.
* fs directories creation::     Creating file system directories.
* fs directories deletion::     Deleting file system directories.
* fs directories working::      Handling the current working directory.
* fs directories root::         Handling the root directory.
@end menu

@c page
@node fs directories streams
@subsection Directory inspection objects


For an example of how to use and inspect data structures representing file system directories see,
for example, @ref{fs directories inspection opendir, Opening a directory for inspection with
@cfunc{mmux_libc_opendir}}.


@deftp {Opaque Struct Typedef} mmux_libc_file_system_dirstream_ptr_t
An opaque data structure representing a pointer to directory stream, defined by the standard as
@code{DIR *}.
@end deftp


@deftp {1--Element Array Typedef} mmux_libc_dirstream_t
Type of 1--element array defines as:

@example
typedef mmux_libc_file_system_dirstream_ptr_t  mmux_libc_dirstream_t[1];
@end example

@noindent
it is meant to be used to define local variables and output arguments to functions.
@end deftp


@deftp {Pointer Typedef} mmux_libc_dirstream_arg_t
Pointer type defined as:

@example
typedef mmux_libc_file_system_dirstream_ptr_t const *  mmux_libc_dirstream_arg_t;
@end example

@noindent
it is meant to be used as type of input arguments to function.
@end deftp


@deftp {Opaque Struct Type} mmux_libc_dirstream_position_t
Opaque data structure used to represent the position in a directory stream retrieved with
@cfunc{mmux_libc_telldir}, @ref{fs directories inspection operations, Operations on a directory
stream}.
@end deftp

@c page
@node fs directories entries
@subsection Directory entry objects


For an example of how to use and inspect data structures representing file system directory entries
see, for example, @ref{fs directories inspection opendir, Opening a directory for inspection with
@cfunc{mmux_libc_opendir}}.


@deftp {Opaque Struct Typedef} mmux_libc_file_system_dirent_t
An opaque alias for the standard data structure type @code{struct direntry}.
@end deftp


@deftp {Struct Typedef} mmux_libc_file_system_dirent_ptr_t
Type of data structures defined as:

@example
typedef struct mmux_libc_file_system_dirent_ptr_t @{
  mmux_libc_file_system_dirent_t const *  value;
@} mmux_libc_file_system_dirent_ptr_t;
@end example
@end deftp


@deftp {1--Element Array Typedef} mmux_libc_dirent_t
Type of 1--element array defined as:

@example
typedef mmux_libc_file_system_dirent_ptr_t  mmux_libc_dirent_t[1];
@end example

@noindent
it is meant to be used as type of local variables and output arguments to function.
@end deftp


@deftp {Pointer Typedef} mmux_libc_dirent_arg_t
Type of pointers defined as:

@example
typedef mmux_libc_file_system_dirent_ptr_t const *  mmux_libc_dirent_arg_t;
@end example

@noindent
it is meant to be used as type of input arguments to function.
@end deftp

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_d_name_ref (mmux_asciizcp_t * @var{RESULT_P}, mmux_libc_dirent_t @var{dirent})
Getter for the field @code{d_name} of @objtype{mmux_libc_file_system_dirent_t}.
@end deftypefun


@deftypefun bool mmux_libc_d_fileno_ref (mmux_uintmax_t * @var{result_p}, mmux_libc_dirent_t @var{dirent})
Getter for the field @code{d_fileno} of @objtype{mmux_libc_file_system_dirent_t}.
@end deftypefun


@deftypefun bool mmux_libc_dirent_dump (mmux_libc_fd_arg_t @var{fd}, mmux_libc_dirent_t @var{dirent}, mmux_asciizcp_t @var{struct_name})
Write to @var{fd} a description of the fields of the instance of
@objtype{mmux_libc_file_system_dirent_t} referenced by @var{dirent}.  @var{struct_name} must be a
pointer to an @MmuxAsciiZ{} string representing the name of the data structure used in the description;
when @cnull{}: it defaults to @samp{struct dirent}.
@end deftypefun

@c page
@node fs directories inspection
@subsection Inspecting file system directories


@menu
* fs directories inspection opendir::     Opening a directory for inspection with @cfunc{mmux_libc_opendir}.
* fs directories inspection fdopendir::   Opening a directory for inspection with @cfunc{mmux_libc_fdopendir}.
* fs directories inspection dirfd::       Opening a directory for inspection with @cfunc{mmux_libc_dirfd}.
* fs directories inspection operations::  Operations on a directory stream.
@end menu

@c page
@node fs directories inspection opendir
@subsubsection Opening a directory for inspection with @cfunc{mmux_libc_opendir}


@deftypefun bool mmux_libc_opendir (mmux_libc_dirstream_t @var{result_dirstream_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
@MmuxCInterfaceGlibc{opendir, Opening a Directory}.

@example
mmux_asciizcp_t        ptn_asciiz = "/path/to/directory.d";
mmux_libc_dirstream_t  dirstream;

/* Open the directory stream. */
@{
  mmux_libc_fs_ptn_t  fs_ptn_directory;

  /* Build file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn_directory, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Do it. */
  @{
    if (mmux_libc_opendir(dirstream, fs_ptn_directory)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn_directory);
  @}
@}

/* Inspect the directory entries. */
@{
  mmux_libc_dirent_t  direntry;

  for (;;) @{
    bool  there_are_more_entries;

    if (mmux_libc_readdir(&there_are_more_entries, direntry, dirstream)) @{
      /* error */
    @} else if (there_are_more_entries) @{
      /* Do something with "direntry". */
    @} else @{
      /* No more entries. */
    @}
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_closedir(dirstream)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs directories inspection fdopendir
@subsubsection Opening a directory for inspection with @cfunc{mmux_libc_fdopendir}


@deftypefun bool mmux_libc_fdopendir (mmux_libc_dirstream_t @var{result_dirstream_p}, mmux_libc_fd_arg_t @var{fd})
@MmuxCInterfaceGlibc{fdopendir, Opening a Directory}.

Notice that the descriptor @var{fd} will be closed if we apply @cfunc{mmux_libc_closedir} to the
resulting @objtype{mmux_libc_dirent_t} object; so we do not need to close @var{fd} with
@cfunc{mmux_libc_close}.

@example
mmux_asciizcp_t        ptn_asciiz = "/path/to/directory.d";
mmux_libc_dirstream_t  dirstream;

/* Obtain the directory stream. */
@{
  mmux_libc_dirfd_t  dirfd;

  /* Obtain the directory file descriptor. */
  @{
    mmux_libc_fs_ptn_t  fs_ptn_directory;

    /* Build file system pathname. */
    @{
      mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

      mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
      if (mmux_libc_make_file_system_pathname(fs_ptn_directory, fs_ptn_factory, ptn_asciiz)) @{
        /* error */
      @}
    @}

    /* Open the directory file descriptor. */
    @{
      auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_DIRECTORY | MMUX_LIBC_O_RDONLY);
      auto  mode  = mmux_libc_mode_constant_zero();

      if (mmux_libc_open(dirfd, fs_ptn_directory, flags, mode)) @{
        /* error */
      @};
    @}

    /* Local cleanup. */
    @{
      mmux_libc_unmake_file_system_pathname(fs_ptn_directory);
    @}
  @}

  /* Open the directory stream. */
  @{
    if (mmux_libc_fdopendir(dirstream, dirfd)) @{
      /* error */
    @}
  @}
@}

/* Inspect the directory entries. */
@{
  mmux_libc_dirent_t  direntry;

  for (;;) @{
    bool  there_are_more_entries;

    if (mmux_libc_readdir(&there_are_more_entries, direntry, dirstream)) @{
    /* error */
    @} else if (there_are_more_entries) @{
      /* Do something with "direntry". */
    @} else @{
      /* No more entries. */
    @}
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_closedir(dirstream)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs directories inspection dirfd
@subsubsection Opening a directory for inspection with @cfunc{mmux_libc_dirfd}


@deftypefun bool mmux_libc_dirfd (mmux_libc_dirfd_t @var{result_dirfd_p}, mmux_libc_dirstream_arg_t @var{dirstream})
@MmuxCInterfaceGlibc{dirfd, Opening a Directory}.  After retrieving the file descriptor, we can use
it with functions like @cfunc{mmux_libc_fstat} and @cfunc{mmux_libc_fchdir}.

@example
mmux_asciizcp_t        ptn_asciiz = "/path/to/directory.d";
mmux_libc_dirstream_t  dirstream;
mmux_libc_dirfd_t      dirfd;

/* Open the directory stream. */
@{
  mmux_libc_fs_ptn_t  fs_ptn_directory;

  /* Build file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn_directory, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Do it. */
  @{
    if (mmux_libc_opendir(dirstream, fs_ptn_directory)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn_directory);
  @}
@}

/* Obtain the directory file descriptor. */
@{
  if (mmux_libc_dirfd(dirfd, dirstream)) @{
    /* error */
  @}
@}

/* Print stat. */
@{
  mmux_libc_stat_t  stat;

  if (mmux_libc_fstat(stat, dirfd)) @{
    /* error */
  @} else @{
    mmux_libc_fd_t  er;

    mmux_libc_stder(er);
    if (mmux_libc_stat_dump(er, stat, NULL)) @{
      /* error */
    @}
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_closedir(dirstream)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs directories inspection operations
@subsubsection Operations on a directory stream


@deftypefun bool mmux_libc_closedir (mmux_libc_dirstream_arg_t @var{dirstream})
@MmuxCInterfaceGlibc{closedir, Reading/Closing Directory}.
@end deftypefun


@deftypefun bool mmux_libc_readdir (bool * @var{there_are_more_entries_p}, mmux_libc_dirent_t @var{result_dirent}, mmux_libc_dirstream_arg_t @var{dirstream})
@MmuxCInterfaceGlibc{readdir, Reading/Closing Directory}.

When successful: if there is a directory entry to inspect in @var{result_dirent} the variable
referenced by @var{there_are_more_entries_p} is set to @ctrue{}; if no more entries are available,
it is set to @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_rewinddir (mmux_libc_dirstream_arg_t @var{dirstream})
@MmuxCInterfaceGlibc{rewinddir, Random Access Directory}.
@end deftypefun


@deftypefun bool mmux_libc_telldir (mmux_libc_dirstream_position_t * @var{result_dirpos_p}, mmux_libc_dirstream_arg_t @var{dirstream})
@MmuxCInterfaceGlibc{telldir, Random Access Directory}.
@end deftypefun


@deftypefun bool mmux_libc_seekdir (mmux_libc_dirstream_arg_t @var{dirstream}, mmux_libc_dirstream_position_t @var{dirpos})
@MmuxCInterfaceGlibc{seekdir, Random Access Directory}.
@end deftypefun

@c page
@node fs directories creation
@subsection Creating file system directories


@deftypefun bool mmux_libc_mkdir (mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_mode_t mode)
@MmuxCInterface{mkdir}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/directory.d";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  auto  mode = mmux_libc_mode(MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR | MMUX_LIBC_S_IXUSR);

  if (mmux_libc_mkdir(fs_ptn, mode)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_mkdirat (mmux_libc_dirfd_arg_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_mode_t @var{mode})
@MmuxCInterface{mkdirat}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/directory.d";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_dirfd_t  dirfd;
  auto  mode = mmux_libc_mode(MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR | MMUX_LIBC_S_IXUSR);

  mmux_libc_at_fdcwd(dirfd);
  if (mmux_libc_mkdirat(dirfd, fs_ptn, mode)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs directories deletion
@subsection Deleting file system directories


@deftypefun bool mmux_libc_rmdir (mmux_libc_fs_ptn_arg_t pathname)
@MmuxCInterface{rmdir}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/directory.d";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  if (mmux_libc_rmdir(fs_ptn)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs directories working
@subsection Handling the current working directory


@menu
* fs directories working retrieving::   Retrieving the current working directory.
* fs directories working changing::     Changing the current working directory.
@end menu

@c page
@node fs directories working retrieving
@subsubsection Retrieving the current working directory


@deftypefun bool mmux_libc_getcwd (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_arg_t @var{fs_ptn_factory})
@MmuxCInterfaceGlibc{getcwd, Working Directory}.  Notice that @var{fs_ptn_factory} must dynamically
allocate the memory required to contain the whole file system pathname.

@example
mmux_libc_fs_ptn_t          fs_ptn_cwd;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_getcwd(fs_ptn_cwd, fs_ptn_factory)) @{
    /* error */
  @}
@}

@{
  /* Do something with "fs_ptn_cwd". */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn_cwd);
@}
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_get_current_dir_name (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_arg_t @var{fs_ptn_factory})
@MmuxCInterfaceGlibc{get_current_dir_name, Working Directory}.  Notice that @var{fs_ptn_factory}
must dynamically allocate the memory required to contain the whole file system pathname.  Remember
that this function attempts to build a resulting file system pathname that contains the symbolic
links of the current working directory.

@example
mmux_libc_fs_ptn_t          fs_ptn_cwd;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_get_current_dir_name(fs_ptn_cwd, fs_ptn_factory)) @{
    /* error */
  @}
@}

@{
  /* Do something with "fs_ptn_cwd". */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn_cwd);
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_getcwd_to_buffer (mmux_asciizp_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterfaceGlibc{getcwd, Working Directory}.

When successful: @var{bufptr} is filled with the @MmuxAsciiZ{} string representing the file system
pathname of the current working directory, including the terminating nul character.

If an error occurs: we must inspect the value of @code{errno}.

@example
auto  buflen = mmux_usize_literal(128);
char  bufptr[buflen.value];

if (mmux_libc_getcwd_to_buffer(bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs directories working changing
@subsubsection Changing the current working directory


@deftypefun bool mmux_libc_chdir (mmux_libc_fs_ptn_arg_t @var{dirptn})
@MmuxCInterfaceGlibc{chdir, Working Directory}.

@example
mmux_asciizcp_t     ptn_asciiz = "..";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  if (mmux_libc_chdir(fs_ptn)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_fchdir (mmux_libc_file_descriptor_t fd)
@MmuxCInterfaceGlibc{fchdir, Working Directory}.

@example
mmux_asciizcp_t     ptn_asciiz = "..";
mmux_libc_dirfd_t   dirfd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the directory. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_PATH);
    auto  mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(dirfd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Do it. */
@{
  if (mmux_libc_fchdir(dirfd)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(dirfd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs directories root
@subsection Handling the root directory


The following functions require the calling process to have special privileges.  They are included
in the @api{} of this package for completeness.


@deftypefun bool mmux_libc_chroot (mmux_libc_fs_ptn_arg_t @var{ptn})
@MmuxCInterface{chroot}.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_pivot_root (mmux_libc_fs_ptn_arg_t new_root_ptn, mmux_libc_fs_ptn_arg_t put_old_ptn)
@MmuxCInterface{pivot_root}.
@end deftypefn

@c page
@node fs links
@section Hard and symbolic links


@menu
* fs links hard::               File system hard links.
* fs links symbolic::           File system symbolic links.
* fs links follow::             Following file system symbolic links.
@end menu

@c page
@node fs links hard
@subsection File system hard links


@cindex File system, hard links
@cindex Hard links, file system


@deftypefun bool mmux_libc_link (mmux_libc_fs_ptn_arg_t @var{oldname}, mmux_libc_fs_ptn_arg_t @var{newname})
@MmuxCInterface{link}.

@example
mmux_asciizcp_t     ptn_asciiz_old = "/path/to/oldfile.ext";
mmux_asciizcp_t     ptn_asciiz_new = "/path/to/newfile.ext";
mmux_libc_fs_ptn_t  fs_ptn_old, fs_ptn_new;

@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_old, fs_ptn_factory, ptn_asciiz_old)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname(fs_ptn_new, fs_ptn_factory, ptn_asciiz_new)) @{
    /* error */
  @}
@}
@{
  if (mmux_libc_link(fs_ptn_old, fs_ptn_new)) @{
    /* error */
  @}
@}
mmux_libc_unmake_file_system_pathname(fs_ptn_old);
mmux_libc_unmake_file_system_pathname(fs_ptn_new);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftp {Struct Typedef} mmux_libc_linkat_flags_t
Data structure type representing the bitwise OR combination of flags to be handed as argument to
@cfunc{mmux_libc_linkat} and @cfunc{mmux_libc_linkfd}.
@end deftp


@deftypefun mmux_libc_linkat_flags_t mmux_libc_linkat_flags (mmux_standard_sint_t @var{flags})
Constructor for objects of type @objtype{mmux_libc_linkat_flags_t}.
@end deftypefun


@deftypefun bool mmux_libc_linkat (mmux_libc_dirfd_arg_t @var{dirfd_old}, mmux_libc_fs_ptn_arg_t @var{oldname}, mmux_libc_dirfd_arg_t @var{dirfd_new}, mmux_libc_fs_ptn_arg_t @var{newname}, mmux_sint_t @var{flags})
@MmuxCInterface{linkat}.

Notice that @var{flags} @strong{cannot} contain @samp{MMUX_LIBC_AT_EMPTY_PATH} because an object of
type @objtype{mmux_libc_fs_ptn_t} cannot represent the empty string pathname; we must use
@cfunc{mmux_libc_linkfd}.

@example
mmux_asciizcp_t     ptn_asciiz_old = "/path/to/oldfile.ext";
mmux_asciizcp_t     ptn_asciiz_new = "/path/to/newfile.ext";
mmux_libc_fs_ptn_t  fs_ptn_old, fs_ptn_new;

@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_old, fs_ptn_factory, ptn_asciiz_old)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname(fs_ptn_new, fs_ptn_factory, ptn_asciiz_new)) @{
    /* error */
  @}
@}
@{
  mmux_libc_dirfd_t  dirfd_old, dirfd_new;
  auto               flags = mmux_libc_linkat_flags(MMUX_LIBC_AT_SYMLINK_FOLLOW);

  mmux_libc_at_fdcwd(dirfd_old);
  mmux_libc_at_fdcwd(dirfd_new);
  if (mmux_libc_linkat(dirfd_old, fs_ptn_old,
                       dirfd_new, fs_ptn_new,
                       flags)) @{
    /* error */
  @}
@}
mmux_libc_unmake_file_system_pathname(fs_ptn_old);
mmux_libc_unmake_file_system_pathname(fs_ptn_new);
@end example
@end deftypefun


@deftypefun bool mmux_libc_linkfd (mmux_libc_fd_arg_t @var{fd_old}, mmux_libc_dirfd_arg_t @var{dirfd_new}, mmux_libc_fs_ptn_arg_t @var{newname}, mmux_sint_t @var{flags})
@MmuxCInterface{linkat}.  Link the file referenced by @var{fd_old} to the new pathname.

Notice that @samp{MMUX_LIBC_AT_EMPTY_PATH} is always added to @var{flags} with a bitwise OR
operation.

Notice that this function will fail test if the caller does not have the @code{CAP_DAC_READ_SEARCH}
capability @manpage{capabilities, Capabilities}.

@example
mmux_asciizcp_t     ptn_asciiz_old = "/path/to/oldfile.ext";
mmux_asciizcp_t     ptn_asciiz_new = "/path/to/newfile.ext";
mmux_libc_fd_t      fd_old;
mmux_libc_fs_ptn_t  fs_ptn_new;

@{
  mmux_libc_fs_ptn_t  fs_ptn_old;

  /* Create the file pathnames. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn_old, fs_ptn_factory, ptn_asciiz_old)) @{
      /* error */
    @}
    if (mmux_libc_make_file_system_pathname(fs_ptn_new, fs_ptn_factory, ptn_asciiz_new)) @{
      /* error */
    @}
  @}

  /* Open the old file. */
  @{
    auto    flags = mmux_libc_open_flags(MMUX_LIBC_O_PATH);
    auto    mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd_old, fs_ptn_old, flags, mode)) @{
      /* error */
    @}
  @}

  /* Intermediate cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn_old);
  @}
@}

/* Create the link. */
@{
  mmux_libc_dirfd_t  dirfd_new;
  auto               flags mmux_libc_linkat_flags(0);

  mmux_libc_at_fdcwd(dirfd_new);

  if (mmux_libc_linkfd(fd_old, dirfd_new, fs_ptn_new, flags)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd_old)) @{
    /* error */
  @}
  mmux_libc_unmake_file_system_pathname(fs_ptn_new);
@}
@end example
@end deftypefun

@c page
@node fs links symbolic
@subsection File system symbolic links


@cindex File system, symbolic links
@cindex Symbolic links, file system


@deftypefun bool mmux_libc_symlink (mmux_libc_fs_ptn_arg_t @var{oldname}, mmux_libc_fs_ptn_arg_t @var{newname})
@MmuxCInterface{symlink}.

@example
mmux_asciizcp_t     ptn_asciiz_src = "/path/to/srcfile.ext";
mmux_asciizcp_t     ptn_asciiz_dst = "/path/to/dst-symlink.ext";
mmux_libc_fs_ptn_t  fs_ptn_src, fs_ptn_dst;

@{
  mmux_libc_fs_ptn_factory_t        fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_src, fs_ptn_factory, ptn_asciiz_src)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname(fs_ptn_dst, fs_ptn_factory, ptn_asciiz_dst)) @{
    /* error */
  @}
@}

if (mmux_libc_symlink(fs_ptn_src, fs_ptn_dst)) @{
  /* error */
@}

mmux_libc_unmake_file_system_pathname(fs_ptn_src);
mmux_libc_unmake_file_system_pathname(fs_ptn_dst);
@end example
@end deftypefun


@deftypefun bool mmux_libc_symlinkat (mmux_libc_fs_ptn_arg_t @var{oldname}, mmux_libc_dirfd_arg_t @var{dirfd_new}, mmux_libc_fs_ptn_arg_t @var{newname})
@MmuxCInterface{symlinkat}.

@example
mmux_asciizcp_t     ptn_asciiz_src = "/path/to/srcfile.ext";
mmux_asciizcp_t     ptn_asciiz_dst = "/path/to/dst-symlink.ext";
mmux_libc_fs_ptn_t  fs_ptn_src, fs_ptn_dst;

@{
  mmux_libc_fs_ptn_factory_t        fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_src, fs_ptn_factory, ptn_asciiz_src)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname(fs_ptn_dst, fs_ptn_factory, ptn_asciiz_dst)) @{
    /* error */
  @}
@}

@{
  mmux_libc_dirfd_t  dirfd_dst;

  mmux_libc_at_fdcwd(dirfd_dst);
  if (mmux_libc_symlinkat(fs_ptn_src, dirfd_dst, fs_ptn_dst)) @{
    /* error */
  @}
@}

mmux_libc_unmake_file_system_pathname(fs_ptn_src);
mmux_libc_unmake_file_system_pathname(fs_ptn_dst);
@end example
@end deftypefun

@c page
@node fs links follow
@subsection Following file system symbolic links


@cindex File system, real pathnames
@cindex Real pathnames, file system


@menu
* fs links follow pathnames::   Follow file system links by pathname.
* fs links follow fds::         Follow file system links by file descriptor.
@end menu

@c page
@node fs links follow pathnames
@subsubsection Follow file system links by pathname


@deftypefun bool mmux_libc_readlink (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_t @var{fs_ptn_factory}, mmux_libc_fs_ptn_arg_t @var{fs_ptn_input_symbolic_link})
@MmuxCInterface{readlink}.

@example
mmux_asciizcp_t     ptn_symlink_asciiz = "/path/to/symlink.ext";
mmux_libc_fs_ptn_t  fs_ptn_symlink, fs_ptn_real;

/* Build the symbolic link pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_symlink, fs_ptn_factory, ptn_symlink_asciiz)) @{
    /* error */
  @}
@}

/* Retrieve the real pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_readlink(fs_ptn_real, fs_ptn_factory, fs_ptn_symlink)) @{
    /* error */
  @}
@}

@{
  /* Do something with "fs_ptn_real". */
@}

/* Final cleanup. */
@{
  mmux_unmake_file_system_pathname(fs_ptn_symlink);
  mmux_unmake_file_system_pathname(fs_ptn_real);
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_readlinkat (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_arg_t @var{fs_ptn_factory}, mmux_libc_dirfd_arg_t @var{dirfd_symlink}, mmux_libc_fs_ptn_arg_t @var{fs_ptn_input_symbolic_link})
@MmuxCInterface{readlinkat}.  Retrieve the real file system pathname of the symbolic link
@var{fs_ptn_input_symbolic_link} and store it in @var{fs_ptn_result}, using @var{fs_ptn_factory} to
build the new file system pathname object.

The file system pathname @var{fs_ptn_input_symbolic_link} is meant to be absolute or relative to
@var{dirfd_symlink}.

@example
mmux_asciizcp_t     ptn_symlink_asciiz = "/path/to/symlink.ext";
mmux_libc_fs_ptn_t  fs_ptn_symlink, fs_ptn_real;

/* Create the symbolic-link file-system-pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_symlink, fs_ptn_factory, ptn_symlink_asciiz)) @{
    /* error */
  @}
@}

/* Retrieve the real file-system-pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;
  mmux_libc_dirfd_t           dirfd_symlink;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  mmux_libc_at_fcwd(dirfd_symlink);
  if (mmux_libc_readlinkat(fs_ptn_real, fs_ptn_factory, dirfd_symlink, fs_ptn_symlink)) @{
    /* error */
  @}
@}

@{
  /* Do something with "fs_ptn_real". */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn_symlink);
  mmux_libc_unmake_file_system_pathname(fs_ptn_real);
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefn {@gnu{} Function} bool mmux_libc_canonicalize_file_name (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_t @var{fs_ptn_factory}, mmux_libc_fs_ptn_arg_t @var{fs_ptn_input})
@deftypefnx {@gnu{} Function} bool mmux_libc_canonicalise_file_name (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_t @var{fs_ptn_factory}, mmux_libc_fs_ptn_arg_t @var{fs_ptn_input})
@MmuxCInterface{canonicalize_file_name}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/../../file.ext";
mmux_libc_fs_ptn_t  fs_ptn, fs_ptn_canonicalised;

/* Build the original pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Canonicalise the pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_canonicalize_file_name(fs_ptn_canonicalised, fs_ptn_factory, fs_ptn)) @{
    /* error */
  @}
@}

@{
  /* Do something with the "fs_ptn_canonicalised". */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
  mmux_libc_unmake_file_system_pathname(fs_ptn_canonicalised);
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_realpath (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_t @var{fs_ptn_factory}, mmux_libc_fs_ptn_arg_t @var{fs_ptn_input})
@MmuxCInterface{realpath}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/../../file.ext";
mmux_libc_fs_ptn_t  fs_ptn, fs_ptn_real;;

/* Build the original file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Retrieve the real file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_realpath(fs_ptn_real, fs_ptn_factory, fs_ptn)) @{
    /* error */
  @}
@}

@{
  /* Do something with "fs_ptn_real". */
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
  mmux_libc_unmake_file_system_pathname(fs_ptn_real);
@}
@end example
@end deftypefun

@c page
@node fs links follow fds
@subsubsection Follow file system links by file descriptor


The following functions are wrappers for @cfunc{readlinkat}, @MmuxCFuncpage{readlinkat}.  They are
invoked in the special way supported by the latest Linux kernels: with the @MmuxAsciiZ{} string
representing the file system pathname set to the empty string.  This causes the file descriptor
argument to be meant to represent the link to follow through to the real file description.


@deftypefun bool mmux_libc_readlinkfd (mmux_libc_fs_ptn_t @var{fs_ptn_result}, mmux_libc_fs_ptn_factory_arg_t @var{fs_ptn_factory}, mmux_libc_fd_arg_t @var{fd_symlink})
@MmuxCInterface{readlinkat}.  Retrieve the real file system pathname of the symbolic link referenced
by @var{fd_symlink} and store it in @var{fs_ptn_result}, using @var{fs_ptn_factory} to build the new
file system pathname object.

@example
mmux_asciizcp_t     ptn_symlink_asciiz = "/path/to/symlink.ext";
mmux_libc_fd_t      fd_symlink;
mmux_libc_fs_ptn_t  fs_ptn_real;

/* Build the file descriptor associated to the symbolic link. */
@{
  mmux_libc_fs_ptn_t  fs_ptn_symlink;

  /* Build the symbolic-link file-system-pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    mmux_libc_make_file_system_pathname(fs_ptn_symlink, fs_ptn_factory, ptn_symlink_asciiz);
  @}

  /* Open the symbolic-link. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW);
    auto  mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd_symlink, fs_ptn_symlink, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn_symlink);
  @}
@}

/* Retrieve the real file-system-pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_factory_dynamic(fs_ptn_factory);
  if (mmux_libc_readlinkfd(fs_ptn_real, fs_ptn_factory, fd_symlink)) @{
    /* error */
  @}
@}

@{
  /* Do something with "fs_ptn_real". */
@}

/* Final cleanup. */
@{
  mmux_libc_close(fd_symlink);
  mmux_libc_unmake_file_system_pathname(fs_ptn_real);
@}
@end example
@end deftypefun

@c page
@node fs deleting
@section Deleting links


@deftypefun bool mmux_libc_unlink (mmux_libc_fs_ptn_arg_t @var{pathname})
@MmuxCInterface{unlink}.

@example
mmux_libc_fs_ptn_t fs_ptn;

@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, "/path/to/file.ext")) @{
    /* error */
  @}
@}

if (mmux_libc_unlink(fs_ptn)) @{
  /* error */
@}

mmux_libc_unmake_file_system_pathname(fs_ptn);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftp {Struct Typedef} mmux_libc_unlinkat_flags_t
Data structure representing a bitwise OR combination of flags for @cfunc{mmux_libc_unlinkat}.
@end deftp


@deftypefun mmux_libc_unlinkat_flags_t mmux_libc_unlinkat_flags (mmux_standard_sint_t @var{flags_num})
Build and return a new object of type @objtype{mmux_libc_unlinkat_flags_t}.
@end deftypefun


@deftypefun bool mmux_libc_unlinkat (mmux_libc_dirfd_arg_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_sint_t @var{flags})
@MmuxCInterface{unlinkat}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t        fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Unlink the file system pathname. */
@{
  mmux_libc_dirfd_t dirfd;
  auto              flags = mmux_libc_unlinkat_flags(0);

  mmux_libc_at_fdcwd(dirfd);
  if (mmux_libc_unlinkat(dirfd, fs_ptn, flags)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example

We can remove directories with this function:

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/directory.d";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t        fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Unlink the file system pathname. */
@{
  mmux_libc_dirfd_t dirfd;
  auto              flags = mmux_libc_unlinkat_flags(MMUX_LIBC_AT_REMOVEDIR);

  mmux_libc_at_fdcwd(dirfd);
  if (mmux_libc_unlinkat(dirfd, fs_ptn, flags)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_remove (mmux_libc_fs_ptn_arg_t @var{pathname})
@MmuxCInterface{remove}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/directory.d";
mmux_libc_fs_ptn_t  fs_ptn;

/* Built the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t        fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Remove the file. */
@{
  if (mmux_libc_remove(fs_ptn)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs renaming
@section Renaming links


@deftypefun bool mmux_libc_rename (mmux_libc_fs_ptn_arg_t @var{oldname}, mmux_libc_fs_ptn_arg_t @var{newname})
@MmuxCInterface{rename}.

@example
mmux_asciizcp_t     ptn_asciiz_src = "/path/to/srcfile.ext";
mmux_asciizcp_t     ptn_asciiz_dst = "/path/to/dstfile.ext";
mmux_libc_fs_ptn_t  fs_ptn_src, fs_ptn_dst;

/* Build the file system pathnames. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_src, fs_ptn_factory, ptn_asciiz_src)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname(fs_ptn_dst, fs_ptn_factory, ptn_asciiz_dst)) @{
    /* error */
  @}
@}

/* Rename the file. */
@{
  if (mmux_libc_rename(fs_ptn_src, fs_ptn_dst)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn_src);
  mmux_libc_unmake_file_system_pathname(fs_ptn_dst);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_renameat (mmux_libc_dirfd_arg_t @var{dirfd_old}, mmux_libc_fs_ptn_arg_t @var{fs_ptn_old}, mmux_libc_dirfd_arg_t @var{dirfd_new}, mmux_libc_fs_ptn_arg_t @var{fs_ptn_new})
@MmuxCInterface{renameat}.

@example
mmux_asciizcp_t     ptn_asciiz_src = "/path/to/srcfile.ext";
mmux_asciizcp_t     ptn_asciiz_dst = "/path/to/dstfile.ext";
mmux_libc_fs_ptn_t  fs_ptn_src, fs_ptn_dst;

/* Build the file system pathnames. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_src, fs_ptn_factory, ptn_asciiz_src)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname(fs_ptn_dst, fs_ptn_factory, ptn_asciiz_dst)) @{
    /* error */
  @}
@}

/* Rename the file. */
@{
  mmux_libc_dirfd_t fd;

  mmux_libc_at_fdcwd(fd);
  if (mmux_libc_renameat(fd, fs_ptn_src, fd, fs_ptn_dst)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn_src);
  mmux_libc_unmake_file_system_pathname(fs_ptn_dst);
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftp {Struct Type} mmux_libc_renameat2_flags_t
Data structure representing a bitwise OR combination of flags to be used in calls to
@cfunc{mmux_libc_renameat2}.
@end deftp


@deftypefun mmux_libc_renameat2_flags_t mmux_libc_renameat2_flags (mmux_standard_sint_t @var{flags_num})
Build and return a new instance of @objtype{mmux_libc_renameat2_t}.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_renameat2 (mmux_libc_dirfd_arg_t @var{dirfd_old}, mmux_libc_fs_ptn_arg_t @var{fs_ptn_old}, mmux_libc_dirfd_arg_t @var{dirfd_new}, mmux_libc_fs_ptn_arg_t @var{fs_ptn_new}, mmux_libc_renameat2_flags_t @var{flags})
@MmuxCInterface{renameat2}.

@example
mmux_libc_fs_ptn_t  fs_ptn_src, fs_ptn_dst;

/* Build the file system pathnames. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_src, fs_ptn_factory, ptn_asciiz_src)) @{
    /* error */
  @}
  if (mmux_libc_make_file_system_pathname(fs_ptn_dst, fs_ptn_factory, ptn_asciiz_dst)) @{
    /* error */
  @}
@}

/* Rename the file. */
@{
  mmux_libc_dirfd_t  dirfd;
  auto  flags = mmux_libc_renameat2_flags(MMUX_LIBC_RENAME_NOREPLACE);

  mmux_libc_at_fdcwd(dirfd);
  if (mmux_libc_renameat2(dirfd, fs_ptn_src, dirfd, fs_ptn_dst, flags)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn_src);
  mmux_libc_unmake_file_system_pathname(fs_ptn_dst);
@}
@end example
@end deftypefn

@c page
@node fs ownership
@section File ownership


@deftypefun bool mmux_libc_chown (mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid})
@MmuxCInterfaceGlibc{chown, File Owner}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;
mmux_libc_uid_t	    uid;
mmux_libc_gid_t	    gid;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t    fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Acquire UID and GID. */
@{
  mmux_asciizcp_t       name;
  mmux_libc_passwd_t *  PW;

  if (mmux_libc_getlogin(&name)) @{
    /* error */
  @}
  if (mmux_libc_getpwnam(&PW, name)) @{
    /* error */
  @}
  mmux_libc_pw_uid_ref(&uid, PW);
  mmux_libc_pw_gid_ref(&gid, PW);
@}

/* Do it. */
@{
  if (mmux_libc_chown(fs_ptn, uid, gid)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_fchown (mmux_libc_fs_arg_t @var{fd}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid})
@MmuxCInterfaceGlibc{fchown, File Owner}.

@example
mmux_asciizcp_t  ptn_asciiz = "/path/to/file.ext";
mmux_libc_fd_t   fd;
mmux_libc_uid_t  uid;
mmux_libc_gid_t  gid;

/* Acquire the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the file. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_RDWR);
    auto  mode  = mmux_libc_mode(MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Acquire UID and GID. */
@{
  mmux_asciizcp_t       name;
  mmux_libc_passwd_t *  PW;

  if (mmux_libc_getlogin(&name)) @{
    /* error */
  @}
  if (mmux_libc_getpwnam(&PW, name)) @{
    /* error */
  @}
  mmux_libc_pw_uid_ref(&uid, PW);
  mmux_libc_pw_gid_ref(&gid, PW);
@}

/* Do it. */
@{
  if (mmux_libc_fchown(fd, uid, gid)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_lchown (mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{lchown}.  This function is like @cfunc{mmux_libc_chown} but it does not dereference
symbolic links.
@end deftypefun

@c ------------------------------------------------------------------------

@deftp {Struct Typedef} mmux_libc_fchownat_flags_t
Data structure type representing a bitwise OR combination of flags for calls to
@cfunc{mmux_libc_fchownat}.
@end deftp


@deftypefun mmux_libc_fchownat_flags_t mmux_libc_fchownat_flags (mmux_standard_sint_t @var{flags_num})
Build and return an instance of @objtype{mmux_libc_fchownat_flags_t}.
@end deftypefun


@deftypefun bool mmux_libc_fchownat (mmux_libc_dirfd_arg_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid}, mmux_libc_fchownat_flags_t flags)
@MmuxCInterface{fchownat}.

@example
mmux_libc_fs_ptn_t  fs_ptn;
mmux_libc_uid_t     uid;
mmux_libc_gid_t     gid;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Acquire UID and GID. */
@{
  mmux_asciizcp_t           name;
  mmux_libc_passwd_t *      PW;

  if (mmux_libc_getlogin(&name)) @{
    /* error */
  @}
  if (mmux_libc_getpwnam(&PW, name)) @{
    /* error */
  @}
  mmux_libc_pw_uid_ref(&uid, PW);
  mmux_libc_pw_gid_ref(&gid, PW);
@}

/* Do it. */
@{
  mmux_libc_dirfd_t  dirfd;
  auto               flags = mmux_libc_fchownat_flags(MMUX_LIBC_AT_SYMLINK_NOFOLLOW);

  mmux_libc_at_fdcwd(dirfd);
  if (mmux_libc_fchownat(dirfd, fs_ptn, uid, gid, flags)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftp {Struct Typedef} mmux_libc_chownfd_flags_t
Data structure type representing a bitwise OR combination of flags for calls to
@cfunc{mmux_libc_chownfd}.
@end deftp


@deftypefun mmux_libc_chownfd_flags_t mmux_libc_chownfd_flags (mmux_standard_sint_t @var{flags_num})
Build and return an instance of @objtype{mmux_libc_chownfd_flags_t}.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_chownfd (mmux_libc_fs_arg_t @var{fd}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid}, mmux_sint_t @var{flags})
@MmuxCInterface{fchownat}.  Notice that this function always adds @code{MMUX_LIBC_AT_EMPTY_PATH} to
@var{flags}, so it operates on @var{fd}.

@example
mmux_libc_fd_t   fd;
mmux_libc_uid_t  uid;
mmux_libc_gid_t  gid;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the file. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW);
    auto  mode  = mmux_libc_mode(MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Acquire UID and GID. */
@{
  mmux_asciizcp_t       name;
  mmux_libc_passwd_t *  PW;

  if (mmux_libc_getlogin(&name)) @{
    /* error */
  @}
  if (mmux_libc_getpwnam(&PW, name)) @{
    /* error */
  @}
  mmux_libc_pw_uid_ref(&uid, PW);
  mmux_libc_pw_gid_ref(&gid, PW);
@}

/* Do it. */
@{
  auto  flags = mmux_libc_chownfd_flags(MMUX_LIBC_AT_SYMLINK_NOFOLLOW);

  if (mmux_libc_chownfd(fd, uid, gid, flags)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fs permissions
@section File access permissions


@menu
* fs permissions umask::        File creation masks.
* fs permissions change::       Changing file permissions.
* fs permissions access::       Accessing file permissions.
@end menu

@c page
@node fs permissions umask
@subsection File creation masks


@deftypefun bool mmux_libc_umask (mmux_libc_mode_t * @var{old_mask_p}, mmux_libc_mode_t @var{new_mask})
@MmuxCInterfaceGlibc{umask, Setting Permissions}.

@example
mmux_libc_mode_t  old_mask, new_mask = mmux_libc_mode_literal(0755);

mmux_libc_umask(&old_mask, new_mask);
@end example
@end deftypefun


@deftypefun bool mmux_libc_getumask (mmux_libc_mode_t * @var{current_mask_p})
Store the current mask in the location referenced by @var{current_mask_p}.  Do not change the
current mask.

@example
mmux_libc_mode_t  cur_mask;

mmux_libc_getumask(&cur_mask);
@end example
@end deftypefun

@c page
@node fs permissions change
@subsection Changing file permissions


@menu
* fs permissions change chmod::     Changing file permissions with @cfunc{mmux_libc_chmod}.
* fs permissions change fchmod::    Changing file permissions with @cfunc{mmux_libc_fchmod}.
* fs permissions change fchmodat::  Changing file permissions with @cfunc{mmux_libc_fchmodat}.
@end menu

@c page
@node fs permissions change chmod
@subsubsection Changing file permissions with @cfunc{mmux_libc_chmod}


@deftypefun bool mmux_libc_chmod (mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_mode_t @var{mode})
@MmuxCInterfaceGlibc{chmod, Setting Permissions}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Change the mode. */
@{
  auto  mode = mmux_libc_mode_literal(0755);

  if (mmux_libc_chmod(fs_ptn, mode)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs permissions change fchmod
@subsubsection Changing file permissions with @cfunc{mmux_libc_fchmod}


@deftypefun bool mmux_libc_fchmod (mmux_libc_fd_arg_t @var{fd}, mmux_libc_mode_t @var{mode})
@MmuxCInterfaceGlibc{fchmod, Setting Permissions}.

@example
mmux_asciizcp_t  ptn_asciiz = "/path/to/file.ext";
mmux_libc_fd_t   fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the file. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_RDWR);
    auto  mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Do it. */
@{
  auto  mode = mmux_libc_mode_literal(0755);

  if (mmux_libc_fchmod(fd, mode)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs permissions change fchmodat
@subsubsection Changing file permissions with @cfunc{mmux_libc_fchmodat}


@deftp {Struct Typedef} mmux_libc_fchmodat_flags_t
Data structure type representing a bitwise OR combination of flags to be used in calls to
@cfunc{mmux_libc_fchmodat}.
@end deftp


@deftypefun mmux_libc_fchmodat_flags_t mmux_libc_fchmodat_flags (mmux_standard_sint_t @var{flags_num})
Build and return a new instance of @objtype{mmux_libc_fchmodat_flags_t}.
@end deftypefun


@deftypefun bool mmux_libc_fchmodat (mmux_libc_fd_arg_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_mode_t @var{mode}, mmux_libc_fchmodat_flags_t @var{flags})
@MmuxCInterface{fchmodat}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_dirfd_t  dirfd;
  auto  mode  = mmux_libc_mode_literal(0755);
  auto  flags = mmux_libc_fchmodat_flags(MMUX_LIBC_AT_SYMLINK_NOFOLLOW);

  mmux_libc_at_fdcwd(dirfd);
  if (mmux_libc_fchmodat(dirfd, fs_ptn, mode, flags)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs permissions access
@subsection Accessing file permissions


@menu
* fs permissions access access::      Accessing file permissions with @cfunc{mmux_libc_access}.
* fs permissions access faccessat::   Accessing file permissions with @cfunc{mmux_libc_faccessat}.
* fs permissions access faccessat2::  Accessing file permissions with @cfunc{mmux_libc_faccessat2}.
@end menu

@c page
@node fs permissions access access
@subsubsection Accessing file permissions with @cfunc{mmux_libc_access}


@deftp {Struct Type} mmux_libc_access_how_t
Data structure type representing a bitwise OR combination of access modes for calls to
@cfunc{mmux_libc_access}, @cfunc{mmux_libc_faccessat}, @cfunc{mmux_libc_faccessat2}.
@end deftp


@deftypefun mmux_libc_access_how_t mmux_libc_access_how (mmux_standard_sint_t @var{how_num})
Build and return an instance of @objtype{mmux_libc_access_how_t}.
@end deftypefun


@deftypefun bool mmux_libc_access (bool * @var{access_is_permitted_p}, mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_access_how_t @var{how})
@MmuxCInterfaceGlibc{access, Testing File Access}.  When successful the access mode specified by
@var{how} could be permitted or denied:

@itemize
@item
if the requested access is permitted: the variable referenced by @var{access_is_permitted_p} is set
to @ctrue{};

@item
if the requested access is denied: the variable referenced by @var{access_is_permitted_p} is set to
@cfalse{}.
@end itemize

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  auto  how = mmux_libc_access_how(MMUX_LIBC_F_OK | MMUX_LIBC_R_OK | MMUX_LIBC_W_OK);
  bool  access_is_permitted;

  if (mmux_libc_access(&access_is_permitted, fs_ptn, how)) @{
    /* error */
  @} else if (access_is_permitted) @{
    /* do something */
  @} else @{
    /* do something else */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs permissions access faccessat
@subsubsection Accessing file permissions with @cfunc{mmux_libc_faccessat}


@deftp {Struct Type} mmux_libc_faccessat_flags_t
Data structure type representing a bitwise OR combination of flags for calls to
@cfunc{mmux_libc_faccessat} and @cfunc{mmux_libc_faccessat2}.
@end deftp


@deftypefun mmux_libc_faccessat_flags_t mmux_libc_faccessat_flags (mmux_standard_sint_t @var{how_num})
Build and return an instance of @objtype{mmux_libc_faccessat_flags_t}.
@end deftypefun


@deftypefun bool mmux_libc_faccessat (bool * @var{access_is_permitted_p}, mmux_libc_dirfd_arg_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_access_how_t @var{how}, mmux_libc_faccessat_flags_t @var{flags})
@MmuxCInterface{faccessat}.  When successful the access mode specified by
@var{how} could be permitted or denied:

@itemize
@item
if the requested access is permitted: the variable referenced by @var{access_is_permitted_p} is set
to @ctrue{};

@item
if the requested access is denied: the variable referenced by @var{access_is_permitted_p} is set to
@cfalse{}.
@end itemize

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t        fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_dirfd_t dirfd;
  auto  how   = mmux_libc_access_how(MMUX_LIBC_F_OK | MMUX_LIBC_R_OK | MMUX_LIBC_W_OK);
  auto  flags = mmux_libc_faccessat_flags(MMUX_LIBC_AT_SYMLINK_NOFOLLOW);
  bool  access_is_permitted;

  mmux_libc_at_fdcwd(dirfd);
  if (mmux_libc_faccessat(&access_is_permitted, dirfd, fs_ptn, how, flags)) @{
    /* error */
  @} else if (access_is_permitted) @{
    /* do something else */
  @} else @{
    /* do something else */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs permissions access faccessat2
@subsubsection Accessing file permissions with @cfunc{mmux_libc_faccessat2}


@deftypefn {Linux Function} bool mmux_libc_faccessat2 (bool * @var{access_is_permitted_p}, mmux_libc_dirfd_arg_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_access_how_t @var{how}, mmux_libc_faccessat_flags_t @var{flags})
@MmuxCInterface{faccessat2}.  When successful the access mode specified by @var{how} could be
permitted or denied:

@itemize
@item
if the requested access is permitted: the variable referenced by @var{access_is_permitted_p} is set
to @ctrue{};

@item
if the requested access is denied: the variable referenced by @var{access_is_permitted_p} is set to
@cfalse{}.
@end itemize

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_dirfd_t dirfd;
  auto  how   = mmux_libc_access_how(MMUX_LIBC_F_OK | MMUX_LIBC_R_OK | MMUX_LIBC_W_OK);
  auto  flags = mmux_libc_faccessat_flags(MMUX_LIBC_AT_SYMLINK_NOFOLLOW);
  bool  access_is_permitted;

  mmux_libc_at_fdcwd(dirfd);
  if (mmux_libc_faccessat2(&access_is_permitted, dirfd, fs_ptn, how, flags)) @{
    /* error */
  @} else if (access_is_permitted) @{
    /* do something else */
  @} else @{
    /* do something else */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefn

@c page
@node fs attributes
@section File attributes


@menu
* fs attributes types::         The @objtype{mmux_libc_stat_t} data type.
* fs attributes inspection::    Inspecting file attributes.
* fs attributes mode::          Inspecting the mode field of @objtype{mmux_libc_file_system_stat_t}.
* fs attributes stat::          Inspecting the whole @objtype{mmux_libc_file_system_stat_t}.
* fs attributes predicates::    File system pathname predicates.
* fs attributes fields::        Fields inspection functions.
@end menu

@c page
@node fs attributes types
@subsection The @objtype{mmux_libc_stat_t} data type


The standard @cfunc{stat} function and its variants inspect the file system to retrieve most of the
informations associated to a directory entry; the informations are stored in data structures of type
@objtype{mmux_libc_file_system_stat_t}.  The core function is @cfunc{mmux_libc_stat}, which we can
use as follows:

Usually we declare a local variable of type @objtype{mmux_libc_stat_t} which is a 1--element array
of instances of @objtype{mmux_libc_file_system_stat_t}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

@{
  mmux_libc_stat_t  stat;

  if (mmux_libc_stat(stat, fs_ptn)) @{
    /* error */
  @} else @{
    mmux_libc_fd_t  fd;

    mmux_libc_stder(fd);
    if (mmux_libc_stat_dump(fd, stat, NULL)) @{
      /* error */
    @}
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example

@noindent
this code prints something like:

@example
struct stat = 0x7ffd58c7b320
struct stat->st_mode = 33152 (regular file)
struct stat->st_ino = 4069062
struct stat->st_dev = 66316
struct stat->st_nlink = 1
struct stat->st_ino = 4069062
struct stat->st_uid = 1000
struct stat->st_gid = 1000
struct stat->st_size = 41
struct stat->st_atime_sec = 1752688262 (2025-07-16T17:51:02+0000)
struct stat->st_atime_nsec = 74991584
struct stat->st_mtime_sec = 1752688262 (2025-07-16T17:51:02+0000)
struct stat->st_mtime_nsec = 74991584
struct stat->st_ctime_sec = 1752688262 (2025-07-16T17:51:02+0000)
struct stat->st_ctime_nsec = 74991584
struct stat->st_blocks = 8
struct stat->st_blksize = 4096
@end example


@MmuxCStructOpaqueTypedef{file_system_stat}
@MmuxSetterGetter{file_system_stat,     st_mode,        mmux_libc_mode_t}
@MmuxSetterGetter{file_system_stat,	st_ino,		mmux_libc_ino_t}
@MmuxSetterGetter{file_system_stat,	st_dev,		mmux_libc_dev_t}
@MmuxSetterGetter{file_system_stat,	st_nlink,	mmux_libc_nlink_t}
@MmuxSetterGetter{file_system_stat,	st_uid,		mmux_libc_uid_t}
@MmuxSetterGetter{file_system_stat,	st_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{file_system_stat,	st_size,	mmux_off_t}
@MmuxSetterGetter{file_system_stat,	st_atime_sec,	mmux_time_t}
@MmuxSetterGetter{file_system_stat,	st_atime_nsec,	mmux_slong_t}
@MmuxSetterGetter{file_system_stat,	st_mtime_sec,	mmux_time_t}
@MmuxSetterGetter{file_system_stat,	st_mtime_nsec,	mmux_slong_t}
@MmuxSetterGetter{file_system_stat,	st_ctime_sec,	mmux_time_t}
@MmuxSetterGetter{file_system_stat,	st_ctime_nsec,	mmux_slong_t}
@MmuxSetterGetter{file_system_stat,	st_blocks,	mmux_libc_blkcnt_t}
@MmuxSetterGetter{file_system_stat,	st_blksize,	mmux_uint_t}
@MmuxStructDumper{file_system_stat}


@deftp {Array Type} mmux_libc_stat_t
Array type defined as:

@example
typedef struct mmux_libc_file_system_stat_t  mmux_libc_stat_t[1];
@end example
@end deftp


@deftp {Pointer Type} mmux_libc_stat_arg_t
Pointer type defined as:

@example
typedef struct mmux_libc_file_system_stat_t const *  mmux_libc_stat_arg_t;
@end example
@end deftp

@c page
@node fs attributes inspection
@subsection Inspecting file attributes


@menu
* fs attributes inspection stat::     Inspecting file attributes with @cfunc{mmux_libc_stat}.
* fs attributes inspection fstat::    Inspecting file attributes with @cfunc{mmux_libc_fstat}.
* fs attributes inspection lstat::    Inspecting file attributes with @cfunc{mmux_libc_lstat}.
* fs attributes inspection fstatat::  Inspecting file attributes with @cfunc{mmux_libc_fstatat}.
* fs attributes inspection statfd::   Inspecting file attributes with @cfunc{mmux_libc_statfd}.
@end menu

@c page
@node fs attributes inspection stat
@subsubsection Inspecting file attributes with @cfunc{mmux_libc_stat}


@deftypefun bool mmux_libc_stat (mmux_libc_stat_t @var{stat_result}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
@MmuxCInterface{stat}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_stat_t  stat;

  if (mmux_libc_stat(stat, fs_ptn)) @{
    /* error */
  @} else @{
    /* Do something with "stat". */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs attributes inspection fstat
@subsubsection Inspecting file attributes with @cfunc{mmux_libc_fstat}


@deftypefun bool mmux_libc_fstat (mmux_libc_stat_t @var{stat_result}, mmux_libc_fd_arg_t @var{fd})
@MmuxCInterface{fstat}.

@example
mmux_asciizcp_t  ptn_asciiz = "/path/to/file.ext";
mmux_libc_fd_t   fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the data file. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW);
    auto  mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Do it. */
@{
  mmux_libc_stat_t  stat;

  if (mmux_libc_fstat(stat, fd)) @{
    /* error */
  @} else @{
    /* Do something with "stat". */
  @}
@}

/* Final cleanup */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs attributes inspection lstat
@subsubsection Inspecting file attributes with @cfunc{mmux_libc_lstat}


@deftypefun bool mmux_libc_lstat (mmux_libc_stat_t @var{stat_result}, mmux_libc_fs_ptn_arg_t @var{fs_ptn})
@MmuxCInterface{lstat}.

@example
mmux_asciizcp_t     ptn_asciiz_symlink = "/path/to/symlink.ext";
mmux_libc_fs_ptn_t  fs_ptn_symlink;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn_symlink, fs_ptn_factory, ptn_asciiz_symlink)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_stat_t  stat;

  if (mmux_libc_lstat(stat, fs_ptn_symlink)) @{
    /* error */
  @} else @{
    /* Do something with "stat". */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn_symlink);
@}
@end example
@end deftypefun

@c page
@node fs attributes inspection fstatat
@subsubsection Inspecting file attributes with @cfunc{mmux_libc_fstatat}


@deftp {Struct Type} mmux_libc_fstatat_flags_t
Data structure type representing a bitwise OR combination of flags for call to @cfunc{mmux_libc_fstatat}.
@end deftp


@deftypefun mmux_libc_fstatat_flags_t mmux_libc_fstatat_flags (mmux_standard_sint_t @var{flags_num})
Build and return a new instance of @objtype{mmux_libc_fstatat_flags_t}.
@end deftypefun


@deftypefun bool mmux_libc_fstatat (mmux_libc_stat_t @var{stat_result}, mmux_libc_fd_arg_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_fstatat_flags_t @var{flags})
@MmuxCInterface{fstatat}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_dirfd_t  dirfd;
  auto               flags = mmux_libc_fstatat_flags(MMUX_LIBC_AT_SYMLINK_NOFOLLOW);
  mmux_libc_stat_t   stat;

  mmux_libc_at_fdcwd(dirfd);
  if (mmux_libc_fstatat(stat, dirfd, fs_ptn, flags)) @{
    /* error */
  @} else @{
    /* Do something with "stat". */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs attributes inspection statfd
@subsubsection Inspecting file attributes with @cfunc{mmux_libc_statfd}


@deftp {Struct Type} mmux_libc_statfd_flags_t
Data structure type representing a bitwise OR combination of flags for call to @cfunc{mmux_libc_statfd}.
@end deftp


@deftypefun mmux_libc_statfd_flags_t mmux_libc_statfd_flags (mmux_standard_sint_t @var{flags_num})
Build and return a new instance of @objtype{mmux_libc_statfd_flags_t}.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_statfd (mmux_libc_stat_t @var{stat_result}, mmux_libc_fd_arg_t @var{fd}, mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_statfd_flags_t @var{flags})
@MmuxCInterface{fstatat}.  This function invokes @cfunc{fstatat} with an empty file system pathname
and adding @samp{MMUX_LIBC_AT_EMPTY_PATH} to the @var{flags} argument; this causes the function to
operate on the file descriptor @var{fd}.

To inspect the attributes of a regular file we do:

@example
mmux_asciizcp_t  ptn_asciiz = "/path/to/file.ext";
mmux_libc_fd_t   fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t        fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t      fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the data file. */
  @{
    auto    flags = mmux_libc_open_flags(MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW);
    auto    mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Do it. */
@{
  mmux_libc_stat_t  stat;
  auto              flags = mmux_libc_statfd_flags(MMUX_LIBC_AT_SYMLINK_NOFOLLOW);

  if (mmux_libc_statfd(stat, fd, flags)) @{
    /* error */
  @} else @{
    /* Do something with "stat". */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example

To inspect the attributes of a directory we do:

@example
mmux_libc_dirfd_t  dirfd;
mmux_libc_stat_t   stat;
auto               flags = mmux_libc_statfd_flags(0);

mmux_libc_at_fdcwd(dirfd);
if (mmux_libc_statfd(stat, dirfd, flags)) @{
  /* error */
@} else @{
  /* Do something with "stat". */
@}
@end example
@end deftypefn

@c page
@node fs attributes mode
@subsection Inspecting the mode field of @objtype{mmux_libc_file_system_stat_t}


To inspect the field @code{st_mode} of @objtype{mmux_libc_file_system_stat_t} we do:

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_stat_t  stat;

  if (mmux_libc_stat(stat, fs_ptn)) @{
    /* error */
  @} else @{
    mmux_libc_mode_t  st_mode;

    mmux_libc_st_mode_ref(&st_mode, stat);

    /* S_ISDIR */
    @{
      bool        result;

      if (mmux_libc_S_ISDIR(&result, st_mode)) @{
        /* Error, should not happen. */
      @} else if (result) @{
        /* The file system pathname references a directory. */
      @} else @{
        /* The file system pathname DOES NOT reference a directory. */
      @}
    @}
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example


@deftypefun bool mmux_libc_S_ISDIR (bool * @var{result_p}, mmux_libc_mode_t @var{mode})
@MmuxCInterface{S_ISDIR}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISCHR (bool * @var{result_p}, mmux_libc_mode_t @var{mode})
@MmuxCInterface{S_ISCHR}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISBLK (bool * @var{result_p}, mmux_libc_mode_t @var{mode})
@MmuxCInterface{S_ISBLK}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISREG (bool * @var{result_p}, mmux_libc_mode_t @var{mode})
@MmuxCInterface{S_ISREG}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISFIFO (bool * @var{result_p}, mmux_libc_mode_t @var{mode})
@MmuxCInterface{S_ISFIFO}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISLNK (bool * @var{result_p}, mmux_libc_mode_t @var{mode})
@MmuxCInterface{S_ISLNK}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISSOCK (bool * @var{result_p}, mmux_libc_mode_t @var{mode})
@MmuxCInterface{S_ISSOCK}.
@end deftypefun

@c page
@node fs attributes stat
@subsection Inspecting the whole @objtype{mmux_libc_file_system_stat_t}


To inspect the whole @objtype{mmux_libc_file_system_stat_t} objects we do:

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_stat_t  stat;

  if (mmux_libc_stat(stat, fs_ptn)) @{
    /* error */
  @} else @{

    /* S_TYPEISMQ */
    @{
      bool        result;

      if (mmux_libc_S_TYPEISMQ(&result, stat)) @{
        /* Error, should not happen. */
      @} else if (result) @{
        /* The file system pathname references a POSIX message queue. */
      @} else @{
        /* The file system pathname DOES NOT reference a POSIX message queue. */
      @}
    @}

  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example


@deftypefun bool mmux_libc_S_TYPEISMQ (bool * @var{result_p}, mmux_libc_stat_arg_t @var{stat})
@MmuxCInterface{S_TYPESIMQ}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISSEM (bool * @var{result_p}, mmux_libc_stat_arg_t @var{stat})
@MmuxCInterface{S_TYPEISSEM}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISSHM (bool * @var{result_p}, mmux_libc_stat_arg_t @var{stat})
@MmuxCInterface{S_TYPEISSHM}.
@end deftypefun

@c page
@node fs attributes predicates
@subsection File system pathname predicates


For all the following functions: the test is performed using @cfunc{mmux_libc_lstat}, so the
pathname itself is inspected without following symbolic links.

To use the following predicates we do:

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Test for file system pathname existence as a directory entry. */
@{
  bool  result;

  if (mmux_libc_file_system_pathname_exists(&result, fs_ptn)) @{
    /* error */
  @} else if (result) @{
    /* it exists */
  @} else @{
    /* it does not exist */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example


@deftypefun bool mmux_libc_file_system_pathname_exists (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_regular (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a regular file; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_symlink (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a symbolic link; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_directory (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a directory; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_character_special (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_block_special (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a block special device; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_fifo (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a FIFO; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_socket (bool * @var{result_p}, mmux_libc_fs_ptn_arg_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a socket; otherwise store @cfalse{}.
@end deftypefun

@c page
@node fs attributes fields
@subsection Attribute inspection functions


The functions documented in this section retrieve the value of some fields from
@objtype{mmux_libc_file_system_stat_t} objects embedding the call to the standard @cfunc{stat}
function and its variants; true control about the resulting values is possible only by explicitly
selecting which @cfunc{stat} variant to call and which arguments to use in the function invocation.
But the following functions are simpler and sometimes they are enough.


@deftypefun bool mmux_libc_file_system_pathname_file_size_ref (mmux_usize_t * @var{result_p}, mmux_libc_fd_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{ptn})
Invoke @cfunc{mmux_libc_fstatat} (with flags set to zero) and retrieve the @code{st_size} field
value of the resulting @objtype{mmux_libc_file_system_stat_t}.  Store such field value in the
variable referenced by @var{result_p}, casting the @objtype{mmux_off_t} value to
@objtype{mmux_usize_t}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t        fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Retrieve the file size. */
@{
  mmux_usize_t       st_size;
  mmux_libc_dirfd_t  dirfd;

  mmux_libc_at_fdcwd(dirfd);
  if (mmux_libc_file_system_pathname_file_size_ref(&st_size, dirfd, fs_ptn)) @{
    /* error */
  @} else @{
    /* Do something with "st_size". */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_file_size_ref (mmux_usize_t * @var{result_p}, mmux_libc_fd_arg_t @var{fd})
Invoke @cfunc{mmux_libc_statfd} (with flags set to zero) and retrieve the @code{st_size} field value
of the resulting @objtype{mmux_libc_file_system_stat_t}.  Store such field value in the variable
referenced by @var{result_p}, casting the @objtype{mmux_off_t} value to @objtype{mmux_usize_t}.

@example
mmux_asciizcp_t  ptn_asciiz = "/path/to/file.ext";
mmux_libc_fd_t   fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the file. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW);
    auto  mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Retrieve the file size. */
@{
  mmux_usize_t  st_size;

  if (mmux_libc_file_descriptor_file_size_ref(&st_size, fd)) @{
    /* error */
  @} else @{
    /* Do something with "st_size". */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    handle_error();
  @}
@}
@end example
@end deftypefun

@c page
@node fs truncating
@section Truncating files


@deftypefun bool mmux_libc_truncate (mmux_libc_fs_ptn_arg_t pathname, mmux_off_t len)
@MmuxCInterface{truncate}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  auto  len = mmux_off_literal(10);

  if (mmux_libc_truncate(fs_ptn, len)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_ftruncate (mmux_libc_file_descriptor_t fd, mmux_off_t len)
@MmuxCInterface{ftruncate}.

@example
mmux_libc_fd_t  fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the file. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_RDWR);
    auto  mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Do it. */
@{
  auto  len = mmux_off_literal(10);

  if (mmux_libc_ftruncate(fd, len)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs times
@section File system times


@menu
* fs times utimbuf::            Data structures of type @objtype{mmux_libc_utimbuf_t}.
* fs times setting::            Setting the file system times associated to files.
@end menu

@c page
@node fs times utimbuf
@subsection Data structures of type @objtype{mmux_libc_utimbuf_t}


In the @posix{} C language library: the data structure type @objtype{struct utimbuf} is used to set
new access and modification times for a directory entry.  Under @value{PACKAGE}: the same data
structure type is represented by @objtype{mmux_file_system_utimbuf_t}.

If we want to toy with a @objtype{mmux_file_system_utimbuf_t} objects, we do:

@example
mmux_libc_utimbuf_t  utimbuf;
mmux_time_t          T1, T2;

mmux_libc_time(&T1);
mmux_libc_time(&T2);

mmux_libc_actime_set  (utimbuf, T1);
mmux_libc_modtime_set (utimbuf, T2);

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(fd);
  if (mmux_libc_utimbuf_dump(fd, utimbuf, NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
which will print something like:

@example
struct utimbuf = 0x7ffe965b02e0
struct utimbuf->st_actime  = 1761546147 (2025-10-27T06:22:27+0000)
struct utimbuf->st_modtime = 1761546147 (2025-10-27T06:22:27+0000)
@end example


@deftp {Opaque Struct Typedef} mmux_libc_file_system_utimbuf_t
An opaque alias for @MmuxCStruct{utimbuf}.
@end deftp

@deftp {Opaque Struct Pointer Typedef} mmux_libc_utimbuf_t
Type definition for the 1--element array defined as:

@example
typedef mmux_libc_file_system_utimbuf_t  mmux_libc_utimbuf_t[1];
@end example
@end deftp


@deftp {Opaque Struct Pointer Typedef} mmux_libc_utimbuf_arg_t
Type definition for a pointer to constant data structure defined as:

@example
typedef mmux_libc_file_system_utimbuf_t const *  mmux_libc_utimbuf_arg_t;
@end example

@noindent
which is meat to be used as type of argument to functions.
@end deftp


@deftypefun bool mmux_libc_actime_set (mmux_libc_utimbuf_t @var{utimbuf_p}, mmux_time_t @var{actime})
@deftypefunx bool mmux_libc_actime_ref (mmux_time_t * @var{result_p}, mmux_libc_utimbuf_arg_t @var{utimbuf_p})
Setter and getter for the field @code{actime} of @objtype{mmux_libc_file_system_utimbuf_t}.
@end deftypefun


@deftypefun bool mmux_libc_modtime_set (mmux_libc_utimbuf_t @var{utimbuf_p}, mmux_time_t @var{modtime})
@deftypefunx bool mmux_libc_modtime_ref (mmux_time_t * @var{result_p}, mmux_libc_utimbuf_arg_t @var{utimbuf_p})
Setter and getter for the field @code{modtime} of @objtype{mmux_libc_file_system_utimbuf_t}.
@end deftypefun


@deftypefun bool mmux_libc_utimbuf_dump (mmux_libc_fd_arg_t @var{fd}, mmux_libc_utimbuf_arg_t @var{utimbuf_p}, mmux_asciizcp_t @var{struct_name})
Write to @var{fd} a description of the fields of the object
@objtype{mmux_libc_file_system_utimbuf_t} referenced by @var{utimbuf_p}.  @var{struct_name} must be
a pointer to an @MmuxAsciiZ{} string representing the name of the data structure used in the
description; when @cnull{} it defaults to @samp{struct utimbuf}.
@end deftypefun

@c page
@node fs times setting
@subsection Setting the file system times associated to files


@menu
* fs times setting utime::      Setting file system times with @cfunc{mmux_libc_utime}.
* fs times setting utimes::     Setting file system times with @cfunc{mmux_libc_utimes}.
* fs times setting lutimes::    Setting file system times with @cfunc{mmux_libc_lutimes}.
* fs times setting futimes::    Setting file system times with @cfunc{mmux_libc_futimes}.
* fs times setting futimens::   Setting file system times with @cfunc{mmux_libc_futimens}.
* fs times setting utimensat::  Setting file system times with @cfunc{mmux_libc_utimensat}.
@end menu

@c page
@node fs times setting utime
@subsubsection Setting file system times with @cfunc{mmux_libc_utime}


@deftypefun bool mmux_libc_utime (mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_utimbuf_arg_t @var{utimbuf})
@MmuxCInterface{utime}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_utimbuf_t  utimbuf;
  mmux_time_t          T1, T2;

  mmux_libc_time(&T1);
  mmux_libc_time(&T2);

  mmux_libc_actime_set  (utimbuf, T1);
  mmux_libc_modtime_set (utimbuf, T2);

  if (mmux_libc_utime(fs_ptn, utimbuf)) @{
    /* error */
  @}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs times setting utimes
@subsubsection Setting file system times with @cfunc{mmux_libc_utimes}


@deftypefun bool mmux_libc_utimes (mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{utimes}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_timeval_t  access_timeval, modification_timeval;

  /* Initialise the "timeval" values. */
  @{
    mmux_time_t  T1, T2;
    auto         microsecs1 = mmux_slong_literal(123);
    auto         microsecs2 = mmux_slong_literal(456);

    mmux_libc_time(&T1);
    mmux_libc_time(&T2);
    mmux_libc_timeval_set(&access_timeval,       T1, microsecs1);
    mmux_libc_timeval_set(&modification_timeval, T2, microsecs2);
  @}

  if (mmux_libc_utimes(fs_ptn, access_timeval, modification_timeval)) @{
    /* error */
  @}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs times setting lutimes
@subsubsection Setting file system times with @cfunc{mmux_libc_lutimes}


@deftypefun bool mmux_libc_lutimes (mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{lutimes}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/symlink.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_timeval_t  access_timeval, modification_timeval;

  /* Initialise the "timeval" values. */
  @{
    mmux_time_t  T1, T2;
    auto         microsecs1 = mmux_slong_literal(123);
    auto         microsecs2 = mmux_slong_literal(456);

    mmux_libc_time(&T1);
    mmux_libc_time(&T2);
    mmux_libc_timeval_set(&access_timeval,       T1, microsecs1);
    mmux_libc_timeval_set(&modification_timeval, T2, microsecs2);
  @}

  if (mmux_libc_lutimes(fs_ptn, access_timeval, modification_timeval)) @{
    /* error */
  @}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node fs times setting futimes
@subsubsection Setting file system times with @cfunc{mmux_libc_futimes}


@deftypefun bool mmux_libc_futimes (mmux_libc_fd_arg_t @var{fd}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{futimes}.

@example
mmux_asciizcp_t  ptn_asciiz = "/path/to/file.ext";
mmux_libc_fd_t   fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the file. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_RDONLY);
    auto  mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Do it. */
@{
  mmux_libc_timeval_t  access_timeval, modification_timeval;

  /* Initialise the "timeval" values. */
  @{
    mmux_time_t  T1, T2;
    auto         microsecs1 = mmux_slong_literal(123);
    auto         microsecs2 = mmux_slong_literal(456);

    mmux_libc_time(&T1);
    mmux_libc_time(&T2);
    mmux_libc_timeval_set(&access_timeval,       T1, microsecs1);
    mmux_libc_timeval_set(&modification_timeval, T2, microsecs2);
  @}

  if (mmux_libc_futimes(fd, access_timeval, modification_timeval)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs times setting futimens
@subsubsection Setting file system times with @cfunc{mmux_libc_futimens}


@deftypefun bool mmux_libc_futimens (mmux_libc_fd_arg_t @var{fd}, mmux_libc_timespec_t @var{access_timespec}, mmux_libc_timespec_t @var{modification_timespec})
@MmuxCInterface{futimens}.

@example
mmux_asciizcp_t  ptn_asciiz = "/path/to/file.ext";
mmux_libc_fd_t   fd;

/* Obtain the file descriptor. */
@{
  mmux_libc_fs_ptn_t  fs_ptn;

  /* Build the file system pathname. */
  @{
    mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

    mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
    if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
      /* error */
    @}
  @}

  /* Open the file. */
  @{
    auto  flags = mmux_libc_open_flags(MMUX_LIBC_O_RDONLY);
    auto  mode  = mmux_libc_mode_constant_zero();

    if (mmux_libc_open(fd, fs_ptn, flags, mode)) @{
      /* error */
    @}
  @}

  /* Local cleanup. */
  @{
    mmux_libc_unmake_file_system_pathname(fs_ptn);
  @}
@}

/* Do it. */
@{
  mmux_libc_timespec_t  access_timespec, modification_timespec;

  /* Initialise the "timespec" values. */
  @{
    mmux_time_t  T1, T2;
    auto         nanosecs1 = mmux_slong_literal(123);
    auto         nanosecs2 = mmux_slong_literal(456);

    mmux_libc_time(&T1);
    mmux_libc_time(&T2);
    mmux_libc_timespec_set(&access_timespec,       T1, nanosecs1);
    mmux_libc_timespec_set(&modification_timespec, T2, nanosecs2);
  @}

  if (mmux_libc_futimens(fd, access_timespec, modification_timespec)) @{
    /* error */
  @}
@}

/* Final cleanup. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs times setting utimensat
@subsubsection Setting file system times with @cfunc{mmux_libc_utimensat}


@deftypefun bool mmux_libc_utimensat (mmux_libc_dirfd_t @var{dirfd}, mmux_libc_fs_ptn_arg_t @var{pathname}, mmux_libc_timespec_t @var{access_timespec}, mmux_libc_timespec_t @var{modification_timespec}, mmux_sint_t @var{flags})
@MmuxCInterface{utimensat}.

@example
mmux_asciizcp_t     ptn_asciiz = "/path/to/file.ext";
mmux_libc_fs_ptn_t  fs_ptn;

/* Build the file system pathname. */
@{
  mmux_libc_fs_ptn_factory_t  fs_ptn_factory;

  mmux_libc_file_system_pathname_factory_static(fs_ptn_factory);
  if (mmux_libc_make_file_system_pathname(fs_ptn, fs_ptn_factory, ptn_asciiz)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_timespec_t  access_timespec, modification_timespec;

  /* Initialise the "timespec" values. */
  @{
    mmux_time_t  T1, T2;
    auto         nanosecs1 = mmux_slong_literal(123);
    auto         nanosecs2 = mmux_slong_literal(456);

    mmux_libc_time(&T1);
    mmux_libc_time(&T2);
    mmux_libc_timespec_set(&access_timespec,       T1, nanosecs1);
    mmux_libc_timespec_set(&modification_timespec, T2, nanosecs2);
  @}

  @{
    auto               flags = mmux_libc_utimensat_flags(MMUX_LIBC_AT_SYMLINK_NOFOLLOW);
    mmux_libc_dirfd_t  dirfd;

    mmux_libc_at_fdcwd(dirfd);
    if (mmux_libc_utimensat(dirfd, fs_ptn, access_timespec, modification_timespec, flags)) @{
      /* error */
    @}
  @}
@}

/* Final cleanup. */
@{
  mmux_libc_unmake_file_system_pathname(fs_ptn);
@}
@end example
@end deftypefun

@c page
@node sockets
@chapter Networking sockets


@menu
* sockets inames::              Socket interface names.
* sockets in_addr::             Address format @objtype{mmux_libc_in_addr_t}.
* sockets insix_addr::          Address format @objtype{mmux_libc_insix_addr_t}.
* sockets sockaddr_un::         Address format @objtype{mmux_libc_sockaddr_un_t}.
* sockets sockaddr_in::         Address format @objtype{mmux_libc_sockaddr_in_t}.
* sockets sockaddr_insix::      Address format @objtype{mmux_libc_sockaddr_insix_t}.
* sockets sockaddr::            Address format @objtype{mmux_libc_sockaddr_t}.
* sockets addrinfo::            Address informations.
* sockets hostsdb::             Hosts database.
* sockets servicesdb::          Services database.
* sockets protocolsdb::         Protocols database.
* sockets networksdb::          Networks database.
* sockets byteorder::           Converting byte order in socket addresses.
* sockets convaddr::            Converting socket addresses between formats.
* sockets getaddrinfo::         Getting address informations.
* sockets getnameinfo::         Getting address name informations.
* sockets creating::            Sockets: creating, pairs, shutting down, inspecting.
* sockets stream::              Sending and receiving data through a stream socket.
* sockets server::              Stream socket servers.
* sockets client::              Stream socket clients.
* sockets dgram::               Sending and receiving data through a datagram socket.
* sockets options::             Socket options.
@end menu

@c page
@node sockets inames
@section Socket interface names


@MmuxCStructOpaqueTypedef{if_nameindex}
@MmuxCStructPointerOpaqueTypedef{if_nameindex}
@MmuxSetterGetter{if_nameindex, if_index, mmux_uint_t}
@MmuxSetterGetter{if_nameindex, if_name,  mmux_asciizcp_t}
@MmuxStructDumper{if_nameindex}


@deftypefun bool mmux_libc_if_nametoindex (mmux_uint_t * @var{index_p}, mmux_asciizcp_t @var{network_interface_name})
@MmuxCInterface{if_nametoindex}.

@example
mmux_asciizcp_t         network_interface_name = "eth0";
mmux_uint_t             network_interface_index;

if (mmux_libc_if_nametoindex(&network_interface_index, network_interface_name)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_indextoname (mmux_asciizp_t @var{result_network_interface_name}, mmux_uint_t @var{network_interface_index})
@MmuxCInterface{if_indextoname}.

@example
mmux_uint_t     network_interface_index = 2;
char            network_interface_name[MMUX_LIBC_IFNAMSIZ];

if (mmux_libc_if_indextoname(network_interface_name, network_interface_index) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_nameindex (mmux_libc_if_nameindex_t const * * @var{result_nameindex_array_p})
@MmuxCInterface{if_nameindex}.

@example
mmux_libc_if_nameindex_t const *        nameindex_array;

if (mmux_libc_if_nameindex(&nameindex_array)) @{
  /* error */
@}

for (int i=0; true; ++i) @{
  mmux_uint_t           if_index;
  mmux_asciizcp_t       if_name;

  mmux_libc_if_index_ref(&if_index, A + i);
  mmux_libc_if_name_ref (&if_name,  A + i);

  if (if_index) @{
    /* do something with "if_index" and "if_name" */
  @} else @{
    break;
  @}
@}

mmux_libc_if_freenameindex(nameindex_array);
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_freenameindex (mmux_libc_if_nameindex_t const * @var{nameindex_array})
@MmuxCInterface{if_freenameindex}.
@end deftypefun

@c page
@node sockets in_addr
@section Address format @objtype{mmux_libc_in_addr_t}


Data structures of type @objtype{mmux_libc_in_addr_t} represent IPv4 addresses in numerical form, as
32-bit values stored in network byte order.


@MmuxCStructOpaqueTypedef{in_addr}
@MmuxCStructPointerOpaqueTypedef{in_addr}
@MmuxSetterGetter{in_addr, s_addr, mmux_uint32_t}
@MmuxStructDumper{in_addr}


@deftypefun bool mmux_libc_make_in_addr (mmux_libc_in_addr_t * in_addr_p, mmux_uint32_t network_byteorder_value)
Initialise the data structure referenced by @var{in_addr_p} to the address
@var{network_byteorder_value}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_none (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_NONE}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_any (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_ANY}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_broadcast (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_BROADCAST}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_loopback (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_LOOPBACK}.
@end deftypefun

@c page
@node sockets insix_addr
@section Address format @objtype{mmux_libc_insix_addr_t}


Data structures of type @objtype{mmux_libc_insix_addr_t} represent IPv6 addresses in binary format.


@deftp {Opaque Struct Typedef} mmux_libc_insix_addr_t
An opaque alias for @code{struct in6_addr}.
@end deftp

@MmuxCStructPointerOpaqueTypedef{insix_addr}
@MmuxStructDumper{insix_addr}


@deftypefun bool mmux_libc_make_insix_addr_loopback (mmux_libc_insix_addr_t * @var{insix_addr_p})
Initialise the data structure referenced by @var{insix_addr_p} to the predefined standard
@code{in6addr_loopback}.
@end deftypefun


@deftypefun bool mmux_libc_make_insix_addr_any (mmux_libc_insix_addr_t * @var{insix_addr_p})
Initialise the data structure referenced by @var{insix_addr_p} to the predefined standard
@code{in6addr_any}.
@end deftypefun

@c page
@node sockets sockaddr_un
@section Address format @objtype{mmux_libc_sockaddr_un_t}


@MmuxCStructOpaqueTypedef{sockaddr_un}
@MmuxCStructPointerOpaqueTypedef{sockaddr_un}
@MmuxSetterGetter{sockaddr_un, sun_family, mmux_sshort_t}
@MmuxSetterGetter{sockaddr_un, sun_path,   mmux_libc_fs_ptn_arg_t}
@MmuxStructDumper{sockaddr_un}


The file system pathname associated to an address of format @objtype{mmux_libc_sockaddr_un_t} is
embedded in the data structure itself; it has maximum length of fixed size, hard--coded in the data
structure definition.  The pathname must be an @MmuxAsciiZ{} string and the terminating nul must be
included in the embedded @MmuxAsciiZ{} string.

If we want to allocate a block of memory wide enough to contain a pathname of maximum length we have
to take the @cfunc{sizeof} of the data structure type.  If we want to compute the address size
needed as arguments by some socket functions: we have to use the following function.


@deftypefun mmux_usize_t mmux_libc_SUN_LEN (mmux_libc_sockaddr_un_t const * @var{sockaddr_un_p})
Return the address size, measured in bytes, of the address data structure referenced by
@var{sockaddr_un_p}.

@itemize
@item
The returned size does @strong{not} include the terminating nul of the included file pathname.

@item
The returned size is the correct value to hand to functions requiring the address size, like
@cfunc{mmux_libc_bind}.
@end itemize
@end deftypefun

@c page
@node sockets sockaddr_in
@section Address format @objtype{mmux_libc_sockaddr_in_t}


@MmuxCStructOpaqueTypedef{sockaddr_in}
@MmuxCStructPointerOpaqueTypedef{sockaddr_in}
@MmuxSetterGetter{sockaddr_in, sin_family, mmux_sshort_t}
@MmuxSetterGetter{sockaddr_in, sin_addr,   mmux_libc_in_addr_t}
@MmuxSetterGetter{sockaddr_in, sin_port,   mmux_host_byteorder_ushort_t}
@MmuxStructDumper{sockaddr_in}


@deftypefun bool mmux_libc_sin_addr_p_ref (mmux_libc_in_addr_t ** sin_addr_pp, mmux_libc_sockaddr_in_t * sockaddr_p)
Store in the location referenced by @var{sin_addr_pp} a pointer to the field @code{sin_addr} of the
data structure referenced by @var{sockaddr_p}.
@end deftypefun

@c page
@node sockets sockaddr_insix
@section Address format @objtype{mmux_libc_sockaddr_insix_t}


To ease typing on keyboards, @value{PACKAGE} renames: the name of the data structure @code{struct
sockaddr_in6} to @objtype{mmux_libc_sockaddr_insix_t}; the fields @code{sin6_} of @code{struct
sockaddr_in6} to @code{sinsix_}.


@deftp {Opaque Struct Typedef} mmux_libc_sockaddr_insix_t
An opaque alias for @code{struct sockaddr_in6}.
@end deftp


@MmuxCStructPointerOpaqueTypedef{sockaddr_insix}
@MmuxSetterGetter{sockaddr_insix, sinsix_family,   mmux_sshort_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_addr,     mmux_libc_insix_addr_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_flowinfo, mmux_uint32_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_scope_id, mmux_uint32_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_port,     mmux_host_byteorder_uint16_t}
@MmuxStructDumper{sockaddr_insix}


@deftypefun bool mmux_libc_sinsix_addr_p_ref (mmux_libc_insix_addr_t ** @var{sin_addr_pp}, mmux_libc_sockaddr_in_t * @var{sockaddr_p})
Store in the location referenced by @var{sinsix_addr_pp} a pointer to the field @code{sinsix_addr}
of the data structure referenced by @var{sockaddr_p}.
@end deftypefun

@c page
@node sockets sockaddr
@section Address format @objtype{mmux_libc_sockaddr_t}


@deftp {Opaque Struct Typedef} mmux_libc_sockaddr_t
An opaque alias for a non--standard data structure type: we can handle this type as being big enough
to contain any of the data structure types @code{struct sockaddr_*}.  @value{PACKAGE} uses this data
type as alias for @MmuxCStruct{sockaddr}.
@end deftp

@MmuxCStructPointerOpaqueTypedef{sockaddr}
@MmuxSetterGetter{sockaddr, sa_family,   mmux_sshort_t}
@MmuxStructDumper{sockaddr}

@c page
@node sockets addrinfo
@section Address informations


@MmuxCStructOpaqueTypedef{addrinfo}
@MmuxCStructPointerOpaqueTypedef{addrinfo}
@MmuxSetterGetter{addrinfo, ai_flags,           mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_family,          mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_socktype,        mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_protocol,        mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_addrlen,         mmux_socklen_t}
@MmuxSetterGetter{addrinfo, ai_addr,            mmux_libc_sockaddr_t *}
@MmuxSetterGetter{addrinfo, ai_canonname,       mmux_asciizp_t}
@MmuxSetterGetter{addrinfo, ai_next,            mmux_libc_addrinfo_t *}
@MmuxStructDumper{addrinfo}

@c page
@node sockets hostsdb
@section Hosts database


@MmuxCStructOpaqueTypedef{hostent}
@MmuxCStructPointerOpaqueTypedef{hostent}
@MmuxSetterGetter{hostent, h_name,              mmux_asciizp_t}
@MmuxSetterGetter{hostent, h_aliases,           mmux_asciizpp_t}
@MmuxSetterGetter{hostent, h_addrtype,          mmux_sint_t}
@MmuxSetterGetter{hostent, h_length,            mmux_sint_t}
@MmuxSetterGetter{hostent, h_addr_list,         mmux_asciizpp_t}
@MmuxSetterGetter{hostent, h_addr,              mmux_asciizp_t}
@MmuxStructDumper{hostent}


@deftypefun bool mmux_libc_sethostent (bool @var{stayopen})
@MmuxCInterface{sethostent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endhostent (void)
@MmuxCInterface{endhostent}.
@end deftypefun


@deftypefun bool mmux_libc_gethostent (mmux_libc_hostent_t const * * @var{result_hostent_pp})
@MmuxCInterface{gethostent}.
@end deftypefun

@c page
@node sockets servicesdb
@section Services database


@MmuxCStructOpaqueTypedef{servent}
@MmuxCStructPointerOpaqueTypedef{servent}
@MmuxSetterGetter{servent, s_name,		mmux_asciizp_t}
@MmuxSetterGetter{servent, s_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{servent, s_port,		mmux_sint_t}
@MmuxSetterGetter{servent, s_proto,		mmux_asciizp_t}
@MmuxStructDumper{servent}


@deftypefun bool mmux_libc_setservent (bool @var{stayopen})
@MmuxCInterface{setservent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endservent (void)
@MmuxCInterface{endservent}.
@end deftypefun


@deftypefun bool mmux_libc_getservent (mmux_libc_servent_t const * * @var{result_servent_pp})
@MmuxCInterface{getservent}.
@end deftypefun


@deftypefun bool mmux_libc_getservbyname(mmux_libc_servent_t const * * @var{result_servent_pp}, mmux_asciizcp_t @var{service_name_p}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getservbyname}.  If an error occurs: @var{result_servent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_servent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 service_name_p  = "smtp";
mmux_asciizcp_t                 protocol_name_p = "tcp";
mmux_libc_servent_t const *     servent_p;

if (mmux_libc_getservbyname(&servent_p, service_name_p, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getservbyport (mmux_libc_servent_t const * * @var{result_servent_pp}, mmux_sint_t @var{host_byteorder_port}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getservbyport}.  If an error occurs: @var{result_servent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_servent_pp} is never set to
@cnull{}.

@example
mmux_sint_t                     host_byteorder_port = 25;
mmux_asciizcp_t                 protocol_name_p     = "tcp";
mmux_libc_servent_t const *     servent_p;

if (mmux_libc_getservbyport(&servent_p, host_byteorder_port, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node sockets protocolsdb
@section Protocols database


@MmuxCStructOpaqueTypedef{protoent}
@MmuxCStructPointerOpaqueTypedef{protoent}
@MmuxSetterGetter{protoent, p_name,		mmux_asciizp_t}
@MmuxSetterGetter{protoent, p_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{protoent, p_proto,		mmux_sint_t}
@MmuxStructDumper{protoent}


@deftypefun bool mmux_libc_setprotoent (bool @var{stayopen})
@MmuxCInterface{setprotoent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endprotoent (void)
@MmuxCInterface{endprotoent}.
@end deftypefun


@deftypefun bool mmux_libc_getprotoent (mmux_libc_protoent_t const * * @var{result_protoent_pp})
@MmuxCInterface{getprotoent}.
@end deftypefun


@deftypefun bool mmux_libc_getprotobyname (mmux_libc_protoent_t const * * @var{result_protoent_pp}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getprotobyname}.  If an error occurs: @var{result_protoent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_protoent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 protocol_name_p = "tcp";
mmux_libc_protoent_t const *    protoent_p;

if (mmux_libc_getprotobyname(&protoent_p, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getprotobynumber (mmux_libc_protoent_t const * * @var{result_protoent_pp}, mmux_sint_t @var{proto})
@MmuxCInterface{getprotobynumber}.  If an error occurs: @var{result_protoent_pp} is left untouched
and the return value is @ctrue{}.  The location referenced by @var{result_protoent_pp} is never set
to @cnull{}.

@example
mmux_libc_protoent_t const *    protoent_p;

if (mmux_libc_getprotobyname(&protoent_p, MMUX_LIBC_IPPROTO_TCP)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node sockets networksdb
@section Networks database


@MmuxCStructOpaqueTypedef{netent}
@MmuxCStructPointerOpaqueTypedef{netent}
@MmuxSetterGetter{netent, n_name,		mmux_asciizp_t}
@MmuxSetterGetter{netent, n_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{netent, n_addrtype,		mmux_sint_t}
@MmuxSetterGetter{netent, n_net,		mmux_ulong_t}
@MmuxStructDumper{netent}


@deftypefun bool mmux_libc_setnetent (bool @var{stayopen})
@MmuxCInterface{setnetent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endnetent (void)
@MmuxCInterface{endnetent}.
@end deftypefun


@deftypefun bool mmux_libc_getnetent (mmux_libc_netent_t const * * @var{result_netent_pp})
@MmuxCInterface{getnetent}.
@end deftypefun


@deftypefun bool mmux_libc_getnetbyname (mmux_libc_netent_t const * * @var{result_netent_pp}, mmux_asciizcp_t @var{network_name_p})
@MmuxCInterface{getnetbyname}.  If an error occurs: @var{result_netent_pp} is left untouched and the
return value is @ctrue{}.  The location referenced by @var{result_netent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 network_name_p = "loopback";
mmux_libc_netent_t const *      netent_p;

if (mmux_libc_getnetbyname(&netent_p, network_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getnetbyaddr (mmux_libc_netent_t const * * @var{result_netent_pp}, mmux_uint32_t @var{n_net}, mmux_sint_t @var{af_type})
@MmuxCInterface{getnetbyaddr}.  If an error occurs: @var{result_netent_pp} is left untouched and the
return value is @ctrue{}.  The location referenced by @var{result_netent_pp} is never set to
@cnull{}.

The argument @var{n_net} is homogeneous to the values of the field @samp{n_net} of
@MmuxCStruct{netent}: the network address in host byteorder.

@example
mmux_asciizcp_t                 dotted_quad = "127.0.0.0";
mmux_libc_in_addr_t             address;
mmux_uint32_t                   netw_byteorder_n_net;
mmux_uint32_t                   host_byteorder_n_net;
mmux_libc_netent_t const *      netent_p;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET, dotted_quad)) @{
  /* error */
@}
mmux_libc_s_addr_ref(&netw_byteorder_n_net, &address);
mmux_libc_ntohl(&host_byteorder_n_net, netw_byteorder_n_net);
if (mmux_libc_getnetbyaddr(&netent_p, host_byteorder_n_net, MMUX_LIBC_AF_INET)) @{
  /* error */
@}
/* do something with "netent_p" */
@end example
@end deftypefun

@c page
@node sockets byteorder
@section Converting byte order in socket addresses


@deftypefun bool mmux_libc_htons (mmux_uint16_t * network_byteorder_value_p, mmux_uint16_t host_byteorder_value)
@MmuxCInterface{htons}.  Host--to--network short--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_ntohs (mmux_uint16_t * host_byteorder_value_p, mmux_uint16_t network_byteorder_value)
@MmuxCInterface{ntohs}.  Network--to--host short--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_htonl (mmux_uint32_t * network_byteorder_value_p, mmux_uint32_t host_byteorder_value)
@MmuxCInterface{htonl}.  Host--to--network long--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_ntohl (mmux_uint32_t * host_byteorder_value_p, mmux_uint32_t network_byteorder_value)
@MmuxCInterface{ntohl}.  Network--to--host long--number byte order conversion.
@end deftypefun

@c page
@node sockets convaddr
@section Converting socket addresses between formats


@deftypefun bool mmux_libc_inet_pton (mmux_pointer_t @var{ouput_addr_p}, mmux_sint_t @var{input_af_family}, mmux_asciizcp_t @var{input_presentation_p})
@MmuxCInterface{inet_pton}.

Convert the @MmuxAsciiZ{} Internet address presentation referenced by @var{input_presentation_p} into a
binary data structure; the presentation is expected to represent an address in the format specified
by @var{input_af_family}, for example @samp{MMUX_LIBC_AF_INET} or @samp{MMUX_LIBC_AF_INET6}.

When successful, the resulting data structure is stored in the buffer referenced by
@var{ouput_addr_p}; when @var{input_af_family} equals:

@table @samp
@item MMUX_LIBC_AF_INET
The referenced buffer must be a data structure of type @objtype{mmux_libc_in_addr_t}.

@item MMUX_LIBC_AF_INET6
The referenced buffer must be a data structure of type @objtype{mmux_libc_insix_addr_t}.
@end table

Example:

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET, dotted_quad)) @{
  /* error */
@}
@end example

Example:

@example
mmux_asciizcp_t         presentation = "1:2:3:4:5:6:7:8";
mmux_libc_insix_addr_t  address;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET6, presentation)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_ntop (mmux_asciizp_t @var{ouput_presentation_p}, mmux_usize_t @var{ouput_presentation_provided_nchars}, mmux_sint_t @var{input_af_family}, mmux_pointer_t @var{input_addr_p})
@MmuxCInterface{inet_ntop}.

Convert the Internet address data structure referenced by @var{input_addr_p} in its @MmuxAsciiZ{}
presentation and copy it into the buffer referenced by @var{ouput_presentation_p}; the data
structure is expected to represent an address in the format specified by @var{input_af_family}, for
example @samp{MMUX_LIBC_AF_INET} or @samp{MMUX_LIBC_AF_INET6}; when @var{input_af_family} equals:

@table @samp
@item MMUX_LIBC_AF_INET
The referenced data structure must be of type @objtype{mmux_libc_in_addr_t}.

@item MMUX_LIBC_AF_INET6
The referenced data structure must be of type @objtype{mmux_libc_insix_addr_t}.
@end table

If the length of the @MmuxAsciiZ{} presentation, including its terminating nul, is less than or equal to
@var{ouput_presentation_provided_nchars}: the whole string, including its terminating nul, is
written in the output buffer; then the return value if @cfalse{}.  Otherwise nothing is written and
the return value is @ctrue{}.

Example:

@example
mmux_libc_in_addr_t     address;

if (mmux_libc_make_in_addr_broadcast(&address)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntop(str, IS_THIS_ENOUGH_QUESTION_MARK, MMUX_LIBC_AF_INET, &address)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example

Example:

@example
mmux_libc_insix_addr_t     address;

if (mmux_libc_make_insix_addr_loopback(&address)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntop(str, IS_THIS_ENOUGH_QUESTION_MARK, MMUX_LIBC_AF_INET6, &address)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_inet_aton (mmux_libc_in_addr_ptr_t @var{ouput_addr_p}, mmux_asciizcp_t @var{input_presentation_p})
@MmuxCInterface{inet_aton}.

Convert the dotted--quad @MmuxAsciiZ{} representation of an IPv4 address referenced by
@var{input_presentation_p} into a data structure of type @objtype{mmux_libc_in_addr_t}; store the
result in the data structure referenced by @var{ouput_addr_p}.

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_aton(&address, dotted_quad)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_ntoa (mmux_asciizp_t @var{ouput_presentation_p}, mmux_usize_t @var{ouput_presentation_provided_nchars}, mmux_libc_in_addr_t * @var{input_addr_p})
@MmuxCInterface{inet_ntoa}.

Convert the IPv4 address referenced by @var{input_addr_p} in its dotted--quad @MmuxAsciiZ{} presentation
and copy it into the buffer referenced by @var{ouput_presentation_p}.

If the length of the @MmuxAsciiZ{} presentation, including its terminating nul, is less than or equal to
@var{ouput_presentation_provided_nchars}: the whole string, including its terminating nul, is
written in the output buffer; then the return value if @cfalse{}.  Otherwise nothing is written and
the return value is @ctrue{}.

@example
mmux_libc_in_addr_t     in_addr;

if (mmux_libc_make_in_addr_broadcast(&in_addr)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntoa(str, IS_THIS_ENOUGH_QUESTION_MARK, &in_addr)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_addr (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_asciizcp_t @var{presentation_in_addr_p})
@MmuxCInterface{inet_addr}.

If an error occurs: the location referenced by @var{result_in_addr_p} is left untouched; the return
value if @ctrue{}.

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_addr(&address, dotted_quad)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_network (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_asciizcp_t @var{presentation_in_addr_p})
@MmuxCInterface{inet_addr}.

If an error occurs: the location referenced by @var{result_in_addr_p} is left untouched; the return
value if @ctrue{}.
@end deftypefun


@deftypefun bool mmux_libc_inet_makeaddr (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_libc_in_addr_ptr_t @var{net_in_addr_p}, mmux_libc_in_addr_ptr_t @var{local_in_addr_p})
@MmuxCInterface{inet_makeaddr}.
@end deftypefun


@deftypefun bool mmux_libc_inet_lnaof (mmux_libc_in_addr_ptr_t @var{local_in_addr_p}, mmux_libc_in_addr_ptr_t @var{in_addr_p})
@MmuxCInterface{inet_lnaof}.
@end deftypefun


@deftypefun bool mmux_libc_inet_netof (mmux_libc_in_addr_ptr_t @var{net_in_addr_p}, mmux_libc_in_addr_ptr_t @var{in_addr_p})
@MmuxCInterface{inet_netof}.
@end deftypefun

@c page
@node sockets getaddrinfo
@section Getting address informations


Usage example:

@example
mmux_asciizcp_t                 node    = "localhost";
mmux_asciizcp_t                 service = "smtp";
mmux_libc_addrinfo_t            hints;

mmux_libc_addrinfo_ptr_t        addrinfo_linked_list_p;
mmux_sint_t                     error_code;

mmux_libc_ai_flags_set    (&hints, MMUX_LIBC_AI_V4MAPPED | MMUX_LIBC_AI_ADDRCONFIG | MMUX_LIBC_AI_CANONNAME);
mmux_libc_ai_family_set   (&hints, MMUX_LIBC_AF_UNSPEC);
mmux_libc_ai_socktype_set (&hints, MMUX_LIBC_SOCK_STREAM);
mmux_libc_ai_protocol_set (&hints, MMUX_LIBC_IPPROTO_TCP);

if (mmux_libc_getaddrinfo(&addrinfo_linked_list, &error_code, node, service, &hints)) @{
  mmux_asciizcp_t      error_message;

  mmux_libc_gai_strerror(&error_message, error_code);
  /* handle the error */
@} else @{
  /* do something with "addrinfo_linked_list_p" */

  mmux_libc_freeaddrinfo(addrinfo_linked_list_p);
@}
@end example


@deftypefun bool mmux_libc_getaddrinfo (mmux_libc_addrinfo_ptr_t * @var{result_addrinfo_linked_list_pp}, mmux_sint_t * @var{result_error_code_p}, mmux_asciizcp_t @var{node}, mmux_asciizcp_t @var{service}, mmux_libc_addrinfo_ptr_t @var{hints_p})
@MmuxCInterface{getaddrinfo}.
@end deftypefun


@deftypefun bool mmux_libc_freeaddrinfo (mmux_libc_addrinfo_ptr_t @var{addrinfo_linked_list_p})
@MmuxCInterface{freeaddrinfo}.
@end deftypefun


@deftypefun bool mmux_libc_gai_strerror (mmux_asciizcp_t * @var{result_error_message_p}, mmux_sint_t @var{errnum})
@MmuxCInterface{gai_strerror}.
@end deftypefun

@c page
@node sockets getnameinfo
@section Getting address name informations


Usage example:

@example
mmux_libc_sockaddr_in_t input_sockaddr;
mmux_sint_t             error_code;
mmux_sint_t             flags = 0;

#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	512
char                    hostname[IS_THIS_ENOUGH_QUESTION_MARK];
char                    servname[IS_THIS_ENOUGH_QUESTION_MARK];

gimme_an_address(&input_sockaddr);

if (mmux_libc_getnameinfo (hostname, IS_THIS_ENOUGH_QUESTION_MARK,
                           servname, IS_THIS_ENOUGH_QUESTION_MARK,
                           &error_code,
                           &input_sockaddr, sizeof(mmux_libc_sockaddr_in_t), flags)) @{
  mmux_asciizcp_t      error_message;

  mmux_libc_gai_strerror(&error_message, error_code);
  /* handle the error */
@} else @{
  /* do something with "hostname" and "servname" */
@}
@end example


@deftypefun bool mmux_libc_getnameinfo (mmux_asciizcp_t @var{result_hostname_p}, mmux_socklen_t @var{provided_hostname_len}, mmux_asciizcp_t @var{result_servname_p}, mmux_socklen_t @var{provided_servname_len}, mmux_sint_t * @var{result_error_code_p}, mmux_libc_sockaddr_ptr_t @var{input_sockaddr_p}, mmux_socklen_t @var{input_sockaddr_size}, mmux_sint_t @var{flags})
@MmuxCInterface{getnameinfo}.
@end deftypefun

@c page
@node sockets creating
@section Sockets: creating, pairs, shutting down, inspecting


@deftp {Opaque Typedef} mmux_libc_network_socket_t
An alias for @objtype{mmux_libc_file_descriptor_t} representing a networking socket.
@end deftp


@deftypefun bool mmux_libc_make_network_socket (mmux_libc_network_socket_t * @var{result_p}, mmux_sint_t @var{sock_num})
Initialise the value referenced by @var{result_p} with the given integer.
@end deftypefun


@deftypefun bool mmux_libc_socket (mmux_libc_network_socket_t * @var{result_sock_p}, mmux_sint_t @var{pf_namespace}, mmux_sint_t @var{sock_style}, mmux_sint_t @var{ipproto})
@MmuxCInterface{socket}.

@example
mmux_libc_network_socket_t      sock;

if (mmux_libc_socket(&sock, MMUX_LIBC_PF_INET, MMUX_LIBC_SOCK_STREAM, MMUX_LIBC_IPPROTO_TCP)) @{
  /* error */
@}

mmux_libc_shutdown(sock, MMUX_LIBC_SHUT_RDWR);
@end example
@end deftypefun


@deftypefun bool mmux_libc_shutdown (mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{shut_how})
@MmuxCInterface{shutdown}.
@end deftypefun


@deftypefun bool mmux_libc_socketpair (mmux_libc_network_socket_t * @var{result_sock1_p}, mmux_libc_network_socket_t * @var{result_sock2_p}, mmux_sint_t @var{pf_namespace}, mmux_sint_t @var{sock_style}, mmux_sint_t @var{ipproto})
@MmuxCInterface{socketpair}.

@example
mmux_libc_network_socket_t      sock1, sock2;

if (mmux_libc_socketpair(&sock1, &sock2, MMUX_LIBC_PF_LOCAL, MMUX_LIBC_SOCK_STREAM, MMUX_LIBC_IPPROTO_IP)) @{
  /* error */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_getpeername (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t * @var{provided_sockaddr_size})
@MmuxCInterface{getpeername}.

@example
mmux_libc_network_socket_t      sock;
mmux_libc_sockaddr_t            sockaddr;
mmux_socklen_t                  sockaddr_size = sizeof(mmux_libc_sockaddr_t);

gimme_a_stream_sock(&sock);

if (mmux_libc_getpeername(sock, &sockaddr, &sockaddr_size)) @{
  /* error */
@}

/* do something with "sockaddr", whose real size is "sockaddr_size" */
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_getsockname (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t * @var{provided_sockaddr_size})
@MmuxCInterface{getsockname}.

@example
mmux_libc_network_socket_t      sock;
mmux_libc_sockaddr_t            sockaddr;
mmux_socklen_t                  sockaddr_size = sizeof(mmux_libc_sockaddr_t);

gimme_a_stream_sock(&sock);

if (mmux_libc_getsockname(sock, &sockaddr, &sockaddr_size)) @{
  /* error */
@}

/* do something with "sockaddr", whose real size is "sockaddr_size" */
@end example
@end deftypefun

@c page
@node sockets stream
@section Sending and receiving data through a stream socket


@deftypefun bool mmux_libc_send (mmux_usize_t * @var{result_number_of_bytes_sent_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{send}.
@end deftypefun


@deftypefun bool mmux_libc_recv (mmux_usize_t * @var{result_number_of_bytes_received_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{recv}.
@end deftypefun

@c page
@node sockets server
@section Stream socket servers


@deftypefun bool mmux_libc_bind (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t @var{sockaddr_size})
@MmuxCInterface{bind}.
@end deftypefun


@deftypefun bool mmux_libc_listen (mmux_libc_network_socket_t @var{sock}, mmux_uint_t @var{pending_connections_queue_length}a)
@MmuxCInterface{listen}.
@end deftypefun


@deftypefun bool mmux_libc_accept (mmux_libc_network_socket_t * @var{result_connected_sock_p}, mmux_libc_sockaddr_ptr_t @var{result_client_sockaddr_p}, mmux_socklen_t * @var{result_client_sockaddr_size_p}, mmux_libc_network_socket_t @var{server_sock})
@MmuxCInterface{accept}.

@itemize
@item
Upon calling: the location referenced by @var{result_client_sockaddr_size_p} must be set to the
number of bytes allocated for the address referenced by @var{result_client_sockaddr_p}.

@item
Upon successfully returning: the location referenced by @var{result_client_sockaddr_size_p} is reset
to the actual size of the client address.
@end itemize
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_accept4 (mmux_libc_network_socket_t * @var{result_connected_sock_p}, mmux_libc_sockaddr_ptr_t @var{result_client_sockaddr_p}, mmux_socklen_t * @var{result_client_sockaddr_size_p}, mmux_libc_network_socket_t @var{server_sock}, mmux_sint_t @var{flags})
@MmuxCInterface{accept4}.

@itemize
@item
Upon calling: the location referenced by @var{result_client_sockaddr_size_p} must be set to the
number of bytes allocated for the address referenced by @var{result_client_sockaddr_p}.

@item
Upon successfully returning: the location referenced by @var{result_client_sockaddr_size_p} is reset
to the actual size of the client address.
@end itemize
@end deftypefn

@c page
@node sockets client
@section Stream socket clients


@deftypefun bool mmux_libc_connect (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t @var{sockaddr_size})
@MmuxCInterface{connect}.
@end deftypefun

@c page
@node sockets dgram
@section Sending and receiving data through a datagram socket


@deftypefun bool mmux_libc_sendto (mmux_usize_t * @var{result_number_of_bytes_sent_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags}, mmux_libc_sockaddr_ptr_t @var{destination_sockaddr_p}, mmux_socklen_t @var{destination_sockaddr_size})
@MmuxCInterface{sendto}.
@end deftypefun


@deftypefun bool mmux_libc_recvfrom (mmux_usize_t * @var{result_number_of_bytes_received_p}, mmux_libc_sockaddr_ptr_t @var{result_sender_sockaddr_p}, mmux_socklen_t * @var{result_sender_sockaddr_size_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{recvfrom}.

The arguments @var{result_sender_sockaddr_p} and @var{result_sender_sockaddr_size_p} can be
@cnull{} if we are not interested in retrieving the sender address; if they are not @cnull{}:

@itemize
@item
Upon entering the call: the location referenced by @var{result_sender_sockaddr_size_p} must be set
to the number of bytes allocated to contain the sender address.

@item
Upon successfully returning from the call: the location referenced by
@var{result_sender_sockaddr_size_p} is reset to the actual number of bytes required to contain the
sender address.
@end itemize
@end deftypefun

@c page
@node sockets options
@section Socket options


@MmuxCStructOpaqueTypedef{linger}
@MmuxCStructPointerOpaqueTypedef{linger}
@MmuxSetterGetter{linger, l_onoff,		mmux_sint_t}
@MmuxSetterGetter{linger, l_linger,		mmux_sint_t}
@MmuxStructDumper{linger}


@deftypefun bool mmux_libc_getsockopt (mmux_pointer_t @var{result_optval_p}, mmux_socklen_t * @var{result_optlen_p}, mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{level}, mmux_sint_t @var{optname})
@MmuxCInterface{getsockopt}.
@end deftypefun


@deftypefun bool mmux_libc_setsockopt (mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{level}, mmux_sint_t @var{optname}, mmux_pointer_t @var{optval_p}, mmux_socklen_t @var{optlen})
@MmuxCInterface{setsockopt}.
@end deftypefun

@c page
@node interface specifications
@chapter Interface specifications


It happens that we implement an @api{} which undergoes progressive development and we want a library
to export multiple revisions of the same @api{}; it is useful to define a data structure
representing an interface version specification.

Under @value{PACKAGE}, interface specifications follow version numbering as established by the
@gnu{} Autotools for shared libraries; for an explanation of interface numbers as managed by @gnu{}
Libtool @xref{Libtool versioning, interface, Libtool's versioning system, libtool, Shared library
support for @gnu{}}.

@menu
* interface specifications projects::   Introduction to declare interface versioning for projects.
* interface specifications types::      Data types to declare interface specifications.
* interface specifications api::        Operations on interface specifications.
@end menu

@c page
@node interface specifications projects
@section Introduction to declare interface versioning for projects.


Let's say we develop a project implementing a C language library, whose public @api{} contains a
module exporting the following functions and data types:

@example
typedef struct alpha_t @{ ... @} alpha_t;
typedef struct beta_t  @{ ... @} beta_t;

extern void red   (alpha_t * A, beta_t * B);
extern void green (alpha_t * A);
extern void blue  (beta_t  * B);
@end example

@noindent
and we publish a release of this project.  If this is the first public release we should assign to
this @api{} an interface version specification with the format @samp{CURRENT:REVISION:AGE} and value
@samp{0:0:0}.  Using the facilities of @value{PACKAGE}, we could define a data structure:

@example
mmux_libc_interface_specification_t const spiffy_interface_specification = @{
  .is_name      = "My Spiffy Project",
  .is_current   = 0,
  .is_revision  = 0,
  .is_age       = 0,
@};
@end example

@noindent
and add it to the public @api{}:

@example
extern mmux_libc_interface_specification_t const spiffy_interface_specification;
@end example

@noindent
so that the process in execution can itself, at run--time, determine the available features.

Now let's say we fix some errors in the code and/or change the internal implementation for
optimisation purposes or something else; then we publish another release; we notice that:

@itemize
@item
nothing has changed in the type declarations and the function prototypes;

@item
all the functions perform the same operations as before;

@item
nothing has changed in the relations between input arguments, output results and side effects; or,
maybe, some results and side effects have changed because of error fixes, but the intended meaning
of results and side effects is the same;
@end itemize

@noindent
we should increment the @samp{REVISION} component, so that the interface version specification
becomes @samp{0:1:0}.  The client code the library is linked with can determine if the fixes are
available by inspecting the @samp{REVISION} component:

@itemize
@item
if it is @samp{0}, the library's implementation does not contain the latest fixes; it means the
package installed on the system has not been upgraded to the latest revision;

@item
if it is @samp{1}, the package has been upgraded.
@end itemize

@c ------------------------------------------------------------------------

@subsection Project's development continues

We add a new function:

@example
extern void transparency (alpha_t * A);
@end example

@noindent
now the @api{} has changed, but the old @api{} is still available; we should:

@enumerate
@item
increment the @samp{CURRENT} component to @samp{1}, to signal that the @api{} has changed;

@item
reset the @samp{REVISION} component to @samp{0}, to signal that the available @api{} is the first
released for @samp{CURRENT} version number @samp{1};

@item
set the @samp{AGE} component to @samp{1}, to signal that the new @api{} having @samp{CURRENT}
version number @samp{1} is compatible with the old @api{} having @samp{CURRENT} version number
@samp{1 - AGE = 1 - 1 = 0}.
@end enumerate

@c ------------------------------------------------------------------------

@subsection Project's development continues again

We add a new function:

@example
extern void glossy (beta_t * B);
@end example

@noindent
the @api{} has changed again, but the old @api{}s are still available; we should:

@enumerate
@item
increment the @samp{CURRENT} component to @samp{2}, to signal that the @api{} has changed;

@item
reset the @samp{REVISION} component to @samp{0}, to signal that the available @api{} is the first
released for @samp{CURRENT} version number @samp{2};

@item
set the @samp{AGE} component to @samp{2}, to signal that the new @api{} having @samp{CURRENT}
version number @samp{2} is compatible with the old @api{}s having @samp{CURRENT} version number in
the inclusive range @samp{2 - AGE = 2 - 2 = 0} and @samp{2}; we can link with this new library
client code that expects the @api{} to be compatible with all the version numbers @samp{0},
@samp{1}, @samp{2}.
@end enumerate

@c ------------------------------------------------------------------------

@subsection Project's development continues again again

We remove the old function:

@example
extern void blue (beta_t * B);
@end example

@noindent
because it has become obsolete; the @api{} has changed again, and the old @api{}s are not available
anymore; we should:

@enumerate
@item
increment the @samp{CURRENT} component to @samp{3}, to signal that the @api{} has changed;

@item
reset the @samp{REVISION} component to @samp{0}, to signal that the available @api{} is the first
released for @samp{CURRENT} version number @samp{3};

@item
reset the @samp{AGE} component to @samp{0}, to signal that the old @api{}s are no more available,
only the @api{} having @samp{CURRENT} version number @samp{3} is available.
@end enumerate

@c page
@node interface specifications types
@section Data types to declare interface specifications


@deftp {Struct Typedef} mmux_libc_interface_specification_t
Data structure representing an interface specification.

@table @code
@item mmux_asciizcp_t is_name
Pointer to a, possibly statically--allocated, @MmuxAsciiZ{} string representing the name of this
interface; there are no constraints on the string's format.

@item mmux_standard_uint_t is_current
Interface's current version number.  The starting value should be @samp{0}.

@item mmux_standard_uint_t is_revision
Interface's revision number.  The starting value should be @samp{0}.

@item mmux_standard_uint_t is_age
Interface's age number.  The starting value should be @samp{0}.
@end table
@end deftp

@c page
@node interface specifications api
@section Operations on interface specifications


@deftypefun bool mmux_libc_interface_specification_is_compatible (bool * @var{result_p}, mmux_libc_interface_specification_t const * @var{IS}, mmux_uint_t @var{requested_version})
If @var{requested_version} is compatible with the interface specification referenced by @var{IS}:
store @ctrue{} in the variable referenced by @var{result_p}; otherwise store @cfalse{}.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
the package @mmux{} CC Types is available online:

@center @url{https://github.com/marcomaggi/mmux-cc-types/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

