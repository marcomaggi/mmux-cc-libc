\input texinfo.tex
@c %**start of header
@setfilename mmux-cc-libc.info
@settitle MMUX CC Types
@c %**end of header

@c @include version.texi
@include mmux-version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX CC Libc

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX CC Libc

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-cc-libc

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024, 2025

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_CC_LIBC
@set PackagePkgconfigModule             mmux-cc-libc
@set PackageLibsVar                     @env{MMUX_CC_LIBC_LIBS}
@set PackageCflagsVar                   @env{MMUX_CC_LIBC_CFLAGS}
@c This is the stem of the library in "libmmux-cc-libc.so".
@set PackageLibstem                     mmux-cc-libc
@set PackageApiPrefixLower              mmux_libc_
@set PackageApiPrefixUpper              MMUX_LIBC_

@set PackageHeader                      mmux-cc-libc.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@macro mmuxcctypesref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,mmux-cc-types}
@end macro

@macro MmuxCFuncpage{FUNCNAME}
@ref{\FUNCNAME\,\FUNCNAME\,\FUNCNAME\,*manpages*}
@end macro

@macro MmuxCStruct{NAME}
@code{struct \NAME\}
@end macro

@macro MmuxCInterfaceTwo{FUNCNAME,MANPAGE}
Interface to the function @cfunc{\FUNCNAME\}, @MmuxCFuncpage{\MANPAGE\}
@end macro

@macro MmuxCInterface{FUNCNAME}
@MmuxCInterfaceTwo{\FUNCNAME\,\FUNCNAME\}
@end macro

@macro MmuxCMacroInterfaceTwo{FUNCNAME,MANPAGE}
Interface to the preprocessor macro @cfunc{\FUNCNAME\}, @MmuxCFuncpage{\MANPAGE\}
@end macro

@macro MmuxCMacroInterface{FUNCNAME}
@MmuxCMacroInterfaceTwo{\FUNCNAME\,\FUNCNAME\}
@end macro

@c ------------------------------------------------------------------------

@macro MmuxCStructOpaqueTypedef{STRUCTNAME}
@deftp {Opaque Struct Typedef} mmux_libc_\STRUCTNAME\_t
An opaque alias for @MmuxCStruct{\STRUCTNAME\}.
@end deftp

@end macro

@macro MmuxCStructPointerOpaqueTypedef{STRUCTNAME}
@deftp {Opaque Struct Pointer Typedef} mmux_libc_\STRUCTNAME\_ptr_t
An opaque alias for @code{mmux_libc_\STRUCTNAME\_t *}.
@end deftp

@end macro

@macro MmuxSetterGetter{STRUCTNAME, FIELDNAME, FIELDTYPE}
@deftypefun bool mmux_libc_\FIELDNAME\_set (mmux_libc_\STRUCTNAME\_t * @var{\STRUCTNAME\_p}, \FIELDTYPE\ @var{\FIELDNAME\})
@deftypefunx bool mmux_libc_\FIELDNAME\_ref (\FIELDTYPE\ * @var{result_p}, mmux_libc_\STRUCTNAME\_t const * @var{\STRUCTNAME\_p})
Setter and getter for the field @code{\FIELDNAME\} of @objtype{mmux_libc_\STRUCTNAME\_t}.
@end deftypefun

@end macro


@macro MmuxStructDumper{STRUCTNAME}
@MmuxStructDumperTwo{\STRUCTNAME\,struct \STRUCTNAME\}
@end macro


@macro MmuxStructDumperTwo{STRUCTNAME,STRUCTTYPE}
@deftypefun bool mmux_libc_\STRUCTNAME\_dump (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_\STRUCTNAME\_t const * @var{struct_p}, mmux_asciizcp_t @var{struct_name})
Write to @var{fd} a description of the fields of the @MmuxCStruct{\STRUCTNAME\} referenced by
@var{struct_p}.  @var{struct_name} must be a pointer to an @asciiz{} string representing the name of
the data structure used in the description; when @cnull{}: it defaults to @samp{\STRUCTTYPE\}.
@end deftypefun

@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C11 language
library implementing a wrapper to the @gnu{} C Library that makes it easier to interface it to
high--level platforms.

The package targets @posix{} platforms.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{MmuxPkgSemanticVersion}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-cc-libc: (mmux-cc-libc).       C11 language library wrapper for the @gnu{} C Library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* constants::                   Constants.
* version::                     Version functions.
* initialisation::              Library initialisation.
* errors::                      Errors management.
* memory::                      Memory management.
* strings::                     String operations.
* characters::                  Character operations.
* time::                        Times and dates.
* system::                      System configuration.
* persona::                     Persona operations.
* processes::                   Processes.
* signals::                     Interprocess signals handling.
* fds::                         File descriptors.
* fs::                          File system.
* sockets::                     Networking sockets.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C11 language
library implementing a wrapper to the @gnu{} C Library that makes it easier to interface it to
high--level platforms.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs multiple header files, of which @value{PackageHeaderFile} is the main one,
exporting the whole library @api{}.  All the function names in the @api{} are prefixed with
@code{@value{PackageApiPrefixLower}}; all the preprocessor symbol names are prefixed with
@code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

The library is installed under @code{$libdir}; for example:

@example
/usr/local/lib64/lib@value{PackageLibstem}.so
@end example

@noindent
C language header files are installed under @code{$includedir}, for example:

@example
/usr/local/include/@value{PackageHeaderFile}
@end example

Before using the library, we must initialise it by calling the appropriate function:

@example
mmux_cc_libc_init();
@end example

@menu
* overview stems::              Specifying C language types with their stem.
* overview errors::             Error handling.
* overview results::            Results handling.
* overview linking::            Linking code with the shared library.
@end menu

@c page
@node overview stems
@section Specifying C language types with their stem


@value{PACKAGE} uses the type definitions of the external package @emph{@mmux{} CC Types},
@mmuxcctypesref{overview stems, Specifying C language types with their stem}.

@c page
@node overview errors
@section Error handling


All the functions return a @objtype{bool} value: @cfalse{} when successful; @ctrue{} when an error
occurs.  The usual function call should look like this:

@example
if (mmux_libc_do_something()) @{
  /* error */
@}
@end example

If a function implemented by the @gnu{} C Library is interfaced by @value{PACKAGE} but it is not
available under a specific platform: the corresponding @value{PACKAGE} function is always
implemented; its return value is a @objtype{bool} and it is always @ctrue{}; it sets @code{errno} to
@samp{MMUX_LIBC_ENOSYS}.

@c page
@node overview results
@section Results handling


Unless otherwise specified, if the first argument of a function is a pointer named @var{result_p},
@var{output_p}, @var{ouput_p}, or similar: the function will store in the referenced location the
result of the call.

For example, we can write:

@example
mmux_slong_t    result;

if (mmux_libc_sysconf(&result, MMUX_LIBC__SC_PAGESIZE)) @{
  /* error */
@}
/* the result is in "result" */
@end example

@c page

@include overview-linking.texi

@c page
@node constants
@chapter Constants


@value{PACKAGE} attempts to offer all the constants implemented by the @gnu{} C Library; the name of
the @value{PACKAGE} constant is the original name prefixed with
@code{@value{PackageApiPrefixUpper}}.


@macro MmuxDefineConstant{NAME}
@defvr {Constant} @value{PackageApiPrefixUpper}\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{@value{PackageApiPrefixUpper}\NAME\} evaluates to the C language constant @code{\NAME\}; it can be
either a preprocessor symbol or an enumerated symbol; it can be defined or not depending on the
features of the underlying platform.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbol
@samp{@value{PackageApiPrefixUpper}\NAME\} is available.
@end defvr

@end macro

@MmuxDefineConstant{AT_EMPTY_PATH}
@MmuxDefineConstant{AT_FDCWD}
@MmuxDefineConstant{AT_NOAUTOMOUNT}
@MmuxDefineConstant{AT_REMOVEDIR}
@MmuxDefineConstant{AT_SYMLINK_FOLLOW}
@MmuxDefineConstant{EOF}
@MmuxDefineConstant{F_DUPFD}
@MmuxDefineConstant{F_GETFD}
@MmuxDefineConstant{F_GETFL}
@MmuxDefineConstant{F_GETLK}
@MmuxDefineConstant{F_GETOWN}
@MmuxDefineConstant{F_OFD_SETLK}
@MmuxDefineConstant{F_OFD_SETLKW}
@MmuxDefineConstant{F_OFD_GETLK}
@MmuxDefineConstant{F_OK}
@MmuxDefineConstant{F_RDLCK}
@MmuxDefineConstant{F_SETFD}
@MmuxDefineConstant{F_SETFL}
@MmuxDefineConstant{F_SETLK}
@MmuxDefineConstant{F_SETLKW}
@MmuxDefineConstant{F_SETOWN}
@MmuxDefineConstant{F_UNLCK}
@MmuxDefineConstant{F_WRLCK}
@MmuxDefineConstant{MAXSYMLINKS}
@MmuxDefineConstant{O_ACCMODE}
@MmuxDefineConstant{O_APPEND}
@MmuxDefineConstant{O_ASYNC}
@MmuxDefineConstant{O_CLOEXEC}
@MmuxDefineConstant{O_CREAT}
@MmuxDefineConstant{O_DIRECT}
@MmuxDefineConstant{O_DIRECTORY}
@MmuxDefineConstant{O_EXCL}
@MmuxDefineConstant{O_EXEC}
@MmuxDefineConstant{O_EXLOCK}
@MmuxDefineConstant{O_FSYNC}
@MmuxDefineConstant{O_IGNORE_CTTY}
@MmuxDefineConstant{O_LARGEFILE}
@MmuxDefineConstant{O_NDELAY}
@MmuxDefineConstant{O_NOATIME}
@MmuxDefineConstant{O_NOCTTY}
@MmuxDefineConstant{O_NOFOLLOW}
@MmuxDefineConstant{O_NOLINK}
@MmuxDefineConstant{O_NONBLOCK}
@MmuxDefineConstant{O_NOTRANS}
@MmuxDefineConstant{O_RDONLY}
@MmuxDefineConstant{O_RDWR}
@MmuxDefineConstant{O_READ}
@MmuxDefineConstant{O_SHLOCK}
@MmuxDefineConstant{O_SYNC}
@MmuxDefineConstant{O_TRUNC}
@MmuxDefineConstant{O_WRITE}
@MmuxDefineConstant{O_WRONLY}
@MmuxDefineConstant{R_OK}
@MmuxDefineConstant{RENAME_EXCHANGE}
@MmuxDefineConstant{RENAME_NOREPLACE}
@MmuxDefineConstant{RENAME_WITHEOUT}
@MmuxDefineConstant{RESOLVE_BENEATH}
@MmuxDefineConstant{RESOLVE_IN_ROOT}
@MmuxDefineConstant{RESOLVE_NO_MAGICLINKS}
@MmuxDefineConstant{RESOLVE_NO_SYMLINKS}
@MmuxDefineConstant{RESOLVE_NO_XDEV}
@MmuxDefineConstant{RESOLVE_CACHED}
@MmuxDefineConstant{SEEK_CUR}
@MmuxDefineConstant{SEEK_DATA}
@MmuxDefineConstant{SEEK_END}
@MmuxDefineConstant{SEEK_HOLE}
@MmuxDefineConstant{SEEK_SET}
@MmuxDefineConstant{S_IRGRP}
@MmuxDefineConstant{S_IROTH}
@MmuxDefineConstant{S_IRUSR}
@MmuxDefineConstant{S_IRWXG}
@MmuxDefineConstant{S_IRWXO}
@MmuxDefineConstant{S_IRWXU}
@MmuxDefineConstant{S_ISGID}
@MmuxDefineConstant{S_ISUID}
@MmuxDefineConstant{S_ISVTX}
@MmuxDefineConstant{S_IWGRP}
@MmuxDefineConstant{S_IWOTH}
@MmuxDefineConstant{S_IWUSR}
@MmuxDefineConstant{S_IXGRP}
@MmuxDefineConstant{S_IXOTH}
@MmuxDefineConstant{S_IXUSR}
@MmuxDefineConstant{MFD_CLOEXEC}
@MmuxDefineConstant{MFD_ALLOW_SEALING}
@MmuxDefineConstant{MFD_HUGETLB}
@MmuxDefineConstant{W_OK}
@MmuxDefineConstant{X_OK}
@MmuxDefineConstant{AF_ALG}
@MmuxDefineConstant{AF_APPLETALK}
@MmuxDefineConstant{AF_AX25}
@MmuxDefineConstant{AF_BLUETOOTH}
@MmuxDefineConstant{AF_CAN}
@MmuxDefineConstant{AF_DECnet}
@MmuxDefineConstant{AF_IB}
@MmuxDefineConstant{AF_INET6}
@MmuxDefineConstant{AF_INET}
@MmuxDefineConstant{AF_IPX}
@MmuxDefineConstant{AF_KCM}
@MmuxDefineConstant{AF_KEY}
@MmuxDefineConstant{AF_LLC}
@MmuxDefineConstant{AF_LOCAL}
@MmuxDefineConstant{AF_MPLS}
@MmuxDefineConstant{AF_NETLINK}
@MmuxDefineConstant{AF_PACKET}
@MmuxDefineConstant{AF_PPPOX}
@MmuxDefineConstant{AF_RDS}
@MmuxDefineConstant{AF_TIPC}
@MmuxDefineConstant{AF_UNIX}
@MmuxDefineConstant{AF_UNSPEC}
@MmuxDefineConstant{AF_VSOCK}
@MmuxDefineConstant{AF_X25}
@MmuxDefineConstant{AF_XDP}
@MmuxDefineConstant{IFNAMSIZ}
@MmuxDefineConstant{PF_FILE}
@MmuxDefineConstant{PF_INET6}
@MmuxDefineConstant{PF_INET}
@MmuxDefineConstant{PF_LOCAL}
@MmuxDefineConstant{PF_UNIX}
@MmuxDefineConstant{PF_UNSPEC}
@MmuxDefineConstant{SHUT_RDWR}
@MmuxDefineConstant{SHUT_RD}
@MmuxDefineConstant{SHUT_WR}
@MmuxDefineConstant{MSG_CONFIRM}
@MmuxDefineConstant{MSG_DONTROUTE}
@MmuxDefineConstant{MSG_DONTWAIT}
@MmuxDefineConstant{MSG_EOR}
@MmuxDefineConstant{MSG_MORE}
@MmuxDefineConstant{MSG_NOSIGNAL}
@MmuxDefineConstant{MSG_OOB}
@MmuxDefineConstant{MSG_PEEK}
@MmuxDefineConstant{SOL_SOCKET}
@MmuxDefineConstant{SO_BROADCAST}
@MmuxDefineConstant{SO_DEBUG}
@MmuxDefineConstant{SO_DONTROUTE}
@MmuxDefineConstant{SO_ERROR}
@MmuxDefineConstant{SO_KEEPALIVE}
@MmuxDefineConstant{SO_LINGER}
@MmuxDefineConstant{SO_OOBINLINE}
@MmuxDefineConstant{SO_RCVBUF}
@MmuxDefineConstant{SO_REUSEADDR}
@MmuxDefineConstant{SO_SNDBUF}
@MmuxDefineConstant{SO_STYLE}
@MmuxDefineConstant{SO_TYPE}
@MmuxDefineConstant{INADDR_ANY}
@MmuxDefineConstant{INADDR_BROADCAST}
@MmuxDefineConstant{INADDR_LOOPBACK}
@MmuxDefineConstant{INADDR_NONE}
@MmuxDefineConstant{AI_ADDRCONFIG}
@MmuxDefineConstant{AI_ADDRCONFIG}
@MmuxDefineConstant{AI_ALL}
@MmuxDefineConstant{AI_CANONIDN}
@MmuxDefineConstant{AI_CANONNAME}
@MmuxDefineConstant{AI_IDN}
@MmuxDefineConstant{AI_NUMERICSERV}
@MmuxDefineConstant{AI_PASSIVE}
@MmuxDefineConstant{AI_V4MAPPED}
@MmuxDefineConstant{NI_DGRAM}
@MmuxDefineConstant{NI_IDN}
@MmuxDefineConstant{NI_NAMEREQD}
@MmuxDefineConstant{NI_NOFQDN}
@MmuxDefineConstant{NI_NUMERICHOST}
@MmuxDefineConstant{NI_NUMERICSERV}

@MmuxDefineConstant{RWF_APPEND}
@MmuxDefineConstant{RWF_DSYNC}
@MmuxDefineConstant{RWF_HIPRI}
@MmuxDefineConstant{RWF_NOWAIT}
@MmuxDefineConstant{RWF_SYNC}

@MmuxDefineConstant{IPPROTO_AH}
@MmuxDefineConstant{IPPROTO_BEETPH}
@MmuxDefineConstant{IPPROTO_COMP}
@MmuxDefineConstant{IPPROTO_DCCP}
@MmuxDefineConstant{IPPROTO_EGP}
@MmuxDefineConstant{IPPROTO_ENCAP}
@MmuxDefineConstant{IPPROTO_ESP}
@MmuxDefineConstant{IPPROTO_ETHERNET}
@MmuxDefineConstant{IPPROTO_GRE}
@MmuxDefineConstant{IPPROTO_ICMP}
@MmuxDefineConstant{IPPROTO_IDP}
@MmuxDefineConstant{IPPROTO_IGMP}
@MmuxDefineConstant{IPPROTO_IP}
@MmuxDefineConstant{IPPROTO_IPIP}
@MmuxDefineConstant{IPPROTO_IPV6}
@MmuxDefineConstant{IPPROTO_MPLS}
@MmuxDefineConstant{IPPROTO_MPTCP}
@MmuxDefineConstant{IPPROTO_MTP}
@MmuxDefineConstant{IPPROTO_PIM}
@MmuxDefineConstant{IPPROTO_PUP}
@MmuxDefineConstant{IPPROTO_RAW}
@MmuxDefineConstant{IPPROTO_RSVP}
@MmuxDefineConstant{IPPROTO_SCTP}
@MmuxDefineConstant{IPPROTO_TCP}
@MmuxDefineConstant{IPPROTO_TP}
@MmuxDefineConstant{IPPROTO_UDP}
@MmuxDefineConstant{IPPROTO_UDPLITE}

@MmuxDefineConstant{IPPORT_BIFFUDP}
@MmuxDefineConstant{IPPORT_CMDSERVER}
@MmuxDefineConstant{IPPORT_DAYTIME}
@MmuxDefineConstant{IPPORT_DISCARD}
@MmuxDefineConstant{IPPORT_ECHO}
@MmuxDefineConstant{IPPORT_EFSSERVER}
@MmuxDefineConstant{IPPORT_EXECSERVER}
@MmuxDefineConstant{IPPORT_FINGER}
@MmuxDefineConstant{IPPORT_FTP}
@MmuxDefineConstant{IPPORT_LOGINSERVER}
@MmuxDefineConstant{IPPORT_MTP}
@MmuxDefineConstant{IPPORT_NAMESERVER}
@MmuxDefineConstant{IPPORT_NETSTAT}
@MmuxDefineConstant{IPPORT_RESERVED}
@MmuxDefineConstant{IPPORT_RJE}
@MmuxDefineConstant{IPPORT_ROUTESERVER}
@MmuxDefineConstant{IPPORT_SMTP}
@MmuxDefineConstant{IPPORT_SUPDUP}
@MmuxDefineConstant{IPPORT_SYSTAT}
@MmuxDefineConstant{IPPORT_TELNET}
@MmuxDefineConstant{IPPORT_TFTP}
@MmuxDefineConstant{IPPORT_TIMESERVER}
@MmuxDefineConstant{IPPORT_TTYLINK}
@MmuxDefineConstant{IPPORT_USERRESERVED}
@MmuxDefineConstant{IPPORT_WHOIS}
@MmuxDefineConstant{IPPORT_WHOSERVER}

@MmuxDefineConstant{SOCK_CLOEXEC}
@MmuxDefineConstant{SOCK_DCCP}
@MmuxDefineConstant{SOCK_DGRAM}
@MmuxDefineConstant{SOCK_NONBLOCK}
@MmuxDefineConstant{SOCK_PACKET}
@MmuxDefineConstant{SOCK_RAW}
@MmuxDefineConstant{SOCK_RDM}
@MmuxDefineConstant{SOCK_SEQPACKET}
@MmuxDefineConstant{SOCK_STREAM}

@MmuxDefineConstant{WAIT_ANY}
@MmuxDefineConstant{WAIT_MYPGRP}

@MmuxDefineConstant{WEXITED}
@MmuxDefineConstant{WNOHANG}
@MmuxDefineConstant{WNOWAIT}
@MmuxDefineConstant{WSTOPPED}
@MmuxDefineConstant{WCONTINUED}
@MmuxDefineConstant{WUNTRACED}

@MmuxDefineConstant{P_ALL}
@MmuxDefineConstant{P_PID}
@MmuxDefineConstant{P_PIDFD}
@MmuxDefineConstant{P_PGID}

@MmuxDefineConstant{EXIT_SUCCESS}
@MmuxDefineConstant{EXIT_FAILURE}

@defvr Constant @value{PackageApiPrefixUpper}MSG_ZERO
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_MSG_ZERO
The symbol @code{@value{PackageApiPrefixUpper}MSG_ZERO} evaluates to zero; it is meant to be used as
@var{flags} argument for @cfunc{mmux_libc_send}, and similar functions, when no other
@code{@value{PackageApiPrefixUpper}MSG_*} flag is needed; it gives the reader of the code a
remainder of which flags are available for the operation.

The symbol @code{MMUX_HAVE_LIBC_MSG_ZERO} is always defined and it evaluates to @samp{1}.
@end defvr

@MmuxDefineConstant{_SC_2_CHAR_TERM}
@MmuxDefineConstant{_SC_2_C_BIND}
@MmuxDefineConstant{_SC_2_C_DEV}
@MmuxDefineConstant{_SC_2_C_VERSION}
@MmuxDefineConstant{_SC_2_FORT_DEV}
@MmuxDefineConstant{_SC_2_FORT_RUN}
@MmuxDefineConstant{_SC_2_LOCALEDEF}
@MmuxDefineConstant{_SC_2_PBS}
@MmuxDefineConstant{_SC_2_PBS_ACCOUNTING}
@MmuxDefineConstant{_SC_2_PBS_CHECKPOINT}
@MmuxDefineConstant{_SC_2_PBS_LOCATE}
@MmuxDefineConstant{_SC_2_PBS_MESSAGE}
@MmuxDefineConstant{_SC_2_PBS_TRACK}
@MmuxDefineConstant{_SC_2_SW_DEV}
@MmuxDefineConstant{_SC_2_UPE}
@MmuxDefineConstant{_SC_2_VERSION}
@MmuxDefineConstant{_SC_ADVISORY_INFO}
@MmuxDefineConstant{_SC_AIO_LISTIO_MAX}
@MmuxDefineConstant{_SC_AIO_MAX}
@MmuxDefineConstant{_SC_AIO_PRIO_DELTA_MAX}
@MmuxDefineConstant{_SC_ARG_MAX}
@MmuxDefineConstant{_SC_ASYNCHRONOUS_IO}
@MmuxDefineConstant{_SC_ATEXIT_MAX}
@MmuxDefineConstant{_SC_AVPHYS_PAGES}
@MmuxDefineConstant{_SC_BARRIERS}
@MmuxDefineConstant{_SC_BASE}
@MmuxDefineConstant{_SC_BC_BASE_MAX}
@MmuxDefineConstant{_SC_BC_DIM_MAX}
@MmuxDefineConstant{_SC_BC_SCALE_MAX}
@MmuxDefineConstant{_SC_BC_STRING_MAX}
@MmuxDefineConstant{_SC_CHARCLASS_NAME_MAX}
@MmuxDefineConstant{_SC_CHAR_BIT}
@MmuxDefineConstant{_SC_CHAR_MAX}
@MmuxDefineConstant{_SC_CHAR_MIN}
@MmuxDefineConstant{_SC_CHILD_MAX}
@MmuxDefineConstant{_SC_CLK_TCK}
@MmuxDefineConstant{_SC_CLOCK_SELECTION}
@MmuxDefineConstant{_SC_COLL_WEIGHTS_MAX}
@MmuxDefineConstant{_SC_CPUTIME}
@MmuxDefineConstant{_SC_C_LANG_SUPPORT}
@MmuxDefineConstant{_SC_C_LANG_SUPPORT_R}
@MmuxDefineConstant{_SC_DELAYTIMER_MAX}
@MmuxDefineConstant{_SC_DEVICE_IO}
@MmuxDefineConstant{_SC_DEVICE_SPECIFIC}
@MmuxDefineConstant{_SC_DEVICE_SPECIFIC_R}
@MmuxDefineConstant{_SC_EQUIV_CLASS_MAX}
@MmuxDefineConstant{_SC_EXPR_NEST_MAX}
@MmuxDefineConstant{_SC_FD_MGMT}
@MmuxDefineConstant{_SC_FIFO}
@MmuxDefineConstant{_SC_FILE_ATTRIBUTES}
@MmuxDefineConstant{_SC_FILE_LOCKING}
@MmuxDefineConstant{_SC_FILE_SYSTEM}
@MmuxDefineConstant{_SC_FSYNC}
@MmuxDefineConstant{_SC_GETGR_R_SIZE_MAX}
@MmuxDefineConstant{_SC_GETPW_R_SIZE_MAX}
@MmuxDefineConstant{_SC_HOST_NAME_MAX}
@MmuxDefineConstant{_SC_INT_MAX}
@MmuxDefineConstant{_SC_INT_MIN}
@MmuxDefineConstant{_SC_IOV_MAX}
@MmuxDefineConstant{_SC_IPV6}
@MmuxDefineConstant{_SC_JOB_CONTROL}
@MmuxDefineConstant{_SC_LEVEL1_DCACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL1_DCACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL1_DCACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL1_ICACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL1_ICACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL1_ICACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL2_CACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL2_CACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL2_CACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL3_CACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL3_CACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL3_CACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL4_CACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL4_CACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL4_CACHE_SIZE}
@MmuxDefineConstant{_SC_LINE_MAX}
@MmuxDefineConstant{_SC_LOGIN_NAME_MAX}
@MmuxDefineConstant{_SC_LONG_BIT}
@MmuxDefineConstant{_SC_MAPPED_FILES}
@MmuxDefineConstant{_SC_MB_LEN_MAX}
@MmuxDefineConstant{_SC_MEMLOCK}
@MmuxDefineConstant{_SC_MEMLOCK_RANGE}
@MmuxDefineConstant{_SC_MEMORY_PROTECTION}
@MmuxDefineConstant{_SC_MESSAGE_PASSING}
@MmuxDefineConstant{_SC_MONOTONIC_CLOCK}
@MmuxDefineConstant{_SC_MQ_OPEN_MAX}
@MmuxDefineConstant{_SC_MQ_PRIO_MAX}
@MmuxDefineConstant{_SC_MULTI_PROCESS}
@MmuxDefineConstant{_SC_NETWORKING}
@MmuxDefineConstant{_SC_NGROUPS_MAX}
@MmuxDefineConstant{_SC_NL_ARGMAX}
@MmuxDefineConstant{_SC_NL_LANGMAX}
@MmuxDefineConstant{_SC_NL_MSGMAX}
@MmuxDefineConstant{_SC_NL_NMAX}
@MmuxDefineConstant{_SC_NL_SETMAX}
@MmuxDefineConstant{_SC_NL_TEXTMAX}
@MmuxDefineConstant{_SC_NPROCESSORS_CONF}
@MmuxDefineConstant{_SC_NPROCESSORS_ONLN}
@MmuxDefineConstant{_SC_NZERO}
@MmuxDefineConstant{_SC_OPEN_MAX}
@MmuxDefineConstant{_SC_PAGESIZE}
@MmuxDefineConstant{_SC_PAGE_SIZE}
@MmuxDefineConstant{_SC_PASS_MAX}
@MmuxDefineConstant{_SC_PHYS_PAGES}
@MmuxDefineConstant{_SC_PII}
@MmuxDefineConstant{_SC_PII_INTERNET}
@MmuxDefineConstant{_SC_PII_INTERNET_DGRAM}
@MmuxDefineConstant{_SC_PII_INTERNET_STREAM}
@MmuxDefineConstant{_SC_PII_OSI}
@MmuxDefineConstant{_SC_PII_OSI_CLTS}
@MmuxDefineConstant{_SC_PII_OSI_COTS}
@MmuxDefineConstant{_SC_PII_OSI_M}
@MmuxDefineConstant{_SC_PII_SOCKET}
@MmuxDefineConstant{_SC_PII_XTI}
@MmuxDefineConstant{_SC_PIPE}
@MmuxDefineConstant{_SC_POLL}
@MmuxDefineConstant{_SC_PRIORITIZED_IO}
@MmuxDefineConstant{_SC_PRIORITY_SCHEDULING}
@MmuxDefineConstant{_SC_RAW_SOCKETS}
@MmuxDefineConstant{_SC_READER_WRITER_LOCKS}
@MmuxDefineConstant{_SC_REALTIME_SIGNALS}
@MmuxDefineConstant{_SC_REGEXP}
@MmuxDefineConstant{_SC_REGEX_VERSION}
@MmuxDefineConstant{_SC_RE_DUP_MAX}
@MmuxDefineConstant{_SC_RTSIG_MAX}
@MmuxDefineConstant{_SC_SAVED_IDS}
@MmuxDefineConstant{_SC_SCHAR_MAX}
@MmuxDefineConstant{_SC_SCHAR_MIN}
@MmuxDefineConstant{_SC_SELECT}
@MmuxDefineConstant{_SC_SEMAPHORES}
@MmuxDefineConstant{_SC_SEM_NSEMS_MAX}
@MmuxDefineConstant{_SC_SEM_VALUE_MAX}
@MmuxDefineConstant{_SC_SHARED_MEMORY_OBJECTS}
@MmuxDefineConstant{_SC_SHELL}
@MmuxDefineConstant{_SC_SHRT_MAX}
@MmuxDefineConstant{_SC_SHRT_MIN}
@MmuxDefineConstant{_SC_SIGNALS}
@MmuxDefineConstant{_SC_SIGQUEUE_MAX}
@MmuxDefineConstant{_SC_SINGLE_PROCESS}
@MmuxDefineConstant{_SC_SPAWN}
@MmuxDefineConstant{_SC_SPIN_LOCKS}
@MmuxDefineConstant{_SC_SPORADIC_SERVER}
@MmuxDefineConstant{_SC_SSIZE_MAX}
@MmuxDefineConstant{_SC_STREAMS}
@MmuxDefineConstant{_SC_STREAM_MAX}
@MmuxDefineConstant{_SC_SYMLOOP_MAX}
@MmuxDefineConstant{_SC_SYNCHRONIZED_IO}
@MmuxDefineConstant{_SC_SYSTEM_DATABASE}
@MmuxDefineConstant{_SC_SYSTEM_DATABASE_R}
@MmuxDefineConstant{_SC_THREADS}
@MmuxDefineConstant{_SC_THREAD_ATTR_STACKADDR}
@MmuxDefineConstant{_SC_THREAD_ATTR_STACKSIZE}
@MmuxDefineConstant{_SC_THREAD_CPUTIME}
@MmuxDefineConstant{_SC_THREAD_DESTRUCTOR_ITERATIONS}
@MmuxDefineConstant{_SC_THREAD_KEYS_MAX}
@MmuxDefineConstant{_SC_THREAD_PRIORITY_SCHEDULING}
@MmuxDefineConstant{_SC_THREAD_PRIO_INHERIT}
@MmuxDefineConstant{_SC_THREAD_PRIO_PROTECT}
@MmuxDefineConstant{_SC_THREAD_PROCESS_SHARED}
@MmuxDefineConstant{_SC_THREAD_SAFE_FUNCTIONS}
@MmuxDefineConstant{_SC_THREAD_SPORADIC_SERVER}
@MmuxDefineConstant{_SC_THREAD_STACK_MIN}
@MmuxDefineConstant{_SC_THREAD_THREADS_MAX}
@MmuxDefineConstant{_SC_TIMEOUTS}
@MmuxDefineConstant{_SC_TIMERS}
@MmuxDefineConstant{_SC_TIMER_MAX}
@MmuxDefineConstant{_SC_TRACE}
@MmuxDefineConstant{_SC_TRACE_EVENT_FILTER}
@MmuxDefineConstant{_SC_TRACE_INHERIT}
@MmuxDefineConstant{_SC_TRACE_LOG}
@MmuxDefineConstant{_SC_TTY_NAME_MAX}
@MmuxDefineConstant{_SC_TYPED_MEMORY_OBJECTS}
@MmuxDefineConstant{_SC_TZNAME_MAX}
@MmuxDefineConstant{_SC_T_IOV_MAX}
@MmuxDefineConstant{_SC_UCHAR_MAX}
@MmuxDefineConstant{_SC_UINT_MAX}
@MmuxDefineConstant{_SC_UIO_MAXIOV}
@MmuxDefineConstant{_SC_ULONG_MAX}
@MmuxDefineConstant{_SC_USER_GROUPS}
@MmuxDefineConstant{_SC_USER_GROUPS_R}
@MmuxDefineConstant{_SC_USHRT_MAX}
@MmuxDefineConstant{_SC_V6_ILP32_OFF32}
@MmuxDefineConstant{_SC_V6_ILP32_OFFBIG}
@MmuxDefineConstant{_SC_V6_LP64_OFF64}
@MmuxDefineConstant{_SC_V6_LPBIG_OFFBIG}
@MmuxDefineConstant{_SC_VERSION}
@MmuxDefineConstant{_SC_WORD_BIT}
@MmuxDefineConstant{_SC_XBS5_ILP32_OFF32}
@MmuxDefineConstant{_SC_XBS5_ILP32_OFFBIG}
@MmuxDefineConstant{_SC_XBS5_LP64_OFF64}
@MmuxDefineConstant{_SC_XBS5_LPBIG_OFFBIG}
@MmuxDefineConstant{_SC_XOPEN_CRYPT}
@MmuxDefineConstant{_SC_XOPEN_ENH_I18N}
@MmuxDefineConstant{_SC_XOPEN_LEGACY}
@MmuxDefineConstant{_SC_XOPEN_REALTIME}
@MmuxDefineConstant{_SC_XOPEN_REALTIME_THREADS}
@MmuxDefineConstant{_SC_XOPEN_SHM}
@MmuxDefineConstant{_SC_XOPEN_UNIX}
@MmuxDefineConstant{_SC_XOPEN_VERSION}
@MmuxDefineConstant{_SC_XOPEN_XCU_VERSION}
@MmuxDefineConstant{_SC_XOPEN_XPG2}
@MmuxDefineConstant{_SC_XOPEN_XPG3}
@MmuxDefineConstant{_SC_XOPEN_XPG4}

@MmuxDefineConstant{_CS_LFS64_CFLAGS}
@MmuxDefineConstant{_CS_LFS64_LDFLAGS}
@MmuxDefineConstant{_CS_LFS64_LIBS}
@MmuxDefineConstant{_CS_LFS64_LINTFLAGS}
@MmuxDefineConstant{_CS_LFS_CFLAGS}
@MmuxDefineConstant{_CS_LFS_LDFLAGS}
@MmuxDefineConstant{_CS_LFS_LIBS}
@MmuxDefineConstant{_CS_LFS_LINTFLAGS}
@MmuxDefineConstant{_CS_PATH}

@MmuxDefineConstant{_PC_ASYNC_IO}
@MmuxDefineConstant{_PC_CHOWN_RESTRICTED}
@MmuxDefineConstant{_PC_FILESIZEBITS}
@MmuxDefineConstant{_PC_LINK_MAX}
@MmuxDefineConstant{_PC_MAX_CANON}
@MmuxDefineConstant{_PC_MAX_INPUT}
@MmuxDefineConstant{_PC_NAME_MAX}
@MmuxDefineConstant{_PC_NO_TRUNC}
@MmuxDefineConstant{_PC_PATH_MAX}
@MmuxDefineConstant{_PC_PIPE_BUF}
@MmuxDefineConstant{_PC_PRIO_IO}
@MmuxDefineConstant{_PC_REC_INCR_XFER_SIZE}
@MmuxDefineConstant{_PC_REC_MAX_XFER_SIZE}
@MmuxDefineConstant{_PC_REC_MIN_XFER_SIZE}
@MmuxDefineConstant{_PC_REC_XFER_ALIGN}
@MmuxDefineConstant{_PC_SYNC_IO}
@MmuxDefineConstant{_PC_VDISABLE}

@MmuxDefineConstant{RLIMIT_AS}
@MmuxDefineConstant{RLIMIT_CORE}
@MmuxDefineConstant{RLIMIT_CPU}
@MmuxDefineConstant{RLIMIT_DATA}
@MmuxDefineConstant{RLIMIT_FSIZE}
@MmuxDefineConstant{RLIMIT_LOCKS}
@MmuxDefineConstant{RLIMIT_MEMLOCK}
@MmuxDefineConstant{RLIMIT_MSGQUEUE}
@MmuxDefineConstant{RLIMIT_NICE}
@MmuxDefineConstant{RLIMIT_NOFILE}
@MmuxDefineConstant{RLIMIT_NPROC}
@MmuxDefineConstant{RLIMIT_RSS}
@MmuxDefineConstant{RLIMIT_RTPRIO}
@MmuxDefineConstant{RLIMIT_RTTIME}
@MmuxDefineConstant{RLIMIT_SIGPENDING}
@MmuxDefineConstant{RLIMIT_STACK}
@MmuxDefineConstant{RLIM_INFINITY}

@MmuxDefineConstant{NSIG}
@MmuxDefineConstant{SIGFPE}
@MmuxDefineConstant{SIGILL}
@MmuxDefineConstant{SIGSEGV}
@MmuxDefineConstant{SIGBUS}
@MmuxDefineConstant{SIGABRT}
@MmuxDefineConstant{SIGIOT}
@MmuxDefineConstant{SIGTRAP}
@MmuxDefineConstant{SIGEMT}
@MmuxDefineConstant{SIGSYS}
@MmuxDefineConstant{SIGTERM}
@MmuxDefineConstant{SIGINT}
@MmuxDefineConstant{SIGQUIT}
@MmuxDefineConstant{SIGKILL}
@MmuxDefineConstant{SIGHUP}
@MmuxDefineConstant{SIGALRM}
@MmuxDefineConstant{SIGVRALRM}
@MmuxDefineConstant{SIGPROF}
@MmuxDefineConstant{SIGIO}
@MmuxDefineConstant{SIGURG}
@MmuxDefineConstant{SIGPOLL}
@MmuxDefineConstant{SIGCHLD}
@MmuxDefineConstant{SIGCLD}
@MmuxDefineConstant{SIGCONT}
@MmuxDefineConstant{SIGSTOP}
@MmuxDefineConstant{SIGTSTP}
@MmuxDefineConstant{SIGTTIN}
@MmuxDefineConstant{SIGTTOU}
@MmuxDefineConstant{SIGPIPE}
@MmuxDefineConstant{SIGLOST}
@MmuxDefineConstant{SIGXCPU}
@MmuxDefineConstant{SIGXSFZ}
@MmuxDefineConstant{SIGUSR1}
@MmuxDefineConstant{SIGUSR2}
@MmuxDefineConstant{SIGWINCH}
@MmuxDefineConstant{SIGINFO}

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {mmux_asciizcp_t} mmux_cc_libc_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_cc_libc_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_cc_libc_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_cc_libc_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node initialisation
@chapter Library initialisation


@deftypefun bool mmux_cc_libc_init (void)
Initialise library's internal state; we can safely call this function multimple times.  When
successful return @cfalse{}; otherwise return @ctrue{}.
@end deftypefun

@c page
@node errors
@chapter Errors management


@cindex @code{errno} variable
@cindex Variacle @code{errno}
@cindex Error handling
@cindex Handling errors


@deftypefun bool mmux_libc_errno_set (mmux_sint_t @var{errnum})
Setter for the standard @code{errno} variable.  The return value is always @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_errno_ref (mmux_sint_t * @var{result_errnum_p})
Getter for the standard @code{errno} variable: always store the current value of @code{errno} in the
location referenced by @var{result_errnum_p}.  When @code{errno} is zero: the return value is
@ctrue{}, there is no reason to query @code{errno}; otherwise it is @cfalse{}.

@example
mmux_sint_t     errnum;

if (mmux_libc_errno_ref(&errnum)) @{
  ... /* there was no error: why are we querying "errno"? */
@} else @{
  mmux_asciizcp_t       errmsg;

  mmux_libc_strerror(&errmsg, errnum);
  ... /* handle the error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_errno_consume (mmux_sint_t * @var{result_errnum_p})
Getter--and--resetter for the standard @code{errno} variable: always store the current value of
@code{errno} in the location referenced by @var{result_errnum_p}, then reset @code{errno} to zero.
Upon calling this function, when @code{errno} is zero: the return value is @ctrue{}, there is no
reason to query @code{errno}; otherwise it is @cfalse{}.

@example
mmux_sint_t     errnum;

if (mmux_libc_errno_consume(&errnum)) @{
  ... /* there was no error: why are we querying "errno"? */
@} else @{
  mmux_asciizcp_t       errmsg;

  mmux_libc_strerror(&errmsg, errnum);
  ... /* handle the error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strerror (mmux_asciizcp_t * @var{result_error_message_p}, mmux_sint_t @var{errnum})
@MmuxCInterface{strerror}.  The return value is always @cfalse{}.

Often we want to compose strings using a memory--mapped file descriptor, so we call
@cfunc{mmux_libc_memfd_strerror} instead of this function, @ref{mmux_libc_memfd_strerror} for details.

Otherwise we may want to call @cfunc{mmux_libc_dprintf_strerror}; @ref{mmux_libc_dprintf_strerror}
for details.
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_strerror_r (mmux_asciizcpp_t @var{result_p}, mmux_asciizp_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{errnum})
@MmuxCInterface{strerror_r}.  This is the @gnu{} variant of this function.

We must use the arguments @var{bufptr} and @var{buflen} to provide a buffer in which the string
could be written: it is up to @cfunc{strerror_r} to use it or not.  If the call is successful: we
just use the pointer stored in the variable referenced by @var{result_p}.  A @var{buflen} of
@samp{1024} should be enough to hold any string.

@example
mmux_asciizcp_t         result;
mmux_usize_t            buflen = 1024;
mmux_char_t             bufptr[buflen];

if (mmux_libc_strerror_r(&result, bufptr, buflen, MMUX_LIBC_EINVAL)) @{
  /* error */
@}

if (mmux_libc_dprintfer("strerror_r result: %s\n", result)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_strerrorname_np (mmux_asciizcpp_t result_p, mmux_sint_t errnum)
@MmuxCInterface{strerrorname_np}.  This is the @gnu{} variant of this function.

The following code example should print @samp{EINVAL}:

@example
mmux_asciizcp_t result;

if (mmux_libc_strerrorname_np(&result, MMUX_LIBC_EINVAL)) @{
  /* error */
@}

if (mmux_libc_dprintfer("strerrorname_np result: %s", result)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_strerrordesc_np (mmux_asciizcpp_t result_p, mmux_sint_t errnum)
@MmuxCInterface{strerrordesc_np}.  This is the @gnu{} variant of this function.

The following code example should print @samp{Invalid argument}:

@example
mmux_asciizcp_t result;

if (mmux_libc_strerrordesc_np(&result, MMUX_LIBC_EINVAL)) @{
  /* error */
@}

if (mmux_libc_dprintfer("strerrordesc_np result: %s", result)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_program_invocation_name (mmux_asciizcpp_t @var{result_p})
Store in the variable referenced by @var{result_p} a pointer to the @gnu{} C Library global variable
@code{program_invocation_name}.  @glibcref{Error Messages, Error Messages}.
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_program_invocation_short_name (mmux_asciizcpp_t @var{result_p})
Store in the variable referenced by @var{result_p} a pointer to the @gnu{} C Library global variable
@code{program_invocation_short_name}.  @glibcref{Error Messages, Error Messages}.
@end deftypefn

@c page
@node memory
@chapter Memory management


@menu
* memory allocation::           Memory allocation.
* memory operations::           Memory operations.
@end menu

@c page
@node memory allocation
@section Memory allocation


@deftypefn {Preprocessor Macro} bool mmux_libc_malloc (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{len})
@deftypefnx {Function} bool mmux_libc_malloc_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{len})
@MmuxCInterface{malloc}.  The macro just casts a pointer @var{P_p} of any type to @code{mmux_pointer_t
*}.  Upon successful return: the pointer variable referenced by @var{P_p} is set to the pointer
referencing the newly allocated memory block.

@example
mmux_libc_tm_t *  tm;

if (mmux_libc_malloc(&tm, sizeof(mmux_libc_tm_t))) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_calloc (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx Function bool mmux_libc_calloc_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@MmuxCInterface{calloc}.  The macro just casts a pointer @var{P_p} of any type to @code{mmux_pointer_t
*}.  Upon successful return: the pointer variable referenced by @var{P_p} is set to the pointer
referencing the newly allocated memory block.

@example
mmux_double_t *  P;

if (mmux_libc_calloc(&P, 123, sizeof(mmux_double_t))) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_realloc (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{newlen})
@deftypefnx Function bool mmux_libc_realloc_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{newlen})
@MmuxCInterface{realloc}.  The macro just casts a pointer @var{P_p} of any type to @code{mmux_pointer_t
*}.

@itemize
@item
Upon calling this function: @var{P_p} must reference a pointer variable holding the pointer to the
memory block to reallocate.

@item
Upon successfully returning from this function: the pointer variable referenced by @var{P_p} holds
the new pointer.
@end itemize

@example
mmux_libc_tm_t *  tm;

if (mmux_libc_malloc(&tm, 1024)) @{
  /* error */
@}
if (mmux_libc_realloc(&tm, 4096)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_reallocarray (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx Function bool mmux_libc_reallocarray_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@MmuxCInterface{reallocarray}.  The macro just casts a pointer @var{P_p} of any type to
@code{mmux_pointer_t *}.  Upon successful return: the pointer variable referenced by @var{P_p} is
set to the pointer referencing the newly allocated memory block.

@example
mmux_double_t *  P;

if (mmux_libc_calloc(&P, 123, sizeof(mmux_double_t))) @{
  /* error */
@}
if (mmux_libc_reallocarray(&P, 456, sizeof(mmux_double_t))) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_free (mmux_pointer_t @var{P})
@MmuxCInterface{free}.
@end deftypefun

@c page
@node memory operations
@section Memory operations


@deftypefun bool mmux_libc_memset (mmux_pointer_t @var{ptr}, mmux_uint8_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memset}.
@end deftypefun


@deftypefun bool mmux_libc_memzero (mmux_pointer_t @var{ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memzero}.
@end deftypefun


@deftypefun bool mmux_libc_memcpy (mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memcpy}.
@end deftypefun


@deftypefun bool mmux_libc_mempcpy (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{mempcpy}.
@end deftypefun


@deftypefun bool mmux_libc_memccpy (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_uint8_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memccpy}.
@end deftypefun


@deftypefun bool mmux_libc_memmove (mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memmove}.
@end deftypefun


@deftypefun bool mmux_libc_memcmp (mmux_sint_t * @var{result_p}, mmux_pointerc_t @vari{ptr}, mmux_pointerc_t @varii{ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memcmp}.
@end deftypefun


@deftypefun bool mmux_libc_memchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memchr}.
@end deftypefun


@deftypefun bool mmux_libc_rawmemchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet})
@MmuxCInterface{rawmemchr}.
@end deftypefun


@deftypefun bool mmux_libc_memrchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memrchr}.
@end deftypefun


@deftypefun bool mmux_libc_memmem (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{haystack_ptr}, mmux_usize_t @var{haystack_len}, mmux_pointer_t @var{needle_ptr}, mmux_usize_t @var{needle_len})
@MmuxCInterface{memmem}.
@end deftypefun

@c page
@node strings
@chapter String operations


@menu
* strings inspection::          Inspecting @asciiz{} strings.
* strings duplication::         Duplicating @asciiz{} strings.
* strings concatenation::       Concatenating @asciiz{} strings.
* strings comparison::          Comparing @asciiz{} strings.
* strings collation::           Collation builtins for @asciiz{} strings.
* strings searching::           Searching in @asciiz{} strings.
* strings tokens::              Finding tokens in @asciiz{} strings.
@end menu

@c page
@node strings inspection
@section Inspecting @asciiz{} strings


@deftypefun bool mmux_libc_strlen (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr})
@MmuxCInterface{strlen}.

@example
mmux_asciizcp_t         bufptr = "hello world";
mmux_usize_t            buflen;

if (mmux_libc_strlen(&buflen, bufptr)) @{
  /* error, it should never happen */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strlen_plus_nil (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr})
Wrapper for @cfunc{mmux_libc_strlen} that adds @samp{1} to the result of the call to @cfunc{strlen};
so the number of characters stored in the variable referenced by @var{result_len_p} includes the
terminating null character.
@end deftypefun


@deftypefun bool mmux_libc_strnlen (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr}, mmux_usize_t @var{maxlen})
@MmuxCInterface{strnlen}.

@example
mmux_asciizcp_t         bufptr = "hello world";
mmux_usize_t            buflen;

if (mmux_libc_strnlen(&buflen, bufptr, 4096)) @{
  /* error, it should never happen */
@}
@end example
@end deftypefun

@c page
@node strings duplication
@section Duplicating @asciiz{} strings


@deftypefun bool mmux_libc_strcpy (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{strcpy}.
@end deftypefun


@deftypefun bool mmux_libc_strncpy (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncpy}.
@end deftypefun


@deftypefun bool mmux_libc_stpcpy(mmux_asciizp_t * @var{result_after_ptr_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{stpcpy}.
@end deftypefun


@deftypefun bool mmux_libc_stpncpy(mmux_asciizp_t * @var{result_after_ptr_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{stpncpy}.
@end deftypefun


@deftypefun bool mmux_libc_strdup (mmux_asciizcp_t * @var{result_oustr_p}, mmux_asciizcp_t @var{instr})
@MmuxCInterface{strdup}.
@end deftypefun


@deftypefun bool mmux_libc_strndup (mmux_asciizcp_t * @var{result_oustr_p}, mmux_asciizcp_t @var{instr}, mmux_usize_t @var{len})
@MmuxCInterface{strndup}.
@end deftypefun

@c page
@node strings concatenation
@section Concatenating @asciiz{} strings


@deftypefun bool mmux_libc_strcat (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{strcat}.
@end deftypefun


@deftypefun bool mmux_libc_strncat (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncat}.
@end deftypefun

@c page
@node strings comparison
@section Comparing @asciiz{} strings


@deftypefun bool mmux_libc_strcmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr})
@MmuxCInterface{strcmp}.
@end deftypefun


@deftypefun bool mmux_libc_strncmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncmp}.
@end deftypefun


@deftypefun bool mmux_libc_strcasecmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr})
@MmuxCInterface{strcasecmp}.
@end deftypefun


@deftypefun bool mmux_libc_strncasecmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncasecmp}.
@end deftypefun


@deftypefun bool mmux_libc_strverscmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr})
@MmuxCInterface{strverscmp}.
@end deftypefun

@c page
@node strings collation
@section Collation builtins for @asciiz{} strings


@deftypefun bool mmux_libc_strcoll (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr})
@MmuxCInterface{strcoll}.
@end deftypefun


@deftypefun bool mmux_libc_strxfrm (mmux_usize_t * @var{result_size_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strxfrm}.
@end deftypefun

@c page
@node strings searching
@section Searching in @asciiz{} strings


@deftypefun bool mmux_libc_strchr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strchr}.
@end deftypefun


@deftypefun bool mmux_libc_strchrnul (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strchrnul}.
@end deftypefun


@deftypefun bool mmux_libc_strrchr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strrchr}.
@end deftypefun


@deftypefun bool mmux_libc_strstr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{haystack}, mmux_asciizcp_t @var{needle})
@MmuxCInterface{strstr}.
@end deftypefun


@deftypefun bool mmux_libc_strcasestr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{haystack}, mmux_asciizcp_t @var{needle})
@MmuxCInterface{strcasestr}.
@end deftypefun


@deftypefun bool mmux_libc_strspn (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{skipset})
@MmuxCInterface{strspn}.
@end deftypefun


@deftypefun bool mmux_libc_strcspn (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{stopset})
@MmuxCInterface{strcspn}.
@end deftypefun


@deftypefun bool mmux_libc_strpbrk (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{stopset})
@MmuxCInterface{strpbrk}.
@end deftypefun

@c page
@node strings tokens
@section Finding tokens in @asciiz{} strings


@deftypefun bool mmux_libc_strtok (mmux_asciizcp_t * @var{result_p}, mmux_asciizp_t @var{newstring}, mmux_asciizcp_t @var{delimiters})
@MmuxCInterface{strtok}.
@end deftypefun


@deftypefun bool mmux_libc_basename (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{pathname})
@MmuxCInterface{basename}.
@end deftypefun


@deftypefun bool mmux_libc_dirname (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{pathname})
@MmuxCInterface{dirname}.
@end deftypefun

@c page
@node characters
@chapter Character operations


@menu
* characters classes::          Character classes.
* characters capital::          Character capitalisation.
@end menu

@c page
@node characters classes
@section Character classes


@deftypefun bool mmux_libc_islower (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{islower}.
@end deftypefun


@deftypefun bool mmux_libc_isupper (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isupper}.
@end deftypefun


@deftypefun bool mmux_libc_isalpha (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isalpha}.
@end deftypefun


@deftypefun bool mmux_libc_isdigit (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isdigit}.
@end deftypefun


@deftypefun bool mmux_libc_isalnum (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isalnum}.
@end deftypefun


@deftypefun bool mmux_libc_isxdigit (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isxdigit}.
@end deftypefun


@deftypefun bool mmux_libc_ispunct (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{ispunct}.
@end deftypefun


@deftypefun bool mmux_libc_isspace (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isspace}.
@end deftypefun


@deftypefun bool mmux_libc_isblank (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isblank}.
@end deftypefun


@deftypefun bool mmux_libc_isgraph (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isgraph}.
@end deftypefun


@deftypefun bool mmux_libc_isprint (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isprint}.
@end deftypefun


@deftypefun bool mmux_libc_iscntrl (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{iscntrl}.
@end deftypefun


@deftypefun bool mmux_libc_isascii (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isascii}.
@end deftypefun

@c page
@node characters capital
@section Character capitalisation


@deftypefun bool mmux_libc_tolower (mmux_schar_t * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{tolower}.
@end deftypefun


@deftypefun bool mmux_libc_toupper (mmux_schar_t * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{toupper}.
@end deftypefun

@c page
@node time
@chapter Times and dates


@menu
* time timeval::                The @objtype{mmux_libc_timeval_t} type.
* time timespec::               The @objtype{mmux_libc_timespec_t} type.
* time tm::                     The @objtype{mmux_libc_tm_t} type.
* time acquiring::              Acquiring the current time.
* time epoch time::             Converting from Epoch time to other formats.
* time broken time::            Converting from broken time to other formats.
* time format::                 Formatting string timestamps.
* time scanning::               Converting from string timestamps to other formats.
* time sleeping::               Suspending a process for a time.
@end menu

@c page
@node time timeval
@section The @objtype{mmux_libc_timeval_t} type


@MmuxCStructOpaqueTypedef{timeval}
@MmuxSetterGetter{timeval, tv_sec,  mmux_time_t}
@MmuxSetterGetter{timeval, tv_usec, mmux_slong_t}
@MmuxStructDumper{timeval}


@deftypefun bool mmux_libc_timeval_set (mmux_libc_timeval_t * @var{timeval_p}, mmux_time_t @var{seconds}, mmux_slong_t @var{microseconds})
Initialise the fields of a @MmuxCStruct{timeval}.
@end deftypefun

@c page
@node time timespec
@section The @objtype{mmux_libc_timespec_t} type


To have more expressive names: in this @api{} we ``rename'' the fields @samp{tv_sec} and
@samp{tv_nsec} of @MmuxCStruct{timespec} to @samp{ts_sec} and @samp{ts_nsec}.


@MmuxCStructOpaqueTypedef{timespec}
@MmuxSetterGetter{timespec, ts_sec,  mmux_time_t}
@MmuxSetterGetter{timespec, ts_nsec, mmux_slong_t}
@MmuxStructDumper{timespec}


@deftypefun bool mmux_libc_timespec_set (mmux_libc_timeval_t * @var{timeval_p}, mmux_time_t @var{seconds}, mmux_slong_t @var{nanoseconds})
Initialise the fields of a @MmuxCStruct{timespec}.
@end deftypefun

@c page
@node time tm
@section The @objtype{mmux_libc_tm_t} type


@MmuxCStructOpaqueTypedef{tm}
@MmuxSetterGetter{tm, tm_sec,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_min,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_hour,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_mday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_mon,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_year,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_wday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_yday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_isdst,       mmux_sint_t}
@MmuxSetterGetter{tm, tm_gmtoff,      mmux_slong_t}
@MmuxSetterGetter{tm, tm_zone,        mmux_asciizcp_t}
@MmuxStructDumper{tm}


@deftypefun bool mmux_libc_tm_reset (mmux_libc_tm_t * @var{TM_P})
Reset the fields to:

@example
tm_sec    = 0
tm_min    = 0
tm_hour   = 0
tm_mday   = 1
tm_mon    = 0
tm_year   = 0
tm_wday   = 0
tm_yday   = 0
tm_isdst  = 0
tm_gmtoff = 0
tm_zone   = NULL
@end example
@end deftypefun

@c page
@node time acquiring
@section Acquiring the current time


@deftypefun bool mmux_libc_time (mmuc_time_t * @var{result_p})
@MmuxCInterface{time}.

@example
mmux_time_t         T;

mmux_libc_time(&T);
@{
  mmux_libc_fd_t    fd;

  mmux_libc_libou(&fd);
  if (mmux_libc_dprintf_time(fd, T)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node time epoch time
@section Converting from Epoch time to other formats


@deftypefun bool mmux_libc_localtime (mmux_libc_tm_t * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{localtime}.  Store in the variable referenced by @var{result_p} a pointer to a
statically allocated @objtype{mmux_libc_tm_t} that will be overwritten by future calls to time
functions; we should just use @cfunc{mmux_libc_localtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t *        BT;

mmux_libc_time(&T);
mmux_libc_localtime(&BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_localtime_r (mmux_libc_tm_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{localtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t          BT[1];

mmux_libc_time(&T);
mmux_libc_localtime_r(BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_gmtime (mmux_libc_tm_t * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{gmtime}.  Store in the variable referenced by @var{result_p} a pointer to a
statically allocated @objtype{mmux_libc_tm_t} that will be overwritten by future calls to time
functions; we should just use @cfunc{mmux_libc_gmtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t *        BT;

mmux_libc_time(&T);
mmux_libc_gmtime(&BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_gmtime_r (mmux_libc_tm_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{gmtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t          BT[1];

mmux_libc_time(&T);
mmux_libc_gmtime_r(BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_ctime (mmux_asciizcp_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{ctime}.  The variable referenced by @var{result_p} is set to a pointer to a
statically allocated string, which will be overwritten by future calls to time functions; we should
just use @cfunc{mmux_libc_ctime_r}.

@example
mmux_time_t         T;
mmux_asciizcp_t     bufptr;

mmux_libc_time(&T);
mmux_libc_asctime(&bufptr, T);
if (mmux_libc_dprintfer("the timestamp from ctime is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_ctime_r (mmux_asciizp_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{ctime_r}.

@example
mmux_time_t         T;
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK            512
mmux_char_t         bufptr[IS_THIS_ENOUGH_QUESTION_MARK];

mmux_libc_time(&T);
mmux_libc_asctime_r(bufptr, T);
if (mmux_libc_dprintfer("the timestamp from ctime_r is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node time broken time
@section Converting from broken time to other formats


@deftypefun bool mmux_libc_mktime (mmux_time_t * @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{mktime}.

@example
mmux_time_t     T1, T2;
mmux_libc_tm_t  BT[1];

mmux_libc_time(&T1);
mmux_libc_localtime_r(BT, T1);
mmux_libc_mktime(&T2, BT);
@{
  mmux_libc_fd_t    fd;

  mmux_libc_libou(&fd);
  if (mmux_libc_dprintf_time(fd, T2)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_timegm (mmux_time_t * @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{timegm}.

@example
mmux_time_t     T1, T2;
mmux_libc_tm_t  BT[1];

mmux_libc_time(&T1);
mmux_libc_localtime_r(BT, T1);
mmux_libc_timegm(&T2, BT);
@{
  mmux_libc_fd_t    fd;

  mmux_libc_libou(&fd);
  if (mmux_libc_dprintf_time(fd, T2)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_asctime (mmux_asciizcp_t * @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{asctime}.  The variable referenced by @var{result_p} is set to a pointer to a
statically allocated string, which will be overwritten by future calls to time functions; we should
just use @cfunc{mmux_libc_asctime_r}.

@example
mmux_time_t         T;
mmux_libc_tm_t      BT[1];
mmux_asciizcp_t     bufptr;

mmux_libc_time(&T);
mmux_libc_localtime_r(BT, T);
mmux_libc_asctime(&bufptr, BT);
if (mmux_libc_dprintfer("the timestamp from asctime is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_asctime_r (mmux_asciizcp_t @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{asctime_r}.

@example
mmux_time_t         T;
mmux_libc_tm_t      BT[1];
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK            512
mmux_char_t         bufptr[IS_THIS_ENOUGH_QUESTION_MARK];

mmux_libc_time(&T);
mmux_libc_localtime_r(BT, T);
mmux_libc_asctime_r(bufptr, BT);
if (mmux_libc_dprintfer("the timestamp from asctime_r is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node time format
@section Formatting string timestamps


@deftypefun bool mmux_libc_strftime_required_nbytes_including_nil (mmux_usize_t * @var{required_nbytes_including_nil_p}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
When successful: store in the variable referenced by @var{required_nbytes_including_nil_p} the
number of bytes, @strong{including} the terminating zero, required to hold the string generated by
@cfunc{strftime} when applied to @var{template} to format a time specification from the broken time
@var{BT}.
@end deftypefun


@anchor{mmux_libc_strftime}
@deftypefun bool mmux_libc_strftime (mmux_usize_t * @var{required_nbytes_without_zero_p}, mmux_asciizp_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{strftime}.  Format an output string representation of the timestamp referenced by
@var{BT} according to @var{template}, and store it in the buffer referenced by @var{bufptr}; at
most @var{buflen} characters, including the terminating zero, will be written to @var{bufptr}.

When successful: the generated string length, without the terminating zero, is stored in the
variable referenced by @var{required_nbytes_without_zero_p}.

It is sometimes better to use the function @cfunc{mmux_libc_dprintf_strftime},
@ref{mmux_libc_dprintf_strftime} for details.

@example
mmux_asciizcp_t         template = "%Y-%m-%dT%H:%M:%S%z";
mmux_time_t             T;
mmux_libc_tm_t *        BT;
mmux_usize_t            required_nbytes_including_nil;

mmux_libc_time(&T);
mmux_libc_localtime(&BT, T);

if (mmux_libc_strftime_required_nbytes_including_nil(&required_nbytes_including_nil, template, BT) @{
  /* error */
@} else @{
  mmux_char_t           bufptr[required_nbytes_including_nil];
  mmux_usize_t          required_nbytes_without_zero;

  if (mmux_libc_strftime(&required_nbytes_without_zero, bufptr, required_nbytes_including_nil, template, BT)) @{
    /* error */
  @}
@}
mmux_libc_dprintfou("%s\n", bufptr);
@end example
@end deftypefun

@c page
@node time scanning
@section Converting from string timestamps to other formats


@deftypefun bool mmux_libc_strptime (char ** @var{first_unprocessed_after_timestamp_p}, mmux_asciizcp_t @var{input_string}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{strptime}.

@example
mmux_asciizcp_t      template     = "%a, %d %b %Y %H:%M:%S %z";
mmux_asciizcp_t      input_string = "Fri, 15 Nov 2024 23:11:20 +0100";
mmux_libc_tm_t *  BT;
char *            first_unprocessed_after_timestamp;

if (mmux_libc_calloc(&BT, 1, sizeof(mmux_libc_tm_t)) @{
  /* error */
@}
if (mmux_libc_strptime(&first_unprocessed_after_timestamp, input_string, template, BT)) @{
  /* error */
@}
mmux_libc_tm_dump(MMUX_LIBC_STDOU, BT, NULL);
@end example
@end deftypefun

@c page
@node time sleeping
@section Suspending a process for a time


@deftypefun mmux_uint_t mmux_libc_sleep (mmux_uint_t * @var{leftover_result_p}, mmux_uint_t @var{seconds})
@MmuxCInterface{sleep}.
@end deftypefun


@deftypefun bool mmux_libc_nanosleep (mmux_libc_timespec_t * @var{requested_time}, mmux_libc_timespec_t * @var{remaining_time})
@MmuxCInterface{nanosleep}.

@example
mmux_libc_timespec_t    requested_time;
mmux_libc_timespec_t    remaining_time;

mmux_libc_timespec_set(&requested_time, 12, 34);
if (mmux_libc_nanosleep(&requested_time, &remaining_time)) @{
  /* error or interruption */
@}
@end example
@end deftypefun

@c page
@node system
@chapter System configuration


@menu
* system parameters::           Configuration parameters.
* system limits::               Configuration limits.
@end menu

@c page
@node system parameters
@section Configuration parameters


@cindex @samp{MMUX_LIBC_SC_} constants
@cindex @samp{MMUX_LIBC_CS_} constants
@cindex Constants @samp{MMUX_LIBC_SC_}
@cindex Constants @samp{MMUX_LIBC_CS_}


@deftypefun bool mmux_libc_sysconf (mmux_slong_t * @var{result_p}, mmux_sint_t @var{parameter})
@MmuxCInterface{sysconf}.  @var{parameter} must be one of the @samp{MMUX_LIBC__SC_*} constants.

@example
mmux_slong_t    result;

if (mmux_libc_sysconf(&result, MMUX_LIBC__SC_PAGESIZE)) @{
  /* error */
@}
/* the result is in "result" */
@end example
@end deftypefun


@deftypefun bool mmux_libc_confstr_size (mmux_usize_t * @var{result_required_nbytes_p}, mmux_sint_t @var{parameter})
@deftypefunx bool mmux_libc_confstr (mmux_sint_t @var{parameter}, char * @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{confstr}.  @var{parameter} must be one of the @samp{MMUX_LIBC__CS_*} constants.

@example
mmux_sint_t     parameter = MMUX_LIBC__CS_PATH;
mmux_usize_t    required_nbytes;

if (mmux_libc_confstr_size(&required_nbytes, parameter)) @{ /* error */ @}
@{
  char value[required_nbytes];

  if (mmux_libc_confstr(parameter, value, required_nbytes)) @{ /* error */ @}
  /* the result is in "value" */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pathconf (mmux_slong_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{parameter})
@MmuxCInterface{pathconf}.
@end deftypefun


@deftypefun bool mmux_libc_fpathconf (mmux_slong_t * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{parameter})
@MmuxCInterface{fpathconf}.
@end deftypefun

@c page
@node system limits
@section Configuration limits


@MmuxCStructOpaqueTypedef{rlimit}
@MmuxSetterGetter{rlimit, rlim_cur, mmux_rlim_t}
@MmuxSetterGetter{rlimit, rlim_max, mmux_rlim_t}
@MmuxStructDumper{rlimit}


@deftypefun bool mmux_libc_getrlimit (mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{rlimit_p})
@MmuxCInterface{getrlimit}.
@end deftypefun


@deftypefun bool mmux_libc_setrlimit (mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{rlimit_p})
@MmuxCInterface{setrlimit}.
@end deftypefun


@deftypefun bool mmux_libc_prlimit (mmux_libc_pid_t @var{pid}, mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{new_rlimit_p}, mmux_libc_rlimit_t * @var{old_rlimit_p})
@MmuxCInterface{prlimit}.
@end deftypefun

@c page
@node persona
@chapter Persona operations


@menu
* persona uids::                Representing UIDs.
* persona gids::                Representing GIDs.
* persona getting::             Getting users and groups.
* persona setting::             Setting users and groups.
* persona login::               Identifying who logged in.
* persona database user::       User database.
* persona database group::      Group database.
@end menu

@c page
@node persona uids
@section Representing UIDs


To obtain a UID value and convert it to string, we can do:

@example
mmux_libc_uid_t         the_uid;
mmux_usize_t            required_nchars;

mmux_libc_getuid(&the_uid);

if (mmux_libc_uid_sprint_size(&required_nchars, the_uid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_uid_sprint(str, required_nchars, the_uid) @{
    /* error */
  @}
@}
@end example


@deftp {Opaque Struct Alias} mmux_libc_uid_t
Type of data structure containing a value of type @objtype{mmux_uid_t}.
@end deftp


@deftypefun bool mmux_libc_make_uid (mmux_libc_uid_t * @var{result_p}, mmux_uid_t @var{uid_num})
Build a new value of type @objtype{mmux_libc_uid_t}.
@end deftypefun


@deftypefun bool mmux_libc_uid_parse (mmux_libc_uid_t * @var{uid_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_uid_t}
value; store the value in the location referenced by @var{uid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_uid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_uid_t @var{uid})
Determine the number of characters required to contain the string representation of @var{uid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_uid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_uid_t @var{uid})
Convert @var{uid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node persona gids
@section Representing GIDs


To obtain a GID value and convert it to string, we can do:

@example
mmux_libc_gid_t         the_gid;
mmux_usize_t            required_nchars;

mmux_libc_getgid(&the_gid);

if (mmux_libc_gid_sprint_size(&required_nchars, the_gid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_gid_sprint(str, required_nchars, the_gid) @{
    /* error */
  @}
@}
@end example


@deftp {Opaque Struct Alias} mmux_libc_gid_t
Type of data structure containing a value of type @objtype{mmux_gid_t}.
@end deftp


@deftypefun bool mmux_libc_make_gid (mmux_libc_gid_t * @var{result_p}, mmux_gid_t @var{gid_num})
Build a new value of type @objtype{mmux_libc_gid_t}.
@end deftypefun


@deftypefun bool mmux_libc_gid_parse (mmux_libc_gid_t * @var{gid_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_gid_t}
value; store the value in the location referenced by @var{gid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_gid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_gid_t @var{gid})
Determine the number of characters required to contain the string representation of @var{gid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_gid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_gid_t @var{gid})
Convert @var{gid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node persona getting
@section Getting users and groups


@deftypefun bool mmux_libc_getuid (mmux_libc_uid_t * @var{result_p})
@MmuxCInterface{getuid}.
@end deftypefun


@deftypefun bool mmux_libc_getgid (mmux_libc_gid_t * @var{result_p})
@MmuxCInterface{getgid}.
@end deftypefun


@deftypefun bool mmux_libc_geteuid (mmux_libc_uid_t * @var{result_p})
@MmuxCInterface{geteuid}.
@end deftypefun


@deftypefun bool mmux_libc_getegid (mmux_libc_gid_t * @var{result_p})
@MmuxCInterface{getegid}.
@end deftypefun


To retrieve the supplementary groups of the current process we do:

@example
mmux_usize_t    ngroups;

if (mmux_libc_getgroups_size(&ngroups)) @{
  /* error */
@} else @{
  mmux_libc_gid_t       gids[ngroups];

  if (mmux_libc_getgroups(&ngroups, gids)) @{
    /* error */
  @} else @{
    /* do something with gids */
  @}
@}
@end example


@deftypefun bool mmux_libc_getgroups_size (mmux_usize_t * @var{result_ngroups_p})
Determine the number of supplementary groups of the current process and store it in the location
referenced by @var{ngroups_p}.
@end deftypefun


@deftypefun bool mmux_libc_getgroups (mmux_usize_t * @var{ngroups_p}, mmux_libc_gid_t * @var{groups_p})
@MmuxCInterface{getgroups}.  Fill the array referenced by @var{groups_p} with values representing
the supplementary groups of the current process.

@itemize
@item
Upon entering the function call: the array must have a number of elements equal to the value
referenced by @var{ngroups_p}.

@item
Upon returning from the function call: the location referenced by @var{ngroups_p} is updated with
the actual number of values stored in the array.
@end itemize
@end deftypefun


To retrieve the groups a user belongs to we do:

@example
mmux_asciizcp_t    user_name = gimme_a_username();
mmux_libc_git_t user_gid  = gimme_its_gid(user_name);
mmux_usize_t    ngroups;

if (mmux_libc_getgrouplist_size(&ngroups, user_name, user_gid)) @{
  /* error */
@} else @{
  mmux_libc_gid_t       gids[ngroups];

  if (mmux_libc_getgrouplist(user_name, user_gid, &ngroups, gids)) @{
    /* error */
  @} else @{
    /* do something with gids */
  @}
@}
@end example


@deftypefun bool mmux_libc_getgrouplist_size (mmux_usize_t * @var{result_ngroups_p}, mmux_asciizcp_t @var{username}, mmux_libc_gid_t @var{gid})
Determine the number of groups a user belongs to and store it in the location referenced by
@var{ngroups_p}.
@end deftypefun


@deftypefun bool mmux_libc_getgrouplist (mmux_asciizcp_t @var{username}, mmux_libc_gid_t @var{gid}, mmux_usize_t * @var{ngroups_p}, mmux_libc_gid_t * @var{groups_p})
@MmuxCInterface{getgrouplist}.  Fill the array referenced by @var{groups_p} with values representing
the groups a user belongs to.

@itemize
@item
Upon entering the function call: the array must have a number of elements equal to the value
referenced by @var{ngroups_p}.

@item
Upon returning from the function call: the location referenced by @var{ngroups_p} is updated with
the actual number of values stored in the array.
@end itemize
@end deftypefun

@c page
@node persona setting
@section Setting users and groups


@deftypefun bool mmux_libc_setuid (mmux_libc_uid_t @var{uid})
@MmuxCInterface{setuid}.
@end deftypefun


@deftypefun bool mmux_libc_seteuid (mmux_libc_uid_t @var{uid})
@MmuxCInterface{seteuid}.
@end deftypefun


@deftypefun bool mmux_libc_setreuid (mmux_libc_uid_t @var{uid}, mmux_libc_uid_t @var{euid})
@MmuxCInterface{setreuid}.
@end deftypefun


@deftypefun bool mmux_libc_setgid (mmux_libc_gid_t @var{gid})
@MmuxCInterface{setgid}.
@end deftypefun


@deftypefun bool mmux_libc_setegid (mmux_libc_gid_t @var{gid})
@MmuxCInterface{setegid}.
@end deftypefun


@deftypefun bool mmux_libc_setregid (mmux_libc_gid_t @var{gid}, mmux_libc_gid_t @var{egid})
@MmuxCInterface{setregid}.
@end deftypefun

@c page
@node persona login
@section Identifying who logged in


@deftypefun bool mmux_libc_getlogin (mmux_asciizcp_t * @var{result_username_p})
@MmuxCInterface{getlogin}.
@end deftypefun

@c page
@node persona database user
@section User database


@MmuxCStructOpaqueTypedef{passwd}
@MmuxSetterGetter{passwd,	pw_name,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_passwd,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_uid,		mmux_libc_uid_t}
@MmuxSetterGetter{passwd,	pw_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{passwd,	pw_gecos,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_dir,		mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_shell,	mmux_asciizcp_t}
@MmuxStructDumper{passwd}


@deftypefun bool mmux_libc_getpwuid (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_libc_uid_t @var{uid})
@MmuxCInterface{getpwuid}.
@end deftypefun


@deftypefun bool mmux_libc_getpwnam (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_asciizcp_t @var{username})
@MmuxCInterface{getpwnam}.
@end deftypefun


@deftypefun bool mmux_libc_setpwent (void)
@MmuxCInterface{setpwent}.
@end deftypefun


@deftypefun bool mmux_libc_endpwent (void)
@MmuxCInterface{endpwent}.
@end deftypefun


@deftypefun bool mmux_libc_getpwent (mmux_libc_passwd_t * * @var{result_passwd_pp})
@MmuxCInterface{getpwent}.
@end deftypefun

@c page
@node persona database group
@section Group database


@MmuxCStructOpaqueTypedef{group}
@MmuxSetterGetter{group,	gr_name,	mmux_asciizcp_t}
@MmuxSetterGetter{group,	gr_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{group,	gr_mem,		mmux_asciizcp_t*}
@MmuxStructDumper{group}


@deftypefun bool mmux_libc_getgrgid (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{getgrgid}.
@end deftypefun


@deftypefun bool mmux_libc_getgrnam (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_asciizcp_t @var{groupname})
@MmuxCInterface{getgrnam}.
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_group_member (bool * @var{result_is_member_p}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{group_member}.
@end deftypefn


@deftypefun bool mmux_libc_setgrent (void)
@MmuxCInterface{setgrent}.
@end deftypefun


@deftypefun bool mmux_libc_endgrent (void)
@MmuxCInterface{endgrent}.
@end deftypefun


@deftypefun bool mmux_libc_getgrent (mmux_libc_group_t * * @var{result_group_pp})
@MmuxCInterface{getgrent}.
@end deftypefun

@c page
@node processes
@chapter Processes


@menu
* processes pids::              Representing PIDs.
* processes statuses::          Representing process completion--statuses.
* processes getting::           Getting PIDs.
* processes forking::           Forking processes.
* processes waiting::           Waiting for process completion.
* processes exiting::           Exiting processes.
@end menu

@c page
@node processes pids
@section Representing PIDs


@deftp {Opaque Struct Typedef} mmux_libc_pid_t
Opaque data structure type representing a @objtype{mmux_pid_t}.
@end deftp


@deftypefun bool mmux_libc_make_pid (mmux_libc_pid_t * @var{result_p}, mmux_pid_t @var{pid_num})
Build a new value of type @objtype{mmux_libc_pid_t}.
@end deftypefun


@deftypefun bool mmux_libc_make_pid_zero (mmux_libc_pid_t * @var{result_p})
Build a new value of type @objtype{mmux_libc_pid_t} whose process identifier equals zero.  This is
useful for neutral initialisation of some data structures like @objtype{mmux_libc_flock_t}.
@end deftypefun


@deftypefun bool mmux_libc_make_pid_minus_one (mmux_libc_pid_t * @var{result_p})
Build a new value of type @objtype{mmux_libc_pid_t} whose process identifier equals @samp{-1}.  This
is useful for special initialisation of some data structures like @objtype{mmux_libc_flock_t}, in
which a process identifier equal to @samp{-1} is used for file description locks, @glibcref{Open
File Description Locks, Open File Description Locks}.
@end deftypefun


@deftypefun bool mmux_libc_pid_equal (mmux_libc_pid_t @vari{pid}, mmux_libc_pid_t @varii{pid})
Return true if @vari{pid} and  @varii{pid} are equal.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_pid_t the_pid;
mmux_usize_t    required_nchars;

mmux_libc_getpid (&the_pid);

if (mmux_libc_pid_sprint_size(&required_nchars, the_pid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_pid_sprint(str, required_nchars, the_pid) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_pid_parse (mmux_libc_pid_t * @var{pid_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_pid_t}
value; store the value in the location referenced by @var{pid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_pid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_pid_t @var{pid})
Determine the number of characters required to contain the string representation of @var{pid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_pid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_pid_t @var{pid})
Convert @var{pid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node processes statuses
@section Representing process completion--statuses


@deftp {Opaque Struct Typedef} mmux_libc_completed_process_status_t
Opaque data structure type representing a process completion--status, which is a
@objtype{mmux_sint_t} value.
@end deftp


@deftypefun bool mmux_libc_make_process_completion_status (mmux_libc_completed_process_status_t * @var{result_p}, mmux_sint_t @var{status_num})
Build a new value of type @objtype{mmux_libc_completed_process_status_t}.
@end deftypefun


@deftypefun bool mmux_libc_completed_process_status_equal (mmux_libc_completed_process_status_t @vari{status}, mmux_libc_completed_process_status_t @varii{status})
Return true if @vari{status} and @varii{status} are equal.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_completed_process_status_t    the_status = ...;
mmux_usize_t                            required_nchars;

if (mmux_libc_completed_process_status_sprint_size(&required_nchars, the_status) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_completed_process_status_sprint(str, required_nchars, the_status) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_completed_process_status_parse (mmux_libc_completed_process_status_t * @var{status_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a
@objtype{mmux_libc_completed_process_status_t} value; store the value in the location referenced by
@var{status_p}.  If an error occurs and @var{who} is not @cnull{}: print an error message to
@stderr{} using @var{who} as name of the entity that performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_completed_process_status_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_completed_process_status_t @var{status})
Determine the number of characters required to contain the string representation of @var{status} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_completed_process_status_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_completed_process_status_t @var{status})
Convert @var{status} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_WIFEXITED (bool * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFEXITED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WEXITSTATUS (mmux_sint_t * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WEXITSTATUS,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WIFSIGNALED (bool * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFSIGNALED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WTERMSIG (mmux_libc_interprocess_signal_t * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WTERMSIG,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WCOREDUMP (bool * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WCOREDUMP,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WIFSTOPPED (bool * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFSTOPPED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WSTOPSIG (mmux_libc_interprocess_signal_t * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WSTOPSIG,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WIFCONTINUED (bool * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFCONTINUED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun

@c page
@node processes getting
@section Getting PIDs


@deftypefun bool mmux_libc_getpid  (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gitpid}.
@end deftypefun


@deftypefun  bool mmux_libc_getppid (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gitppid}.
@end deftypefun


@deftypefun bool mmux_libc_gettid (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gittid}.
@end deftypefun

@c page
@node processes forking
@section Forking processes


@deftypefun bool mmux_libc_fork (bool * @var{this_is_the_parent_process_p}, mmux_libc_pid_t * @var{child_process_pid_p})
@MmuxCInterface{fork}.  When a call is successful:

Regarding the argument @var{this_is_the_parent_process_p}: the referenced variable is mutated only
when a call is successful, otherwise it is left untouched.

@itemize
@item
In the parent process: the referenced variable is set to @ctrue{}.

@item
In the child process: the referenced variable is set to @cfalse{}.
@end itemize

Regarding the argument @var{child_process_pid_p}: the referenced variable is mutated only in the
parent process and when a call is successful, otherwise it is left untouched.

@itemize
@item
In the parent process: the referenced variable is set to the child process identifier.

@item
In the child process: the referenced variable is left untouched.
@end itemize

@example
bool                    this_is_the_parent_process;
mmux_libc_pid_t         child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  mmux_sint_t         errnum;

  mmux_libc_errno_consume(&errnum);
  ... /* handle the error */
@} else if (this_is_the_parent_process) @{
  ... /* do something in the parent process, maybe using "child_pid" */
@} else @{
  ... /* do something in the child process */
@}
@end example
@end deftypefun

@c page
@node processes waiting
@section Waiting for process completion


@menu
* processes waiting args::      Convention for common arguments.
* processes waiting waitpid::   Waiting with @cfunc{waitpid}.
* processes waiting other::     Waiting with other functions.
@end menu

@c page
@node processes waiting args
@subsection Convention for common arguments


This section documents the common arguments in calls to process--completion waiting--functions.  For
all the documented functions:

@table @code
@item bool * @var{completed_process_status_available_p}
pointer argument which cannot be @cnull{}; when the function call is successful:

@itemize
@item
if we have collected the completion status of a process: the referenced variable is set to @ctrue{};

@item
if no completion status was collected: the referenced variable is set to @cfalse{};
@end itemize

@noindent
when the function call is a failure: the referenced variable is left untouched;

@item mmux_libc_pid_t * @var{completed_process_pid_p}
pointer argument which cannot be @cnull{}; when the function call is successful and we have
collected the completion status of a process: the PID of the completed process is stored in the
referenced variable, otherwise the variable is left untouched;

@item mmux_libc_completed_process_status_t * @var{completed_process_status_p}
pointer argument which cannot be @cnull{}; when the function call is successful and we have
collected the completion status of a process: such status is stored in the referenced variable,
otherwise the variable is left untouched.
@end table

@c page
@node processes waiting waitpid
@subsection Waiting with @cfunc{waitpid}


For the documentation of the common arguments see @ref{processes waiting args, Convention for common
arguments}.


@deftypefun bool mmux_libc_wait_any_process (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of any child process.

@example
bool                                    completed_process_status_available;
mmux_libc_pid_t                         completed_process_pid;
mmux_libc_completed_process_status_t    completed_process_status;

if (mmux_libc_wait_any_process(&completed_process_status_available, &completed_process_pid,
                               &completed_process_status, MMUX_LIBC_WNOHANG)) @{
  ... /* handle the error */
@} else @{
  if (completed_process_status_available) @{
    ... /* do something with "completed_process_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_my_process_group (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of any child process in the same process group
of the calling process.

@example
bool                                    completed_process_status_available;
mmux_libc_pid_t                         completed_process_pid;
mmux_libc_completed_process_status_t    completed_process_status;

if (mmux_libc_wait_my_process_group(&completed_process_status_available, &completed_process_pid,
                                    &completed_process_status, MMUX_LIBC_WNOHANG)) @{
  ... /* handle the error */
@} else @{
  if (completed_process_status_available) @{
    ... /* do something with "completed_process_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_process_id (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p}, mmux_libc_pid_t @var{pid}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of a specific process whose process identifier
is @var{pid}.

@example
bool                    this_is_the_parent_process;
mmux_libc_pid_t         child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  ... /* handle the error */
@} else if (this_is_the_parent_process) @{
  bool                                  completed_process_status_available;
  mmux_libc_pid_t                       completed_process_pid;
  mmux_libc_completed_process_status_t  completed_process_status;

  if (mmux_libc_wait_process_id(&completed_process_status_available, &completed_process_pid,
                                &completed_process_status, child_pid, MMUX_LIBC_WNOHANG)) @{
    ... /* handle the error */
  @} else @{
    if (completed_process_status_available) @{
      ... /* do something with "completed_process_status" */
    @} else @{
      ... /* no completed process status was collected */
    @}
  @}
@} else @{
  ... /* do something in the child process */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_group_id (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_sint_t * @var{completed_process_status_p}, mmux_libc_gid_t @var{gid}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of any process belonging to the process group
@var{gid}.

@example
mmux_libc_gid_t       the_gid;

if (mmux_libc_getgid(&the_gid)) @{
  ... /* handle the error */
@} else @{
  bool                                  completed_process_status_available;
  mmux_libc_pid_t                       completed_process_pid;
  mmux_libc_completed_process_status_t  completed_process_status;

  if (mmux_libc_wait_group_id(&completed_process_status_available, &completed_process_pid,
                              &completed_process_status, the_gid, MMUX_LIBC_WNOHANG)) @{
    ... /* handle the error */
  @} else @{
    if (completed_process_status_available) @{
      ... /* do something with "completed_process_status" */
    @} else @{
      ... /* no completed process status was collected */
    @}
  @}
@}
@end example
@end deftypefun

@c page
@node processes waiting other
@subsection Waiting with other functions


For the documentation of the common arguments see @ref{processes waiting args, Convention for common
arguments}.


@deftypefun bool mmux_libc_wait (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p})
@MmuxCInterface{wait}.  Wait for the termination of any child process.

@example
bool                                    completed_process_status_available;
mmux_libc_pid_t                         completed_process_pid;
mmux_libc_completed_process_status_t    completed_process_status;

if (mmux_libc_wait(&completed_process_status_available, &completed_process_pid, &completed_process_status)) @{
  ... /* handle the error */
@} else @{
  if (completed_process_status_available) @{
    ... /* do something with "completed_process_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@}
@end example
@end deftypefun

@c page
@node processes exiting
@section Exiting processes


@deftypefun bool mmux_libc_exit (mmux_sint_t @var{status})
@MmuxCInterface{exit}.
@end deftypefun


@deftypefun bool mmux_libc_exit_success (void)
@deftypefunx bool mmux_libc_exit_failure (void)
Wrappers for @cfunc{mmux_libc_exit} that terminate the current process with, respectively, the
status @code{MMUX_LIBC_EXIT_SUCCESS} or @code{MMUX_LIBC_EXIT_FAILURE}.
@end deftypefun


@deftypefun bool mmux_libc__exit (mmux_sint_t @var{status})
@MmuxCInterface{_exit}.
@end deftypefun


@deftypefun bool mmux_libc_atexit (void (* @var{function_pointer}) (void))
@MmuxCInterface{atexit}.
@end deftypefun

@c page
@node signals
@chapter Interprocess signals handling


@menu
* signals signals::             Representing interprocess signals.
* signals delivering::          Delivering interprocess signals.
* signals bub::                 Block/unblock interprocess signals handling.
* signals handling::            Other interprocess signals delivering methods.
@end menu

@c page
@node signals signals
@section Representing interprocess signals


@deftp {Opaque Struct Typedef} mmux_libc_interprocess_signal_t
Opaque data structure type representing an interprocess signal number.
@end deftp


@deftypefun bool mmux_libc_make_interprocess_signal (mmux_libc_interprocess_signal_t * @var{result_p}, mmux_sint_t @var{signal_number})
Build a new value of type @objtype{mmux_libc_interprocess_signal_t}.

@example
mmux_libc_interprocess_signal_t ipxsig;

if (mmux_libc_make_interprocess_signal(&ipxsig, MMUX_LIBC_SIGUSR1) @{
  ... /* this error happens only if @var{signal_number} is negative */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signal_equal (mmux_libc_interprocess_signal_t @vari{ipxsig}, mmux_libc_interprocess_signal_t @varii{ipxsig})
Return true if @vari{ipxsig} and  @varii{ipxsig} are equal.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_interprocess_signal_t         ipxsig;
mmux_usize_t                            required_nchars;

mmux_libc_make_interprocess_signal(&the_signal_number, MMUX_LIBC_SIGUSR1);

if (mmux_libc_interprocess_signal_sprint_size(&required_nchars, ipxsig) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_interprocess_signal_sprint(str, required_nchars, ipxsig) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_interprocess_signal_parse (mmux_libc_interprocess_signal_t * @var{ipxsig_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a
@objtype{mmux_libc_interprocess_signal_t} value; store the value in the location referenced by
@var{ipxsig_p}.  If an error occurs and @var{who} is not @cnull{}: print an error message to
@stderr{} using @var{who} as name of the entity that performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signal_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_interprocess_signal_t @var{ipxsig})
Determine the number of characters required to contain the string representation of @var{ipxsig} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signal_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_interprocess_signal_t @var{ipxsig})
Convert @var{ipxsig} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node signals delivering
@subsection Delivering interprocess signals


@deftypefun bool mmux_libc_raise (mmux_libc_interprocess_signal_t @var{ipxsignal})
@MmuxCInterface{raise}.

To deliver a signal to the calling process we do:

@example
mmux_libc_interprocess_signal_t         ipxsignal;

mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
if (mmux_libc_raise(ipxsignal)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_kill (mmux_libc_pid_t pid, mmux_libc_interprocess_signal_t @var{ipxsignal})
@MmuxCInterface{kill}.

To deliver the signal @samp{SIGUSR1} to a child process we do:

@example
bool                    this_is_the_parent_process;
mmux_libc_pid_t         child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  /* error */
@} else if (this_is_the_parent_process) @{
  mmux_libc_interprocess_signal_t         ipxsignal;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  if (mmux_libc_kill(child_pid, ipxsignal)) @{
    /* error */
  @}
@} else @{
  ... /* do something in the child process */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_kill_all_processes_in_same_group (mmux_libc_interprocess_signal_t @var{ipxsignal})
Call the C library function @cfunc{signal} setting the first argument to @samp{0}: it delivers the
signal to all the processes in the same group as the delivering process.
@end deftypefun


@deftypefun bool mmux_libc_kill_group (mmux_libc_gid_t @var{gid}, mmux_libc_interprocess_signal_t @var{ipxsignal})
Deliver the signal to all the processes in the group @var{gid}.
@end deftypefun


@deftypefun bool mmux_libc_kill_all_processes (mmux_libc_interprocess_signal_t @var{ipxsignal})
Call the C library function @cfunc{signal} setting the first argument to @samp{-1}: it delivers the
signal to ``all'' processes, see the documentation for details.  @glibcref{Signaling Another
Process, Signaling Another Process}.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_tgkill (mmux_libc_pid_t @var{pid}, mmux_libc_pid_t @var{tid}, mmux_libc_interprocess_signal_t @var{ipxsignal})
@MmuxCInterface{tgkill}.  Deliver the signal to thread @var{tid} belonging to the process @var{pid}.
@end deftypefn

@c page
@node signals bub
@subsection Block/unblock interprocess signals handling


@cindex @bub{} interprocess signals @api{}
@cindex @bub{} signals @api{}
@cindex Block/unblock interprocess signals @api{}
@cindex Interprocess signals, block/unblock @api{}
@cindex Signals, block/unblock @api{}


The block/unblock (@bub{}) @api{} is a simplified interface to detect the arrival of interprocess
signals; if it does not suit the application's model, we should just ignore it.  It is impossible to
use the @bub{} @api{} along with other interprocess signal @api{}s.  Here is a meaningless usage
example:

@example
if (mmux_libc_interprocess_signals_bub_init()) @{
  /* error */
@}

/* Deliver a signal to the calling process. */
@{
  mmux_libc_interprocess_signal_t       ipxsignal;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  if (mmux_libc_raise(ipxsignal)) @{
    /* error */
  @}
@}

/* Unblock all the signals, then block them again. */
if (mmux_libc_interprocess_signals_bub_acquire()) @{
  /* error */
@}

/* Check if the signal was delivered. */
@{
  mmux_libc_interprocess_signal_t       ipxsignal;
  bool                                  delivered;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  if (mmux_libc_interprocess_signals_bub_delivered(&result, ipxsignal)) @{
    /* error */
  @}
  if (delivered) @{
    /* react to the signal */
  @}
@}

if (mmux_libc_interprocess_signals_bub_final()) @{
  /* error */
@}
@end example


@deftypefun bool mmux_libc_interprocess_signals_bub_init (void)
Block all the signals and initialise the @bub{} interface.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signals_bub_final (void)
Set all the signal handlers to @code{SIG_IGN}, then unblock all the signals and finalise the @bub{}
interface.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signals_bub_acquire (void)
Unblock all the signals, then block them again.  This should allow all the pending signals to be
delivered to the process.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signals_bub_delivered (bool * @var{result_p}, mmux_libc_interprocess_signal_t @var{ipxsignal})
When successful: store @ctrue{} in the variable referenced by @var{result_p} if the signal
@var{ipxsignal} has been delivered at least once @strong{before} the last call to
@cfunc{mmux_libc_interprocess_signal_bub_acquire}.

Calling this function with @var{ipxsignal} clears the internal flag for this signal, so calling it
again without acquiring new signals always stores @false{} in the variable referenced by
@var{result_p}.
@end deftypefun

@c page
@node signals handling
@subsection Other interprocess signals delivering methods


@deftypefn {Function Type} bool mmux_libc_sighandler_t (mmux_sint_t @var{signum})
Type of functions to be used as interprocess signal handlers.
@end deftypefn


@deftypefun bool mmux_libc_retrieve_signal_handler_SIG_DFL (mmux_libc_sighandler_t ** @var{result_p})
@deftypefunx bool mmux_libc_retrieve_signal_handler_SIG_IGN (mmux_libc_sighandler_t ** @var{result_p})
@deftypefunx bool mmux_libc_retrieve_signal_handler_SIG_ERR (mmux_libc_sighandler_t ** @var{result_p})
Store in the variable referenced by @var{result_p} the corresponding signal handling action.

The value @samp{SIG_ERR} is a special value used by @cfunc{signal} to return error, but it is
provided in this @api{} for completeness.
@end deftypefun


@deftypefun bool mmux_libc_signal (mmux_libc_sighandler_t ** @var{result_p}, mmux_libc_interprocess_signal_t @var{ipxsignal}, mmux_libc_sighandler_t @var{action})
@MmuxCInterface{signal}.  When successful: store in the variable referenced by @var{result_p} the
action that was previously set for @var{ipxsignal}.

To set the default action for @samp{SIGUSR1} we do:

@example
@{
  mmux_libc_interprocess_signal_t       ipxsignal;
  mmux_libc_sighandler_t *              the_old_handler;
  mmux_libc_sighandler_t *              the_new_handler;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  mmux_libc_retrieve_signal_handler_SIG_DFL(&the_new_handler);
  if (mmux_libc_signal(&the_old_hadler, ipxsignal, the_new_handler)) @{
    /* error */
  @}
@}
@end example

To set a custom action for @samp{SIGUSR1} we do:

@example
static void
my_handler (mmux_sint_t signum)
@{
  ...
@}

@{
  mmux_libc_interprocess_signal_t       ipxsignal;
  mmux_libc_sighandler_t *              the_old_handler;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  if (mmux_libc_signal(&the_old_handler, ipxsignal, my_handler)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pause (void)
@MmuxCInterface{pause}.  It is usually not useful to check the return value of @cfunc{pause}.
@end deftypefun

@c page
@node fds
@chapter File descriptors


@menu
* fds fds::                     File descriptors type.
* fds printing::                Printing formatted output.
* fds opening::                 Opening file descriptors.
* fds closing::                 Closing file descriptors.
* fds reading::                 Reading from file descriptors.
* fds writing::                 Writing to file descriptors.
* fds seeking::                 Seeking position in file descriptors.
* fds duplicating::             Duplicating file descriptors.
* fds piping::                  Opening file descriptor pipes.
* fds selecting::               Selecting file descriptors.
* fds scatter-gather::          Scatter--gather input and output.
* fds copying::                 Copying ranges from file to file.
* fds flock::                   File locks.
* fds fun control::             File descriptors functionality control.
* fds io control::              File descriptors input/output control.
* fds memfd::                   Memory-mapped file descriptors.
@end menu

@c page
@node fds fds
@section File descriptors type


@deftp {Opaque Type} mmux_libc_file_descriptor_t
@deftpx {Opaque Type} mmux_libc_fd_t
Opaque type representing file descriptors.  It must be passed by value.
@end deftp


@deftypefun bool mmux_libc_stdin (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard input.
@end deftypefun


@deftypefun bool mmux_libc_stdou (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard output.
@end deftypefun


@deftypefun bool mmux_libc_stder (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard error.
@end deftypefun


@deftypefun bool mmux_libc_at_fdcwd (mmux_libc_file_descriptor_t * @var{result_p})
Return the file descriptor associated to the constant @code{AT_FDCWD}.  We can use it with
@cfunc{mmux_libc_openat} and similar functions.
@end deftypefun


@deftypefun bool mmux_libc_make_fd (mmux_libc_file_descriptor_t * @var{result_p}, mmux_sint_t @var{fd_num})
Make a new file descriptor value.
@end deftypefun


@deftypefun bool mmux_libc_fd_equal (mmux_libc_fd_t @vari{fd}, mmux_libc_fd_t @varii{fd})
Return @ctrue{} if @vari{fd} is equal to @varii{fd}; otherwise return @cfalse{}.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_fd_t  the_fd = gimme_an_fd();
mmux_usize_t    required_nchars;

if (mmux_libc_fd_sprint_size(&required_nchars, the_fd) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_fd_sprint(str, required_nchars, the_fd) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_fd_parse (mmux_libc_fd_t * @var{fd_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_fd_t}
value; store the value in the location referenced by @var{fd_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_fd_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_fd_t @var{fd})
Determine the number of characters required to contain the string representation of @var{fd} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_fd_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_fd_t @var{fd})
Convert @var{fd} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node fds printing
@section Printing formatted output


@deftypefun bool mmux_libc_dprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_asciizcp_t @var{template}, ...)
@deftypefunx bool mmux_libc_dprintfou (mmux_asciizcp_t template, ...)
@deftypefunx bool mmux_libc_dprintfer (mmux_asciizcp_t template, ...)
@MmuxCInterface{dprintf}.  Print the message to, respectively: @var{fd}, @stdout{}, @stderr{}.

To print to a file descriptor:

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
mmux_sint_t             flags = MMUX_LIBC_O_RDONLY;
mmux_mode_t             mode  = 0;

if (mmux_libc_make_file_system_pathname(&ptn, "./file.ext")) @{
  /* error */
@};

if (mmux_libc_open(&fd, ptn, flags, mode)) @{
  /* error */
@}

if (mmux_libc_dprintf(fd, "the number is %d\n", 123)) @{
  /* error */
@}
@end example

To print to @stdout{} and @stderr{}:

@example
if (mmux_libc_dprintfou("the number is %d\n", 123)) @{
  /* error */
@}
if (mmux_libc_dprintfer("the number is %d\n", 456)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_vdprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_asciizcp_t @var{template}, va_list @var{ap})
@deftypefunx bool mmux_libc_vdprintfou (mmux_asciizcp_t @var{template}, va_list @var{ap})
@deftypefunx bool mmux_libc_vdprintfer (mmux_asciizcp_t @var{template}, va_list @var{ap})
@MmuxCInterface{vdprintf}.  Print the message to, respectively: @var{fd}, @stdout{}, @stderr{}.
Notice that @file{stdarg.h} is already included by @value{PackageHeaderFile}.

@example
bool
my_print_error (mmux_asciizcp_t template, ...)
@{
  bool          rv;
  va_list       ap;

  va_start(ap, template);
  @{
    rv = mmux_libc_vdprintfer(template, ap);
  @}
  va_end(ap);
  return rv;
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_dprintf_newline (mmux_libc_file_descriptor_t @var{fd})
@deftypefunx bool mmux_libc_dprintfou_newline (void)
@deftypefunx bool mmux_libc_dprintfer_newline (void)
Print a single newline character to, respectively: @var{fd}, @stdout{}, @stderr{}.
@end deftypefun


@anchor{mmux_libc_dprintf_strerror}
@deftypefun bool mmux_libc_dprintf_strerror (mmux_libc_fd_t @var{fd}, mmux_sint_t @var{errnum})
Wrapper for @cfunc{mmux_libc_dprintf} that prints to @var{fd} the @asciiz{} string resulting from a
call to @cfunc{mmux_libc_strerror}.
@end deftypefun


@anchor{mmux_libc_dprintf_strftime}
@deftypefun bool mmux_libc_dprintf_strftime (mmux_libc_fd_t @var{fd}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
Wrapper for @cfunc{mmux_libc_printf} that prints to @var{fd} the timestamp representation of
@var{BT} formatted according to @var{template} using @cfunc{mmux_libc_strftime},
@ref{mmux_libc_strftime} for details.
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineTypePrinterFunc{STEM}
@deftypefun bool mmux_libc_dprintf_\STEM\ (mmux_libc_file_descriptor_t @var{fd}, mmux_\STEM\_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun

@end macro

@MmuxDefineTypePrinterFunc{pointer}

@MmuxDefineTypePrinterFunc{schar}
@MmuxDefineTypePrinterFunc{uchar}
@MmuxDefineTypePrinterFunc{sshort}
@MmuxDefineTypePrinterFunc{ushort}
@MmuxDefineTypePrinterFunc{sint}
@MmuxDefineTypePrinterFunc{uint}
@MmuxDefineTypePrinterFunc{slong}
@MmuxDefineTypePrinterFunc{ulong}
@MmuxDefineTypePrinterFunc{sllong}
@MmuxDefineTypePrinterFunc{ullong}

@MmuxDefineTypePrinterFunc{sint8}
@MmuxDefineTypePrinterFunc{uint8}
@MmuxDefineTypePrinterFunc{sint16}
@MmuxDefineTypePrinterFunc{uint16}
@MmuxDefineTypePrinterFunc{sint32}
@MmuxDefineTypePrinterFunc{uint32}
@MmuxDefineTypePrinterFunc{sint64}
@MmuxDefineTypePrinterFunc{uint64}

@MmuxDefineTypePrinterFunc{float}
@MmuxDefineTypePrinterFunc{double}
@MmuxDefineTypePrinterFunc{ldouble}

@MmuxDefineTypePrinterFunc{float32}
@MmuxDefineTypePrinterFunc{float64}
@MmuxDefineTypePrinterFunc{float128}

@MmuxDefineTypePrinterFunc{float32x}
@MmuxDefineTypePrinterFunc{float64x}
@MmuxDefineTypePrinterFunc{float128x}

@MmuxDefineTypePrinterFunc{decimal32}
@MmuxDefineTypePrinterFunc{decimal64}
@MmuxDefineTypePrinterFunc{decimal128}

@MmuxDefineTypePrinterFunc{complexf}
@MmuxDefineTypePrinterFunc{complexd}
@MmuxDefineTypePrinterFunc{complexld}

@MmuxDefineTypePrinterFunc{complexf32}
@MmuxDefineTypePrinterFunc{complexf64}
@MmuxDefineTypePrinterFunc{complexf128}

@MmuxDefineTypePrinterFunc{complexf32x}
@MmuxDefineTypePrinterFunc{complexf64x}
@MmuxDefineTypePrinterFunc{complexf128x}

@MmuxDefineTypePrinterFunc{complexd32}
@MmuxDefineTypePrinterFunc{complexd64}
@MmuxDefineTypePrinterFunc{complexd128}

@MmuxDefineTypePrinterFunc{usize}
@MmuxDefineTypePrinterFunc{ssize}

@MmuxDefineTypePrinterFunc{sintmax}
@MmuxDefineTypePrinterFunc{uintmax}
@MmuxDefineTypePrinterFunc{sintptr}
@MmuxDefineTypePrinterFunc{uintptr}
@MmuxDefineTypePrinterFunc{ptrdiff}
@MmuxDefineTypePrinterFunc{mode}
@MmuxDefineTypePrinterFunc{off}
@MmuxDefineTypePrinterFunc{pid}
@MmuxDefineTypePrinterFunc{uid}
@MmuxDefineTypePrinterFunc{gid}
@MmuxDefineTypePrinterFunc{wchar}
@MmuxDefineTypePrinterFunc{wint}
@MmuxDefineTypePrinterFunc{time}
@MmuxDefineTypePrinterFunc{socklen}
@MmuxDefineTypePrinterFunc{rlim}

@deftypefun bool mmux_libc_dprintf_libc_fd (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_file_descriptor_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_dprintf_libc_pid (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_pid_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_dprintf_libc_uid (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_uid_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_dprintf_libc_gid (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_gid_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_dprintf_libc_ptn (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_file_system_pathname_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_dprintf_libc_completed_process_status (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_completed_process_status_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_dprintf_libc_interprocess_signal (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_interprocess_signal_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun

@c page
@node fds opening
@section Opening file descriptors


@menu
* fds opening standard::        Standard file descriptor opening.
* fds opening extended::        Extended file descriptor opening.
@end menu

@c page
@node fds opening standard
@subsection Standard file descriptor opening


@deftypefun bool mmux_libc_open (mmux_libc_file_descriptor_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{flags}, mmux_mode_t @var{mode})
@MmuxCInterface{open}.

@example
mmux_libc_file_system_pathname_t pathname;
mmux_libc_file_descriptor_t      fd;

mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

if (mmux_libc_make_file_system_pathname(&pathname, "/path/to/file.ext")) @{
  /* error */
@};

if (mmux_libc_open(&fd, pathname, flags, mode)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_openat (mmux_libc_file_descriptor_t * @var{result_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{flags}, mmux_mode_t @var{mode})
@MmuxCInterface{openat}.

@example
mmux_libc_file_system_pathname_t pathname;
mmux_libc_file_descriptor_t      dirfd;
mmux_libc_file_descriptor_t      fd;

mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

if (mmux_libc_make_file_system_pathname(&pathname, "/path/to/file.ext")) @{
  /* error */
@};

mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_openat(&fd, dirfd, pathname, flags, mode)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds opening extended
@subsection Extended file descriptor opening


The function @cfunc{openat2} and the data structure @code{struct open_how} are system extensions
implemented by the Linux kernel.


@MmuxCStructOpaqueTypedef{open_how}


@MmuxSetterGetter{open_how, flags,   mmux_uint64_t}
@MmuxSetterGetter{open_how, mode,    mmux_uint64_t}
@MmuxSetterGetter{open_how, resolve, mmux_uint64_t}
@MmuxStructDumper{open_how}


To dump the contents of @code{mmux_libc_open_how_t} we can do:

@example
mmux_libc_file_descriptor_t     fder;
mmux_libc_open_how_t            open_how;

mmux_libc_memzero(&open_how, sizeof(mmux_libc_open_how_t));

mmux_libc_open_how_flags_set(&open_how, \
  MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);

mmux_libc_open_how_mode_set(&open_how, \
  MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

mmux_libc_open_how_resolve_set(&open_how, \
  MMUX_LIBC_RESOLVE_BENEATH               \
  | MMUX_LIBC_RESOLVE_NO_MAGICLINKS       \
  | MMUX_LIBC_RESOLVE_NO_SYMLINKS         \
  | MMUX_LIBC_RESOLVE_NO_XDEV);

mmux_libc_stder(&fder);
if (mmux_libc_open_how_dump(fder, &open_how, NULL)) @{
  /* error */
@}
@end example

@noindent
notice how the Linux kernel demands the data structure to be reset to zero before use; this code
prints:

@example
struct open_how = 0x7ffca7af5b80
struct open_how->flags = 194 (O_ACCMODE | O_CREAT | O_EXCL | O_RDWR)
struct open_how->mode = 384 (S_IRUSR | S_IRWXU | S_IWUSR)
struct open_how->resolve = 15 (RESOLVE_BENEATH | RESOLVE_NO_MAGICLINKS | RESOLVE_NO_SYMLINKS | RESOLVE_NO_XDEV)
@end example


@deftypefn {Linux Function} bool mmux_libc_openat2 (mmux_libc_file_descriptor_t * @var{fd}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_open_how_t const * const @var{how_p})
@MmuxCInterface{openat2}.

@example
mmux_libc_file_system_pathname_t      ptn;
mmux_libc_file_descriptor_t           dirfd;
mmux_libc_file_descriptor_t           fd;
mmux_libc_open_how_t                  open_how;

/* required by the Linux kernel */
mmux_libc_memzero(&open_how, sizeof(mmux_libc_open_how_t));

mmux_libc_open_how_flags_set(&open_how, \
  MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);

mmux_libc_open_how_mode_set(&open_how, \
  MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

mmux_libc_open_how_resolve_set(&open_how, \
  MMUX_LIBC_RESOLVE_BENEATH               \
  | MMUX_LIBC_RESOLVE_NO_MAGICLINKS       \
  | MMUX_LIBC_RESOLVE_NO_SYMLINKS         \
  | MMUX_LIBC_RESOLVE_NO_XDEV);

if (mmux_libc_make_file_system_pathname(&ptn, "./file.ext")) @{
  /* error */
@};

mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_openat2(&fd, dirfd, ptn, &open_how)) @{
  /* error */
@}
@end example
@end deftypefn

@c page
@node fds closing
@section Closing file descriptors


@deftypefun bool mmux_libc_close (mmux_libc_file_descriptor_t @var{fd})
@MmuxCInterface{close}.
@end deftypefun

@c page
@node fds reading
@section Reading from file descriptors


@deftypefun bool mmux_libc_read (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{read}.

@example
mmux_libc_file_descriptor_t     fd;
mmux_usize_t                    nbytes_done;
mmux_usize_t                    buflen = 4096;
mmux_uint8_t                    bufptr[buflen];

mmux_libc_stdin(&fd);
if (mmux_libc_read(&nbytes_done, fd, bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pread (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_off_t @var{offset})
@MmuxCInterface{pread}.
@end deftypefun

@c page
@node fds writing
@section Writing to file descriptors


@deftypefun bool mmux_libc_write (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{write}.

@example
mmux_libc_file_descriptor_t     fd;
mmux_usize_t                    nbytes_done;
mmux_usize_t                    buflen;
mmux_asciizcp_t                 bufptr = "ciao";

mmux_libc_strlen(&buflen, bufptr);
mmux_libc_stdou(&fd);
if (mmux_libc_write(&nbytes_done, fd, bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pwrite (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_off_t @var{offset})
@MmuxCInterface{pwrite}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_write_buffer (mmux_libc_file_descriptor_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@deftypefunx bool mmux_libc_write_buffer_to_stdou (mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@deftypefunx bool mmux_libc_write_buffer_to_stder (mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
Like @cfunc{mmux_libc_write}, but write a buffer to the file descriptor, respectively: @var{fd},
@stdout{}, @stderr{}.  If the number of written bytes equals @var{buflen}: return @cfalse{},
otherwise return @ctrue{}.

These functions exist mostly as tools in debugging code.

@example
mmux_usize_t    buflen;
mmux_uint8_t    bufptr[buflen];

if (mmux_libc_write_buffer_to_stdou(bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds seeking
@section Seeking position in file descriptors


@deftypefun bool mmux_libc_lseek (mmux_libc_file_descriptor_t @var{fd}, mmux_off_t * @var{offset_p}, mmux_sint_t @var{whence})
@MmuxCInterface{lseek}.

Upon calling this function: @var{offset_p} must reference a variable whose value represents the
offset from the position selected by @var{whence}.

Upon successfully returning from this function: the variable referenced by @var{offset_p} has been
updated to represent the resulting position, measured in bytes, from the beginning of the file.

@example
mmux_libc_fd_t  fd     = get_some_fd();
mmux_off_t      offset = 123;
mmux_sint_t     whence = MMUX_LIBC_SEEK_SET;

if (mmux_libc_lseek(fd, &offset, whence)) @{
  /* error */
@}

/* now "offset" has been updated */
@end example
@end deftypefun

@c page
@node fds duplicating
@section Duplicating file descriptors


@deftypefun bool mmux_libc_dup (mmux_libc_file_descriptor_t * @var{new_fd_p}, mmux_libc_file_descriptor_t @var{old_fd})
@MmuxCInterface{dup}.
@end deftypefun


@deftypefun bool mmux_libc_dup2 (mmux_libc_file_descriptor_t @var{old_fd}, mmux_libc_file_descriptor_t @var{new_fd})
@MmuxCInterface{dup2}.
@end deftypefun


@deftypefun bool mmux_libc_dup3 (mmux_libc_file_descriptor_t @var{old_fd}, mmux_libc_file_descriptor_t @var{new_fd}, mmux_sint_t @var{flags})
@MmuxCInterface{dup3}.

@example
mmux_asciizcp_t    pathname = "/path/to/file.ext";
mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

mmux_libc_fd_t  fd1, fd2;

if (mmux_libc_open(&fd1, pathname, flags, mode)) @{
  /* error */
@}

/* I'm so dirty. */
mmux_libc_make_fd(&fd2, 5);

if (mmux_libc_dup3(fd1, fd2, MMUX_LIBC_O_CLOEXEC)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds piping
@section Opening file descriptor pipes


@deftypefun bool mmux_libc_pipe (mmux_libc_file_descriptor_t @var{fds}[2])
@MmuxCInterface{pipe}.

@example
@{
  bool                this_is_the_paren_process;
  mmux_libc_pid_t     child_pid;
  mmux_libc_fd_t      paren_to_child_fds[2];
  mmux_libc_fd_t      paren_fr_child_fds[2];

  if        (mmux_libc_pipe(paren_to_child_fds)) @{
    ... /* error */
  @} else if (mmux_libc_pipe(paren_fr_child_fds)) @{
    ... /* error */
  @} else if (mmux_libc_fork(&this_is_the_paren_process, &child_pid)) @{
    ... /* error */
  @} else if (this_is_the_paren_process) @{
    paren_play(paren_fr_child_fds[0], paren_to_child_fds[1], child_pid);
  @} else @{
    child_play(paren_to_child_fds[0], paren_fr_child_fds[1]);
  @}
@}
void
paren_play (mmux_libc_fd_t read_fr_child_fd, mmux_libc_fd_t writ_to_child_fd, mmux_libc_pid_t child_pid)
@{
  ...
@}
void
child_play (mmux_libc_fd_t read_fr_paren_fd, mmux_libc_fd_t writ_to_paren_fd)
@{
  ...
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_close_pipe (mmux_libc_file_descriptor_t @var{fds}[2])
Close both the file descriptors in @var{fds}.  If both closures succeed: return @cfalse{}; otherwise
return @ctrue{}.  If closing the first fails: this function still closes the second.

This function might be useful when an error occurs after we have created a pipe.
@end deftypefun

@c page
@node fds selecting
@section Selecting file descriptors


Example:

@example
mmux_libc_fd_set_t      read_fd_set[1], writ_fd_set[1], exce_fd_set[1];
mmux_uint_t             nfds_ready;
mmux_uint_t             maximum_nfds_to_check = MMUX_LIBC_FD_SETSIZE;
mmux_libc_timeval_t     timeout[1];
mmux_libc_fd_t          in, ou;
bool                    isset;

mmux_libc_stdin(&in);
mmux_libc_stdou(&ou);

mmux_libc_FD_ZERO(read_fd_set);
mmux_libc_FD_ZERO(writ_fd_set);
mmux_libc_FD_ZERO(exce_fd_set);

mmux_libc_FD_SET(in, read_fd_set);
mmux_libc_FD_SET(ou, writ_fd_set);

mmux_libc_timeval_set(timeout, 1, 0);

if (mmux_libc_select(&nfds_ready, maximum_nfds_to_check,
                     read_fd_set, writ_fd_set, exce_fd_set,
                     timeout)) @{
  /* error */
@}

mmux_libc_FD_ISSET(&isset, in, read_fd_set);
if (isset) @{
  /* do something */
@}

mmux_libc_FD_ISSET(&isset, ou, writ_fd_set);
if (isset) @{
  /* do something */
@}

mmux_libc_FD_ISSET(&isset, in, exce_fd_set);
if (isset) @{
  /* do something */
@}
@end example


@deftypefun bool mmux_libc_FD_ZERO (mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_ZERO}.
@end deftypefun


@deftypefun bool mmux_libc_FD_SET (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_SET}.
@end deftypefun


@deftypefun bool mmux_libc_FD_CLR (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_CLR}.
@end deftypefun


@deftypefun bool mmux_libc_FD_ISSET (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t const * @var{fd_set_p})
@MmuxCInterface{FD_ISSET}.
@end deftypefun


@deftypefun bool mmux_libc_select (mmux_uint_t * @var{nfds_ready_p}, mmux_uint_t @var{maximum_nfds_to_check}, mmux_libc_fd_set_t * @var{read_fd_set_p}, mmux_libc_fd_set_t * @var{writ_fd_set_p}, mmux_libc_fd_set_t * @var{exce_fd_set_p}, mmux_libc_timeval_t * @var{timeout_p})
@MmuxCInterface{select}.

Each of the arguments @var{read_fd_set_p}, @var{writ_fd_set_p}, @var{exce_fd_set_p} can be @cnull{}
if we are not interested in selecting the corresponding events.

The argument @var{timeout_p} can be @cnull{} if we want to set a timeout of infinite time.

After a successful call: the variable referenced by @var{nfds_ready_p} is set to the number of file
descriptors that are ready for an action.

The argument @var{maximum_nfds_to_check} must represent the maximum number of file descriptors to
check for events: if we want to check up to file descriptor @samp{10}, we have to set
@var{maximum_nfds_to_check} to @samp{11}; it is usually just set to the constant
@code{MMUX_LIBC_FD_SETSIZE}.
@end deftypefun


@deftypefun bool mmux_libc_select_fd_for_reading (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timeval_t * @var{timeout_p})
@deftypefunx bool mmux_libc_select_fd_for_writing (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timeval_t * @var{timeout_p})
@deftypefunx bool mmux_libc_select_fd_for_exception (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timeval_t * @var{timeout_p})
Like @cfunc{mmux_libc_select}, but select a single event for a single file descriptor; if the file
descriptor is ready the variable referenced by @var{result_p} is set to @ctrue{}, otherwise it is
set to @cfalse{}.

@example
mmux_libc_fd_t  fd;
bool            is_ready;

gimme_an_fd(&fd);

if (mmux_libc_select_fd_for_reading(&is_ready, fd, NULL)) @{
  /* error */
@}
if (is_ready) @{
  /* the fd is ready for reading */
@}
@end example
@end deftypefun

@c page
@node fds scatter-gather
@section Scatter--gather input and output


@menu
* fds scatter-gather buffer::   The input/output buffer data structure.
* fds scatter-gather array::    The input/output array data structure.
* fds scatter-gather reading::  Reading with the input/output vector programming interface.
* fds scatter-gather writing::  Writing with the input/output vector programming interface.
@end menu

@c page
@node fds scatter-gather buffer
@subsection The input/output buffer data structure


Data to be read from or written to a file descriptor using the scatter--gather facilities must be
stored in multiple buffers; a single buffer of data is represented by the data structure
@objtype{mmux_libc_iovec_t}.  To instantiate and inspect such data structure we do:

@example
mmux_usize_t const      bufnum = 16;
mmux_usize_t const      buflen = 4096;
mmux_octet_t            bufptr[bufnum][buflen];
mmux_libc_iovec_t       iov[bufnum];

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_iovec_dump(fd, &(iov[0]), NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
this code dumps to @stdout{} a string representation of a single @objtype{mmux_libc_iovec_t}:

@example
struct iovec = 0x7ffe8c4309d0
struct iovec->iov_base = 0x7ffe8c4209c0
struct iovec->iov_len = 4096
@end example


@MmuxCStructOpaqueTypedef{iovec}


@MmuxSetterGetter{iovec, iov_base, mmux_pointer_t}
@MmuxSetterGetter{iovec, iov_len,  mmux_usize_t}
@MmuxStructDumper{iovec}

@c page
@node fds scatter-gather array
@subsection The input/output array data structure


Data to be read from or written to a file descriptor using the scatter--gather facilities must be
stored in multiple buffers; an array of these buffers is represented by the data structure
@objtype{mmux_libc_iovec_array_t}.  To instantiate and inspect such data structure we do:

@example
mmux_usize_t const      bufnum = 16;
mmux_usize_t const      buflen = 4096;
mmux_octet_t            bufptr[bufnum][buflen];
mmux_libc_iovec_t       iov[bufnum];
mmux_libc_iovec_array_t iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_iovec_array_dump(fd, &iova, NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
this code dumps to @stdout{} a string representation of a single @objtype{mmux_libc_iovec_array_t}:

@example
mmux_libc_iovec_array_t = 0x7ffcd9306550
mmux_libc_iovec_array_t->iova_base = 0x7ffcd9306560
mmux_libc_iovec_array_t->iova_len = 4
mmux_libc_iovec_array_t->iova_base[0] = 0x7ffcd9306560
mmux_libc_iovec_array_t->iova_base[0]->iov_base = 0x7ffcd9302540
mmux_libc_iovec_array_t->iova_base[0]->iov_len = 4096
mmux_libc_iovec_array_t->iova_base[1] = 0x7ffcd9306570
mmux_libc_iovec_array_t->iova_base[1]->iov_base = 0x7ffcd9303540
mmux_libc_iovec_array_t->iova_base[1]->iov_len = 4096
mmux_libc_iovec_array_t->iova_base[2] = 0x7ffcd9306580
mmux_libc_iovec_array_t->iova_base[2]->iov_base = 0x7ffcd9304540
mmux_libc_iovec_array_t->iova_base[2]->iov_len = 4096
mmux_libc_iovec_array_t->iova_base[3] = 0x7ffcd9306590
mmux_libc_iovec_array_t->iova_base[3]->iov_base = 0x7ffcd9305540
mmux_libc_iovec_array_t->iova_base[3]->iov_len = 4096
@end example


@deftp {Opaque Struct Typedef} mmux_libc_iovec_array_t
Data structure type representing an array of @objtype{mmux_libc_iovec_t} data structures.  It has
the following fields:

@table @code
@item mmux_libc_iovec_t * iova_base
Pointer to an array of @objtype{mmux_libc_iovec_t} data structures.

@item mmux_usize_t iova_len
Number of items in the array referenced by @code{iova_base}.
@end table
@end deftp


@MmuxSetterGetter{iovec_array, iova_base, mmux_libc_iovec_t *}
@MmuxSetterGetter{iovec_array, iova_len,  mmux_usize_t}
@MmuxStructDumperTwo{iovec_array, mmux_libc_iovec_array_t}

@c page
@node fds scatter-gather reading
@subsection Reading with the input/output vector programming interface


@deftypefun bool mmux_libc_readv (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p})
@MmuxCInterface{readv}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

/* Perform the reading. */
@{
  mmux_usize_t      nbytes_done;

  if (mmux_libc_readv(&nbytes_done, mfd, &iova)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_preadv (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset})
@MmuxCInterface{preadv}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

/* Perform the reading. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;

  if (mmux_libc_preadv(&nbytes_done, mfd, &iova, offset)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_preadv2 (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset}, mmux_sint_t @var{flags})
@MmuxCInterface{preadv2}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

/* Perform the reading. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;
  mmux_sint_t   flags  = MMUX_LIBC_RWF_HIPRI;

  if (mmux_libc_preadv2(&nbytes_done, mfd, &iova, offset, flags)) @{
    /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fds scatter-gather writing
@subsection Writing with the input/output vector programming interface


@deftypefun bool mmux_libc_writev (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p})
@MmuxCInterface{writev}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

fill_buffers(iova);

/* Perform the writing. */
@{
  mmux_usize_t      nbytes_done;

  if (mmux_libc_writev(&nbytes_done, mfd, &iova)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pwritev (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset})
@MmuxCInterface{pwritev}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

fill_buffers(iova);

/* Perform the writing. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;

  if (mmux_libc_pwritev(&nbytes_done, mfd, &iova, offset)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_pwritev2 (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset}, mmux_sint_t @var{flags})
@MmuxCInterface{pwritev2}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

fill_buffers(iova);

/* Perform the writing. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;
  mmux_sint_t   flags  = MMUX_LIBC_RWF_HIPRI;

  if (mmux_libc_pwritev2(&nbytes_done, mfd, &iova, offset, flags)) @{
    /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fds copying
@section Copying ranges from file to file


@deftypefun bool mmux_libc_copy_file_range (mmux_usize_t * @var{number_of_bytes_copied_p}, mmux_libc_file_descriptor_t @var{input_fd}, mmux_sint64_t * @var{input_position_p}, mmux_libc_file_descriptor_t @var{ouput_fd}, mmux_sint64_t * @var{ouput_position_p}, mmux_usize_t @var{number_of_bytes_to_copy}, mmux_sint_t @var{flags})
@MmuxCInterface{copy_file_range}.
@end deftypefun


Here is an example to understand the mechanics of the function call:

@example
mmux_libc_file_descriptor_t     src_fd;
mmux_libc_file_descriptor_t     dst_fd;

/* Open the source and destination files. */
@{
  mmux_libc_file_system_pathname_t    src_ptn;
  mmux_libc_file_system_pathname_t    dst_ptn;
  mmux_sint_t  flags = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
  mmux_mode_t  mode  = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

  if (mmux_libc_make_file_system_pathname(&src_ptn, "source.ext")) @{
    /* error */
  @}
  if (mmux_libc_open(&src_fd, src_ptn, flags, mode)) @{
    /* error */
  @}

  if (mmux_libc_make_file_system_pathname(&dst_ptn, "destination.ext")) @{
    /* error */
  @}

  if (mmux_libc_open(&dst_fd, dst_ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Write data to the source file. */
@{
  mmux_usize_t        nbytes_done;
  //                            01234567890123456789012345678901234567890
  //                            0         1         2         3         4
  mmux_asciizcp_t     bufptr = "0123456789abcdefghilmnopqrstuvz0123456789";
  mmux_usize_t        buflen;

  mmux_libc_strlen(&buflen, bufptr);

  if (mmux_libc_write(&nbytes_done, src_fd, bufptr, buflen)) @{
    /* error */
  @}
  if (nbytes_done != buflen) @{
    /* it is an error for our purposes */
  @}
@}

/* Copy the alpha range of data "abcdefghilmnopqrstuvz" from the source
   file to the destination file. */
@{
  mmux_usize_t        nbytes_done;
  mmux_sint64_t       src_position = 10;
  mmux_sint64_t       dst_position = 0;
  mmux_usize_t        number_of_bytes_to_copy = 21;
  mmux_sint_t         flags = 0;

  if (mmux_libc_copy_file_range(&nbytes_done,
                                src_fd, &src_position,
                                dst_fd, &dst_position,
                                number_of_bytes_to_copy, flags)) @{
    /* error */
  @}
@}

if (mmux_libc_close(src_fd)) @{
  /* error */
@}
if (mmux_libc_close(dst_fd)) @{
  /* error */
@}
@end example

If we need to copy data between file descriptors, and we cannot use
@cfunc{mmux_libc_copy_file_range}, we can adapt the following code template:

@example
mmux_libc_fd_t                  infd, oufd;

static mmux_usize_t const       read_buflen = 1024;
mmux_octet_t                    read_bufptr[read_buflen];
mmux_usize_t                    nbytes_read;

gimme_an_input_fd(&infd);
gimme_an_ouput_fd(&oufd);

/* Loop reading while the number of bytes read is positive. */
do @{
  if (mmux_libc_read(&nbytes_read, infd, read_bufptr, read_buflen)) @{
    /* error */
  @}

  if (nbytes_read > 0) @{
    mmux_octet_t *  write_bufptr    = read_bufptr;
    mmux_usize_t    write_buflen    = nbytes_read;
    mmux_usize_t    nbytes_written  = 0;

    /* Loop writing until we have written all the bytes from the buffer. */
    do @{
      if (mmux_libc_write(&nbytes_written, oufd, write_bufptr, write_buflen)) @{
        /* error */
      @}

      if (nbytes_written < write_buflen) @{
        write_bufptr += nbytes_written;
        write_buflen -= nbytes_written;
      @}
    @} while (nbytes_written < write_buflen);
  @}
@} while (nbytes_read > 0);
@end example

@c page
@node fds flock
@section File locks


Data structures of type @objtype{mmux_libc_flock_t} are used to describe a file lock in some calls
to @cfunc{mmux_libc_fcntl}.  To declare and inspect such data structures we do:

@example
mmux_libc_flock_t     flo;
mmux_libc_pid_t       pid;

mmux_libc_make_pid_zero(&pid); /* should not fail */

mmux_libc_l_type_set   (&flo, MMUX_LIBC_F_RDLCK);
mmux_libc_l_whence_set (&flo, MMUX_LIBC_SEEK_SET);
mmux_libc_l_start_set  (&flo, 11);
mmux_libc_l_len_set    (&flo, 33);
mmux_libc_l_pid_set    (&flo, pid);

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_flock_dump(fd, &flo, NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
which will print:

@example
struct flock = "0x7ffcf5d55170"
struct flock.l_type = "0" (F_RDLCK)
struct flock.l_whence = "0" (SEEK_SET)
struct flock.l_start = "11"
struct flock.l_len = "33"
struct flock.l_pid = "0"
@end example


@MmuxCStructOpaqueTypedef{flock}
@MmuxSetterGetter{flock, l_type,   mmux_sshort_t}
@MmuxSetterGetter{flock, l_whence, mmux_sshort_t}
@MmuxSetterGetter{flock, l_start,  mmux_off_t}
@MmuxSetterGetter{flock, l_len,    mmux_off_t}
@MmuxSetterGetter{flock, l_pid,    mmux_libc_pid_t}
@MmuxStructDumper{flock}

@deftypefun bool mmux_libc_flag_to_symbol_struct_flock_l_type (mmux_asciizcp_t* @var{str_p}, mmux_sint_t @var{flag})
Identify @var{flag} as a value for the field @code{l_type} of @objtype{mmux_libc_flock_t}; store in
the variable referenced by @var{str_p} a pointer to a statically allocated @asciiz{} string
representing the name of the value.
@end deftypefun

@c page
@node fds fun control
@section File descriptors functionality control


@deftypefun bool mmux_libc_fcntl (mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{command}, mmux_pointer_t @var{parameter_p})
@MmuxCInterface{fcntl}.  Arguments:

@table @var
@item fd
A file descriptor.

@item command
A constant representing a command for @cfunc{fcntl}.

@item parameter_p
Pointer to a variable representing a parameter that can be input or output depending on the
@var{command}.
@end table
@end deftypefun


@deftypefun bool mmux_libc_fcntl_command_flag_to_symbol (mmux_asciizcp_t* @var{str_p}, mmux_sint_t @var{command})
Identify @var{command} as a command argument for @cfunc{mmux_libc_fcntl}; store in the variable
referenced by @var{str_p} a pointer to a statically allocated @asciiz{} string representing a string
representation of the @var{command}.
@end deftypefun

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_DUPFD
Duplicate a file descriptor; @var{parameter_p} must reference a variable of type
@objtype{mmux_libc_file_descriptor_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETFD
Get file descriptor flags, like @samp{MMUX_LIBC_FD_CLOEXEC}; @var{parameter_p} must reference a variable
of type @objtype{mmux_sint_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETFD
Set file descriptor flags, like @samp{MMUX_LIBC_FD_CLOEXEC}; @var{parameter_p} must reference a variable
of type @objtype{mmux_sint_t} holding a bitwise OR combination of flags.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETFL
Get open file descriptor flags, like @samp{O_RDWR}; @var{parameter_p} must reference a variable of
type @objtype{mmux_sint_t}.

To set blocking mode for a file descriptor we do:

@example
mmux_libc_fd_t  fd;
mmux_sint_t     parameter;

/* Acquire current file descriptor flags. */
if (mmux_libc_fcntl(in, MMUX_LIBC_F_GETFL, &parameter)) @{
  /* error */
@}

/* Null the non-block flag. */
parameter &= (~ MMUX_LIBC_O_NONBLOCK);

/* Set the new flags. */
if (mmux_libc_fcntl(in, MMUX_LIBC_F_SETFL, &parameter)) @{
  /* error */
@}
@end example
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETFL
Set open file descriptor flags, like @samp{O_APPEND}; @var{parameter_p} must reference a variable of
type @objtype{mmux_sint_t} holding a bitwise OR combination of flags.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETLK
Get a @MmuxCStruct{flock} describing a lock that blocks a requested lock; @var{parameter_p} must
reference a value of type @objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETLK
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETLKW
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_GETLK
Get a @MmuxCStruct{flock} describing a lock that blocks a requested lock; @var{parameter_p} must
reference a value of type @objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_SETLK
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_SETLKW
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETOWN
Get the process or group id that receives the signal @samp{SIGIO}; @var{parameter_p} must reference
a variable of type @objtype{mmux_libc_pid_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETOWN
Set the process or group id that receives the signal @samp{SIGIO}; @var{parameter_p} must reference
a variable of type @objtype{mmux_libc_pid_t}.
@end defvr

@c page
@node fds io control
@section File descriptors input/output control


@deftypefun bool mmux_libc_ioctl (mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{command}, mmux_pointer_t @var{parameter_p})
@MmuxCInterface{ioctl}.  Arguments:

@table @var
@item fd
A file descriptor.

@item command
A constant representing a command for @cfunc{ioctl}.

@item parameter_p
Pointer to a variable representing a parameter that can be input or output depending on the
@var{command}.
@end table
@end deftypefun

@c ------------------------------------------------------------------------

@defvr {Iontl Command} MMUX_LIBC_SIOCATMARK
Detect if the data received through a socket has reached the mark; @var{parameter_p} must reference
a variable of type @objtype{mmux_sint_t}.
@end defvr

@c page
@node fds memfd
@section Memory--mapped file descriptors


@cindex Memory--mapped file descriptors
@cindex Memfds


Memory--mapped file descriptors (memfds for short) are constructed by @cfunc{memfd_create},
@MmuxCFuncpage{memfd_create}.  The device underlying a memfd exists only in memory, but we can apply
to it almost all the functions acting upon file descriptors.

@menu
* fds memfd intro::             Introduction to memfds and usage examples.
* fds memfd makers::            Constructing memfds.
* fds memfd inspect::           Inspecting memfds.
* fds memfd reading::           Special reading operations upon memfds.
* fds memfd writing::           Special writing operations upon memfds.
* fds memfd copying::           Special copying operations upon memfds.
@end menu

@c page
@node fds memfd intro
@subsection Introduction to memfds and usage examples


To use a memory--mapped file descriptor, we do:

@example
mmux_libc_fd_t  mfd;

if (mmux_libc_make_memfd(&mfd)) @{
  /* error */
@}
@{
  /* Write something. */
  if (mmux_libc_dprintf(mfd, "The value is %d.\n", 123)) @{
    /* error */
  @}

  @{
    mmux_double_t       rep = 1.2;
    mmux_double_t       imp = 3.4;
    mmux_complexd_t     Z;

    Z = mmux_complexd_make_rectangular(rep, imp);
    mmux_complexd_dprintf(mfd, Z);
  @}

  /* Copy the data to stdout. */
  if (mmux_libc_memfd_copyou(mfd)) @{
    /* error */
  @}
@}
if (mmux_libc_close(mfd)) @{
  /* error */
@}
@end example

@noindent
we can apply to a memfd almost all the functions that act upon ordinary file descriptors.

We need to remember to appropriately shift the input/output position of the underlying device with
@cfunc{mmux_libc_lseek}.  If we need to shift the position, do something, and then restore the
position to its original value, we do:

@example
mmux_libc_fd_t  mfd = ...;
mmux_off_t      position = 0; /* new position with respect to MMUX_LIBC_SEEK_SET */

/* Save the current position then seek to the beginning. */
if (mmux_libc_lseek(mfd, &position, MMUX_LIBC_SEEK_SET)) @{
  /* error */
@}

/* do something with mfd */

/* Restore the original position. */
if (mmux_libc_lseek(mfd, &position, MMUX_LIBC_SEEK_SET)) @{
  /* error */
@}
@end example

@noindent
also we can use @cfunc{mmux_libc_pread} and @cfunc{mmux_libc_pwrite} to read from and write to a
position from the beginning of the underlying device.

@c page
@node fds memfd makers
@subsection Constructing memfds


The core constructor for a memfd is @cfunc{mmux_libc_make_memfd}; we should always pair a call to it
with a call to @cfunc{mmux_libc_close}, which acts as destructor:

@example
mmux_libc_fd_t  mfd;

if (mmux_libc_make_memfd(&mfd)) @{
  /* error */
@}

@{
  /* do something with "mfd" */
@}

if (mmux_libc_close(mfd)) @{
  /* error */
@}
@end example


@deftypefun bool mmux_libc_make_memfd (mmux_libc_file_descriptor_t * @var{mfd_p})
Create a new file descriptor whose underlying device is mapped into ordinary memory; store the
resulting file descriptor in the variable referenced by @var{mfd_p}.
@end deftypefun

@c page
@node fds memfd inspect
@subsection Inspecting memfds


To acquire the number of bytes in the device underlying a memfd, we do:

@example
mmux_libc_fd_t  mfd;
mmux_usize_t    buflen;

if (mmux_libc_memfd_length(&buflen, mfd)) @{
  /* error */
@}
@end example

@noindent
this operation should not fail.

If the data in the device is to be interpreted as an @mmuxascii{} string, we can allocate a buffer
to contain it as @asciiz{} string as follows:

@example
mmux_libc_fd_t  mfd;
mmux_usize_t    buflen;

if (mmux_libc_memfd_length(&buflen, mfd)) @{
  /* error */
@}

@{
  mmux_char_t   bufptr[1+buflen];

  bufptr[buflen] = '\0';
  ...
@}
@end example


@deftypefun bool mmux_libc_memfd_length (mmux_usize_t * @var{len_p}, mmux_libc_file_descriptor_t @var{mfd})
Store in the variable referenced by @var{len_p} the number of bytes in the device underlying
@var{mfd}.
@end deftypefun

@c page
@node fds memfd reading
@subsection Special reading operations upon memfds


Applying the basic reading operation using @cfunc{mmux_libc_read} to a memfd, looks like this:

@example
mmux_usize_t    buflen = 4094;
mmux_octet_t *  bufptr[buflen];

mmux_libc_fd_t  mfd;
mmux_usize_t    nbytes_done;

gimme_a_memfd(&mfd);

if (mmux_libc_read(&nbytes_done, mfd, bufptr, buflen)) @{
  /* error */
@}
@end example

@noindent
this is quite verbose, and the read operation should not fail if the destination buffer is wide
enough.  So the following functions are implemented.

If the data in the device underlying the memfd is to be considered as an @mmuxascii{} string, we can
copy it into an external buffer as follows:

@example
mmux_usize_t    buflen;

if (mmux_libc_memfd_length(&buflen, mfd)) @{
  /* error */
@} else @{
  mmux_char_t   bufptr[1+buflen];

  bufptr[buflen] = '\0';
  if (mmux_libc_memfd_read_buffer(mfd, bufptr, buflen)) @{
    /* error */
  @}
  ...
@}
@end example

@noindent
we take advantage of the fact that we know the data size.


@deftypefun bool mmux_libc_memfd_read_buffer (mmux_libc_fd_t @var{mfd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{maximum_buflen})
Wrapper for @cfunc{mmux_libc_read}.  Copy up to @var{maximum_buflen} bytes from the device
underlying @var{mfd} to the buffer referenced by @var{bufptr}.
@end deftypefun

@c page
@node fds memfd writing
@subsection Special writing operations upon memfds


Applying the basic writing operation using @cfunc{mmux_libc_write} to a memfd, looks like this:

@example
mmux_usize_t    buflen = 4094;
mmux_octet_t *  bufptr[buflen];

mmux_libc_fd_t  mfd;
mmux_usize_t    nbytes_done;

fill_buffer(bufptr, buflen);
gimme_a_memfd(&mfd);

if (mmux_libc_write(&nbytes_done, mfd, bufptr, buflen)) @{
  /* error */
@}
@end example

@noindent
this is quite verbose, but we need to remember that the write operation could fail if there is not
enough memory available to enlarge the underlying device.  Anyway, the following functions are
implemented.


@deftypefun bool mmux_libc_memfd_write_buffer (mmux_libc_file_descriptor_t @var{mfd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
Write @var{buflen} bytes from the buffer @var{bufptr} into the device underlying @var{mfd}, at the
current position.  The return value is @ctrue{} if less than @var{buflen} bytes are written to
@var{mfd}.
@end deftypefun


@deftypefun bool mmux_libc_memfd_write_asciiz (mmux_libc_file_descriptor_t @var{mfd}, mmux_asciizcp_t @var{bufptr})
Write the @asciiz{} string referenced by @var{bufptr} into the device underlying @var{mfd}, at the
current position.  The return value is @ctrue{} if less than the whole string is written to
@var{mfd}.
@end deftypefun


@anchor{mmux_libc_memfd_strerror}
@deftypefun bool mmux_libc_memfd_strerror (mmux_libc_file_descriptor_t @var{mfd}, mmux_sint_t @var{errnum})
Write to @var{mfd}, at the current position for the underlying device, the error string associated
to @var{errnum} and retrieved using @cfunc{mmux_libc_strerror}.  The return value is @ctrue{} if
less than the whole error message is written to @var{mfd}.
@end deftypefun

@c page
@node fds memfd copying
@subsection Special copying operations upon memfds


@deftypefun bool mmux_libc_memfd_copy (mmux_libc_file_descriptor_t @var{oufd}, mmux_libc_file_descriptor_t @var{mfd})
Copy all the data in the device underlying @var{mfd} to the file descriptor @var{oufd}.

This function ignores the current device position, writing all the data from the beginning to the
end of the underlying device.  When successful: the current device position is restored to the
original value, so it is left unchanged.  If an error occurs: the underlying device position is
undefined.

@strong{NOTE} It appears the memfds cannot be used with @cfunc{mmux_libc_copy_file_range}.
@end deftypefun


@deftypefun bool mmux_libc_memfd_copyou (mmux_libc_file_descriptor_t @var{mfd})
@deftypefunx bool mmux_libc_memfd_copyer (mmux_libc_file_descriptor_t @var{mfd})
Wrappers for @cfunc{mmux_libc_memfd_copy} that write the underlying device contents to, respectively:
@stdout{}, @stderr{}.
@end deftypefun

@c page
@node fs
@chapter File system


@menu
* fs pathnames::                File system pathnames type definition.
* fs links::                    Hard and symbolic links.
* fs deleting::                 Deleting links.
* fs renaming::                 Renaming links.
* fs directories::              Directories.
* fs ownership::                File ownership.
* fs permissions::              File access permissions.
* fs attributes::               File attributes.
* fs truncating::               Truncating files.
* fs times::                    File system times.
@end menu

@c page
@node fs pathnames
@section File system pathnames type definition


@deftp {Opaque Struct Type} mmux_libc_file_system_pathname_t
@deftpx {Opaque Struct Type} mmux_libc_ptn_t
Data type representing a file system pathname as a non--@cnull{} pointer to @asciiz{} string.

@quotation
@strong{NOTE} At present a file system pathname value is considered ``validated'' if its internal
pointer to @asciiz{} string is non--@cnull{}; no validation is performed on the string itself, which
means that the string could be empty or invalid as a file system pathname.  This may change in the
future.
@end quotation
@end deftp


@deftypefun bool mmux_libc_make_file_system_pathname (mmux_libc_file_system_pathname_t * @var{pathname_p}, mmux_asciizcp_t @var{asciiz_pathname})
Make a new file system pathname value.  The pointer @var{asciiz_pathname} is stored in the data
structure referenced by @var{pathname_p}.

@example
mmux_asciizcp_t         asciiz_pathname = "/path/to/file.ext";
mmux_libc_ptn_t         ptn;

if (mmux_libc_make_file_system_pathname(&ptn, asciiz_pathname)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_malloc (mmux_libc_file_system_pathname_t * @var{pathname_p}, mmux_asciizcp_t @var{asciiz_pathname})
Make a new file system pathname value by allocating memory with @cfunc{mmux_libc_malloc} and copying
the given pathname.

@example
mmux_asciizcp_t         asciiz_pathname = "/path/to/file.ext";
mmux_libc_ptn_t         ptn;

if (mmux_libc_file_system_pathname_malloc(&ptn, asciiz_pathname)) @{
  /* error */
@}
@{
  ...
@}
if (mmux_libc_file_system_pathname_free(ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_free (mmux_libc_file_system_pathname_t @var{pathname})
Release the memory holding the pathname as @asciiz{} string using @cfunc{mmux_libc_free}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_equal (bool * result_p, mmux_libc_file_system_pathname_t @vari{ptn}, mmux_libc_file_system_pathname_t @varii{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} is the two given pathnames are equal
when compared as @asciiz{} strings.
@end deftypefun

@c page
@node fs links
@section Hard and symbolic links


@menu
* fs links hard::               File system hard links.
* fs links symbolic::           File system symbolic links.
* fs links follow::             Following file system symbolic links.
@end menu

@c page
@node fs links hard
@subsection File system hard links


@cindex File system, hard links
@cindex Hard links, file system


@deftypefun bool mmux_libc_link (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{link}.

@example
mmux_libc_ptn_t         old_ptn, new_ptn;

mmux_libc_make_file_system_pathname(&old_ptn, "/path/to/old-file.ext");
mmux_libc_make_file_system_pathname(&new_ptn, "/path/to/new-file.ext");
if (mmux_libc_link(old_ptn, new_ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_linkat (mmux_libc_file_descriptor_t @var{oldfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newfd}, mmux_libc_file_system_pathname_t @var{newname}, mmux_sint_t @var{flags})
@MmuxCInterface{linkat}

@example
mmux_libc_ptn_t         old_ptn, new_ptn;
mmux_libc_fd_t          fd;
mmux_sint_t             flags = MMUX_LIBC_AT_SYMLINK_FOLLOW;

mmux_libc_make_file_system_pathname(&old_ptn, "/path/to/old-file.ext");
mmux_libc_make_file_system_pathname(&new_ptn, "/path/to/new-file.ext");
mmux_libc_at_fdcwd(&fd);
if (mmux_libc_linkat(fd, src_ptn, fd, dst_ptn, flags)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs links symbolic
@subsection File system symbolic links


@cindex File system, symbolic links
@cindex Symbolic links, file system


@deftypefun bool mmux_libc_symlink (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{symlink}.

@example
mmux_libc_ptn_t         old_ptn, new_ptn;

mmux_libc_make_file_system_pathname(&old_ptn, "/path/to/old-file.ext");
mmux_libc_make_file_system_pathname(&new_ptn, "/path/to/new-file.ext");
if (mmux_libc_symlink(old_ptn, new_ptn)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs links follow
@subsection Following file system symbolic links


@cindex File system, real pathnames
@cindex Real pathnames, file system


@menu
* fs links follow pathnames::   Follow file system links by pathname.
* fs links follow fds::         Follow file system links by file descriptor.
@end menu

@c page
@node fs links follow pathnames
@subsubsection Follow file system links by pathname


@deftypefun bool mmux_libc_readlink (mmux_usize_t * @var{required_nbytes_p}, mmux_libc_file_system_pathname_t @var{linkname}, mmux_asciizp_t @var{buffer}, mmux_usize_t @var{provided_nbytes})
@MmuxCInterface{readlink}.  It is usually better to use @cfunc{mmux_libc_readlink_malloc}.

@example
mmux_libc_ptn_t 	org_ptn, rea_ptn;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");
@{
  mmux_usize_t          provided_nbytes_with_nul = 1024;
  char                  bufptr[provided_nbytes_with_nul];
  mmux_usize_t          nbytes_done_no_nul;

  mmux_libc_memzero(bufptr, provided_nbytes_with_nul);

  if (mmux_libc_readlink(&nbytes_done_no_nul, lnk_ptn, bufptr, provided_nbytes_with_nul-1)) @{
    /* error */
  @} else if (nbytes_done_no_nul == provided_nbytes_with_nul) @{
    /* not enough bytes in the supplied buffer */
  @}
  if (mmux_libc_file_system_pathname_malloc(&rea_ptn, bufptr)) @{
    /* error */
  @}
@}
@{
  ... /* do something with "rea_ptn" */
@}
mmux_libc_file_system_pathname_free(rea_ptn);
@end example
@end deftypefun


@deftypefun bool mmux_libc_readlink_malloc (mmux_libc_file_system_pathname_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Like @cfunc{mmux_libc_readlink} but when successful: allocate a memory block, using
@cfunc{mmux_libc_malloc}, and store the resulting pathname @asciiz{} string in it; we must release
the allocated memory using @cfunc{mmux_libc_free}.

@example
mmux_libc_ptn_t	org_ptn, rea_ptn;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");
if (mmux_libc_readlink_malloc(&rea_ptn, org_ptn)) @{
  /* error */
@}
@{
  ... /* do something with "rea_ptn" */
@}
mmux_libc_file_system_pathname_free(rea_ptn);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_readlinkat (mmux_usize_t * @var{required_nbytes_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{linkname}, mmux_asciizp_t @var{buffer}, mmux_usize_t @var{provided_nbytes})
@MmuxCInterface{readlinkat}.  It is usually better to use @cfunc{mmux_libc_readlinkat_malloc}.

@example
mmux_libc_ptn_t 	org_ptn, rea_ptn;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");
@{
  mmux_usize_t          provided_nbytes_with_nul = 1024;
  char                  bufptr[provided_nbytes_with_nul];
  mmux_usize_t          nbytes_done_no_nul;
  mmux_libc_fd_t        dirfd;

  mmux_libc_memzero(bufptr, provided_nbytes_with_nul);

  if (mmux_libc_readlinkat(&nbytes_done_no_nul, dirfd, lnk_ptn, bufptr, provided_nbytes_with_nul-1)) @{
    /* error */
  @} else if (nbytes_done_no_nul == provided_nbytes_with_nul) @{
    /* not enough bytes in the supplied buffer */
  @}
  if (mmux_libc_file_system_pathname_malloc(&rea_ptn, bufptr)) @{
    /* error */
  @}
@}
@{
  ... /* do something with "rea_ptn" */
@}
mmux_libc_file_system_pathname_free(rea_ptn);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_readlinkat_malloc (mmux_libc_file_system_pathname_t * @var{result_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{linkname})
Like @cfunc{mmux_libc_readlinkat} but when successful: allocate a memory block, using
@cfunc{mmux_libc_malloc}, and store the resulting pathname @asciiz{} string in it; we must release
the allocated memory using @cfunc{mmux_libc_free}.

@example
mmux_libc_ptn_t         org_ptn, rea_ptn;
mmux_libc_fd_t          dirfd;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");
mmux_libc_at_fdcwd(&dirfd);
if (mmux_libc_readlinkat_malloc(&rea_ptn, dirfd, org_ptn)) @{
  /* error */
@}
@{
  ... /* do something with "rea_ptn" */
@}
mmux_libc_file_system_pathname_free(rea_ptn);
@end example
@end deftypefun


@deftypefun bool mmux_libc_canonicalize_file_name (mmux_libc_file_system_pathname_t * @var{result_pathname_p}, mmux_libc_file_system_pathname_t @var{input_pathname})
@MmuxCInterface{canonicalize_file_name}.  When successful: a memory buffer is allocated, using
@cfunc{mmux_libc_malloc}, and the resulting pathname is stored in it, including the terminating nul;
a pointer to the buffer is stored in the location referenced by @var{result_pathname_p}.  It is
responsibility of the caller to release the buffer with a call to @cfunc{mmux_libc_free}.
@end deftypefun


@deftypefun bool mmux_libc_realpath (mmux_asciizp_t * @var{result_pathname_p}, mmux_libc_file_system_pathname_t @var{input_pathname})
@MmuxCInterface{realpath}.  When successful: a memory buffer is allocated, using
@cfunc{mmux_libc_malloc}, and the resulting pathname is stored in it, including the terminating nul;
a pointer to the buffer is stored in the location referenced by @var{result_pathname_p}.  It is
responsibility of the caller to release the buffer with a call to @cfunc{mmux_libc_free}.
@end deftypefun

@c page
@node fs links follow fds
@subsubsection Follow file system links by file descriptor


The following functions are wrappers for @cfunc{readlinkat}, @MmuxCFuncpage{readlinkat}.  They are
invoked in the special way supported by the latest Linux kernels: with the @asciiz{} string
representing the file system pathname set to the empty string.  This causes the file descriptor
argument to be meant to represent the link to follow through to the real file description.


@deftypefn {Linux Function} bool mmux_libc_readlinkfd (mmux_usize_t * @var{required_nbytes_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_asciizp_t @var{buffer}, mmux_usize_t @var{provided_nbytes})
Wrapper for @cfunc{readlinkat} called with empty file system pathname.  It is usually better to use
@cfunc{mmux_libc_readlinkfd_malloc}.

@example
mmux_libc_ptn_t         org_ptn, rea_ptn;
mmux_libc_fd_t          org_fd;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&org_fd, org_ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Read the link. */
@{
  mmux_usize_t          provided_nbytes_with_nul = 1024;
  char                  bufptr[provided_nbytes_with_nul];
  mmux_usize_t          nbytes_done_no_nul;

  mmux_libc_memzero(bufptr, provided_nbytes_with_nul);

  if (mmux_libc_readlinkfd(&nbytes_done_no_nul, org_fd, bufptr, provided_nbytes_with_nul-1)) @{
    /* error */
  @} else if (nbytes_done_no_nul == provided_nbytes_with_nul) @{
    /* not enough bytes in the supplied buffer */
  @}
  if (mmux_libc_file_system_pathname_malloc(&rea_ptn, bufptr)) @{
    /* error */
  @}
@}

/* Do something with "rea_ptn". */
@{
  ...
@}

/* Release the asynchronous resources. */
@{
  mmux_libc_file_system_pathname_free(rea_ptn);
  if (mmux_libc_close(org_fd)) @{
      /* error */
  @}
@}
@end example
@end deftypefn

@c ------------------------------------------------------------------------

@deftypefn {Linux Function} bool mmux_libc_readlinkfd_malloc (mmux_libc_file_system_pathname_t * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Like @cfunc{mmux_libc_readlinkfd} but when successful: allocate a memory block, using
@cfunc{mmux_libc_malloc}, and store the resulting pathname @asciiz{} string in it; we must release
the allocated memory using @cfunc{mmux_libc_free}.

@example
mmux_libc_ptn_t         org_ptn, rea_ptn;
mmux_libc_fd_t          org_fd;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&org_fd, org_ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Read the link. */
@{
  if (mmux_libc_readlinkfd_malloc(&rea_ptn, org_fd)) @{
    /* error */
  @}
@}

/* Do something with "rea_ptn". */
@{
  ...
@}

/* Release the asynchronous resources. */
@{
  mmux_libc_file_system_pathname_free(rea_ptn);
  if (mmux_libc_close(org_fd)) @{
      /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fs deleting
@section Deleting links


@deftypefun bool mmux_libc_unlink (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{unlink}.
@end deftypefun


@deftypefun bool mmux_libc_unlinkat (mmux_libc_file_descriptor_t dirfd, mmux_libc_file_system_pathname_t pathname, mmux_sint_t flags)
@MmuxCInterface{unlinkat}.
@end deftypefun


@deftypefun bool mmux_libc_rmdir (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{rmdir}.
@end deftypefun


@deftypefun bool mmux_libc_remove (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{remove}.
@end deftypefun

@c page
@node fs renaming
@section Renaming links


@deftypefun bool mmux_libc_rename (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{rename}.
@end deftypefun


@deftypefun bool mmux_libc_renameat (mmux_libc_file_descriptor_t @var{olddirfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newdirfd}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{renameat}.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_renameat2 (mmux_libc_file_descriptor_t @var{olddirfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newdirfd}, mmux_libc_file_system_pathname_t @var{newname}, mmux_uint_t flags)
@MmuxCInterface{renameat2}.
@end deftypefn

@c page
@node fs directories
@section Directories


@deftypefun bool mmux_libc_mkdir (mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t mode)
@MmuxCInterface{mkdir}.
@end deftypefun


@deftypefun bool mmux_libc_mkdirat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode})
@MmuxCInterface{mkdirat}.
@end deftypefun

@c page
@node fs ownership
@section File ownership


@deftypefun bool mmux_libc_chown (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterface{chown}.
@end deftypefun


@deftypefun bool mmux_libc_fchown (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterface{fchown}.
@end deftypefun


@deftypefun bool mmux_libc_lchown (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterface{lchown}.
@end deftypefun


@deftypefun bool mmux_libc_fchownat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid}, mmux_sint_t flags);
@MmuxCInterface{fchownat}.
@end deftypefun

@c page
@node fs permissions
@section File access permissions


@deftypefun bool mmux_libc_umask (mmux_mode_t * @var{old_mask_p}, mmux_mode_t @var{new_mask})
@MmuxCInterface{umask}.
@end deftypefun


@deftypefun bool mmux_libc_getumask (mmux_mode_t * @var{current_mask_p})
Store the current mask in the location referenced by @var{current_mask_p}.  Do not change the
current mask.
@end deftypefun


@deftypefun bool mmux_libc_chmod (mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode})
@MmuxCInterface{chmod}.
@end deftypefun


@deftypefun bool mmux_libc_fchmod (mmux_libc_file_descriptor_t @var{fd}, mmux_mode_t @var{mode})
@MmuxCInterface{fchmod}.
@end deftypefun


@deftypefun bool mmux_libc_fchmodat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode}, mmux_sint_t @var{flags})
@MmuxCInterface{fchmodat}.
@end deftypefun


@deftypefun bool mmux_libc_access (mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{how})
@MmuxCInterface{access}.
@end deftypefun


@deftypefun bool mmux_libc_faccessat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{how}, mmux_sint_t @var{flags})
@MmuxCInterface{faccessat}.
@end deftypefun

@c page
@node fs attributes
@section File attributes


@menu
* fs attributes struct::        The @objtype{mmux_libc_stat_t} data structure.
* fs attributes stat::          The @cfunc{stat} functions.
* fs attributes mode::          Inspecting the mode field of @objtype{mmux_libc_stat_t}.
* fs attributes pathnames::     File system pathname predicates.
* fs attributes fds::           File descriptors predicates.
@end menu

@c page
@node fs attributes struct
@subsection The @objtype{mmux_libc_stat_t} data structure


@MmuxCStructOpaqueTypedef{stat}
@MmuxSetterGetter{stat, st_mode,        mmux_mode_t}
@MmuxSetterGetter{stat,	st_ino,		mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_dev,		mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_nlink,	mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_uid,		mmux_libc_uid_t}
@MmuxSetterGetter{stat,	st_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{stat,	st_size,	mmux_off_t}
@MmuxSetterGetter{stat,	st_atime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_atime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_mtime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_mtime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_ctime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_ctime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_blocks,	mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_blksize,	mmux_uint_t}
@MmuxStructDumper{stat}


@deftypefun bool mmux_libc_S_TYPEISMQ (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPESIMQ}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISSEM (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPEISSEM}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISSHM (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPEISSHM}.
@end deftypefun

@c page
@node fs attributes stat
@subsection The @cfunc{stat} functions


@deftypefun bool mmux_libc_stat (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{stat}.
@end deftypefun


@deftypefun bool mmux_libc_fstat (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{fstat}.
@end deftypefun


@deftypefun bool mmux_libc_lstat (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{lstat}.
@end deftypefun


@deftypefun bool mmux_libc_fstatat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p}, mmux_sint_t flags)
@MmuxCInterface{fstatat}.
@end deftypefun

@c page
@node fs attributes mode
@subsection Inspecting the mode field of @objtype{mmux_libc_stat_t}


@deftypefun bool mmux_libc_S_ISDIR (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISDIR}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISCHR (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISCHR}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISBLK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISBLK}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISREG (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISREG}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISFIFO (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISFIFO}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISLNK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISLNK}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISSOCK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISSOCK}.
@end deftypefun

@c page
@node fs attributes pathnames
@subsection File system pathname predicates


For all the following functions: the test is performed using @cfunc{mmux_libc_lstat}, so the
pathname itself is inspected without following symbolic links.


@deftypefun bool mmux_libc_file_system_pathname_exists (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_exists(&the_pathname_exists, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_regular (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a regular file; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_regular;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_regular(&the_pathname_exists_and_it_is_regular, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_symlink (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a symbolic link; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_symlink;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_symlink(&the_pathname_exists_and_it_is_symlink, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_directory (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a directory; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_directory;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_directory(&the_pathname_exists_and_it_is_directory, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_character_special (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a character special device; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_character_special;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_character_special(&the_pathname_exists_and_it_is_character_special, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_block_special (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a block special device; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_block_special;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_block_special(&the_pathname_exists_and_it_is_block_special, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_fifo (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a FIFO; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_fifo;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_fifo(&the_pathname_exists_and_it_is_fifo, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_socket (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a socket; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_socket;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_socket(&the_pathname_exists_and_it_is_socket, ptn)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs attributes fds
@subsection File descriptors predicates


@deftypefun bool mmux_libc_file_descriptor_is_regular (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
regular file; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_regular;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_regular(&the_fd_is_regular, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_symlink (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
symbolic link; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_symlink;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_symlink(&the_fd_is_symlink, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_directory (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
directory; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_directory;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_directory(&the_fd_is_directory, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_character_special (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
character special device; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_character_special;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_character_special(&the_fd_is_character_special, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_block_special (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a block
special device; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_block_special;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_block_special(&the_fd_is_block_special, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_fifo (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a FIFO;
otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_fifo;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_fifo(&the_fd_is_fifo, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_socket (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
socket; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_socket;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_socket(&the_fd_is_socket, ptn)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs truncating
@section Truncating files


@deftypefun bool mmux_libc_truncate (mmux_libc_file_system_pathname_t pathname, mmux_off_t len)
@MmuxCInterface{truncate}.
@end deftypefun


@deftypefun bool mmux_libc_ftruncate (mmux_libc_file_descriptor_t fd, mmux_off_t len);
@MmuxCInterface{ftruncate}.
@end deftypefun

@c page
@node fs times
@section File system times


@MmuxCStructOpaqueTypedef{utimbuf}
@MmuxSetterGetter{utimbuf, actime,  mmux_time_t}
@MmuxSetterGetter{utimbuf, modtime, mmux_time_t}
@MmuxStructDumper{utimbuf}


@deftypefun bool mmux_libc_utime (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_utimbuf_t @var{utimbuf})
@MmuxCInterface{utime}.
@end deftypefun


@deftypefun bool mmux_libc_utimes (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{utimes}.
@end deftypefun

@deftypefun bool mmux_libc_lutimes (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{lutimes}.
@end deftypefun


@deftypefun bool mmux_libc_futimes (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{futimes}.
@end deftypefun

@c page
@node sockets
@chapter Networking sockets


@menu
* sockets inames::              Socket interface names.
* sockets in_addr::             Address format @objtype{mmux_libc_in_addr_t}.
* sockets insix_addr::          Address format @objtype{mmux_libc_insix_addr_t}.
* sockets sockaddr_un::         Address format @objtype{mmux_libc_sockaddr_un_t}.
* sockets sockaddr_in::         Address format @objtype{mmux_libc_sockaddr_in_t}.
* sockets sockaddr_insix::      Address format @objtype{mmux_libc_sockaddr_insix_t}.
* sockets sockaddr::            Address format @objtype{mmux_libc_sockaddr_t}.
* sockets addrinfo::            Address informations.
* sockets hostsdb::             Hosts database.
* sockets servicesdb::          Services database.
* sockets protocolsdb::         Protocols database.
* sockets networksdb::          Networks database.
* sockets byteorder::           Converting byte order in socket addresses.
* sockets convaddr::            Converting socket addresses between formats.
* sockets getaddrinfo::         Getting address informations.
* sockets getnameinfo::         Getting address name informations.
* sockets creating::            Sockets: creating, pairs, shutting down, inspecting.
* sockets stream::              Sending and receiving data through a stream socket.
* sockets server::              Stream socket servers.
* sockets client::              Stream socket clients.
* sockets dgram::               Sending and receiving data through a datagram socket.
* sockets options::             Socket options.
@end menu

@c page
@node sockets inames
@section Socket interface names


@MmuxCStructOpaqueTypedef{if_nameindex}
@MmuxCStructPointerOpaqueTypedef{if_nameindex}
@MmuxSetterGetter{if_nameindex, if_index, mmux_uint_t}
@MmuxSetterGetter{if_nameindex, if_name,  mmux_asciizcp_t}
@MmuxStructDumper{if_nameindex}


@deftypefun bool mmux_libc_if_nametoindex (mmux_uint_t * @var{index_p}, mmux_asciizcp_t @var{network_interface_name})
@MmuxCInterface{if_nametoindex}.

@example
mmux_asciizcp_t         network_interface_name = "eth0";
mmux_uint_t             network_interface_index;

if (mmux_libc_if_nametoindex(&network_interface_index, network_interface_name)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_indextoname (mmux_asciizp_t @var{result_network_interface_name}, mmux_uint_t @var{network_interface_index})
@MmuxCInterface{if_indextoname}.

@example
mmux_uint_t     network_interface_index = 2;
char            network_interface_name[MMUX_LIBC_IFNAMSIZ];

if (mmux_libc_if_indextoname(network_interface_name, network_interface_index) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_nameindex (mmux_libc_if_nameindex_t const * * @var{result_nameindex_array_p})
@MmuxCInterface{if_nameindex}.

@example
mmux_libc_if_nameindex_t const *        nameindex_array;

if (mmux_libc_if_nameindex(&nameindex_array)) @{
  /* error */
@}

for (int i=0; true; ++i) @{
  mmux_uint_t           if_index;
  mmux_asciizcp_t       if_name;

  mmux_libc_if_index_ref(&if_index, A + i);
  mmux_libc_if_name_ref (&if_name,  A + i);

  if (if_index) @{
    /* do something with "if_index" and "if_name" */
  @} else @{
    break;
  @}
@}

mmux_libc_if_freenameindex(nameindex_array);
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_freenameindex (mmux_libc_if_nameindex_t const * @var{nameindex_array})
@MmuxCInterface{if_freenameindex}.
@end deftypefun

@c page
@node sockets in_addr
@section Address format @objtype{mmux_libc_in_addr_t}


Data structures of type @objtype{mmux_libc_in_addr_t} represent IPv4 addresses in numerical form, as
32-bit values stored in network byte order.


@MmuxCStructOpaqueTypedef{in_addr}
@MmuxCStructPointerOpaqueTypedef{in_addr}
@MmuxSetterGetter{in_addr, s_addr, mmux_uint32_t}
@MmuxStructDumper{in_addr}


@deftypefun bool mmux_libc_make_in_addr (mmux_libc_in_addr_t * in_addr_p, mmux_uint32_t network_byteorder_value)
Initialise the data structure referenced by @var{in_addr_p} to the address
@var{network_byteorder_value}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_none (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_NONE}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_any (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_ANY}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_broadcast (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_BROADCAST}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_loopback (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_LOOPBACK}.
@end deftypefun

@c page
@node sockets insix_addr
@section Address format @objtype{mmux_libc_insix_addr_t}


Data structures of type @objtype{mmux_libc_insix_addr_t} represent IPv6 addresses in binary format.


@deftp {Opaque Struct Typedef} mmux_libc_insix_addr_t
An opaque alias for @code{struct in6_addr}.
@end deftp

@MmuxCStructPointerOpaqueTypedef{insix_addr}
@MmuxStructDumper{insix_addr}


@deftypefun bool mmux_libc_make_insix_addr_loopback (mmux_libc_insix_addr_t * @var{insix_addr_p})
Initialise the data structure referenced by @var{insix_addr_p} to the predefined standard
@code{in6addr_loopback}.
@end deftypefun


@deftypefun bool mmux_libc_make_insix_addr_any (mmux_libc_insix_addr_t * @var{insix_addr_p})
Initialise the data structure referenced by @var{insix_addr_p} to the predefined standard
@code{in6addr_any}.
@end deftypefun

@c page
@node sockets sockaddr_un
@section Address format @objtype{mmux_libc_sockaddr_un_t}


@MmuxCStructOpaqueTypedef{sockaddr_un}
@MmuxCStructPointerOpaqueTypedef{sockaddr_un}
@MmuxSetterGetter{sockaddr_un, sun_family, mmux_sshort_t}
@MmuxSetterGetter{sockaddr_un, sun_path,   mmux_libc_file_system_pathname_t}
@MmuxStructDumper{sockaddr_un}


The file system pathname associated to an address of format @objtype{mmux_libc_sockaddr_un_t} is
embedded in the data structure itself; it has maximum length of fixed size, hard--coded in the data
structure definition.  The pathname must be an @asciiz{} string and the terminating nul must be
included in the embedded @asciiz{} string.

If we want to allocate a block of memory wide enough to contain a pathname of maximum length we have
to take the @cfunc{sizeof} of the data structure type.  If we want to compute the address size
needed as arguments by some socket functions: we have to use the following function.


@deftypefun mmux_usize_t mmux_libc_SUN_LEN (mmux_libc_sockaddr_un_t const * @var{sockaddr_un_p})
Return the address size, measured in bytes, of the address data structure referenced by
@var{sockaddr_un_p}.

@itemize
@item
The returned size does @strong{not} include the terminating nul of the included file pathname.

@item
The returned size is the correct value to hand to functions requiring the address size, like
@cfunc{mmux_libc_bind}.
@end itemize
@end deftypefun

@c page
@node sockets sockaddr_in
@section Address format @objtype{mmux_libc_sockaddr_in_t}


@MmuxCStructOpaqueTypedef{sockaddr_in}
@MmuxCStructPointerOpaqueTypedef{sockaddr_in}
@MmuxSetterGetter{sockaddr_in, sin_family, mmux_sshort_t}
@MmuxSetterGetter{sockaddr_in, sin_addr,   mmux_libc_in_addr_t}
@MmuxSetterGetter{sockaddr_in, sin_port,   mmux_host_byteorder_ushort_t}
@MmuxStructDumper{sockaddr_in}


@deftypefun bool mmux_libc_sin_addr_p_ref (mmux_libc_in_addr_t ** sin_addr_pp, mmux_libc_sockaddr_in_t * sockaddr_p)
Store in the location referenced by @var{sin_addr_pp} a pointer to the field @code{sin_addr} of the
data structure referenced by @var{sockaddr_p}.
@end deftypefun

@c page
@node sockets sockaddr_insix
@section Address format @objtype{mmux_libc_sockaddr_insix_t}


To ease typing on keyboards, @value{PACKAGE} renames: the name of the data structure @code{struct
sockaddr_in6} to @objtype{mmux_libc_sockaddr_insix_t}; the fields @code{sin6_} of @code{struct
sockaddr_in6} to @code{sinsix_}.


@deftp {Opaque Struct Typedef} mmux_libc_sockaddr_insix_t
An opaque alias for @code{struct sockaddr_in6}.
@end deftp


@MmuxCStructPointerOpaqueTypedef{sockaddr_insix}
@MmuxSetterGetter{sockaddr_insix, sinsix_family,   mmux_sshort_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_addr,     mmux_libc_insix_addr_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_flowinfo, mmux_uint32_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_scope_id, mmux_uint32_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_port,     mmux_host_byteorder_uint16_t}
@MmuxStructDumper{sockaddr_insix}


@deftypefun bool mmux_libc_sinsix_addr_p_ref (mmux_libc_insix_addr_t ** @var{sin_addr_pp}, mmux_libc_sockaddr_in_t * @var{sockaddr_p})
Store in the location referenced by @var{sinsix_addr_pp} a pointer to the field @code{sinsix_addr}
of the data structure referenced by @var{sockaddr_p}.
@end deftypefun

@c page
@node sockets sockaddr
@section Address format @objtype{mmux_libc_sockaddr_t}


@deftp {Opaque Struct Typedef} mmux_libc_sockaddr_t
An opaque alias for a non--standard data structure type: we can handle this type as being big enough
to contain any of the data structure types @code{struct sockaddr_*}.  @value{PACKAGE} uses this data
type as alias for @MmuxCStruct{sockaddr}.
@end deftp

@MmuxCStructPointerOpaqueTypedef{sockaddr}
@MmuxSetterGetter{sockaddr, sa_family,   mmux_sshort_t}
@MmuxStructDumper{sockaddr}

@c page
@node sockets addrinfo
@section Address informations


@MmuxCStructOpaqueTypedef{addrinfo}
@MmuxCStructPointerOpaqueTypedef{addrinfo}
@MmuxSetterGetter{addrinfo, ai_flags,           mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_family,          mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_socktype,        mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_protocol,        mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_addrlen,         mmux_socklen_t}
@MmuxSetterGetter{addrinfo, ai_addr,            mmux_libc_sockaddr_t *}
@MmuxSetterGetter{addrinfo, ai_canonname,       mmux_asciizp_t}
@MmuxSetterGetter{addrinfo, ai_next,            mmux_libc_addrinfo_t *}
@MmuxStructDumper{addrinfo}

@c page
@node sockets hostsdb
@section Hosts database


@MmuxCStructOpaqueTypedef{hostent}
@MmuxCStructPointerOpaqueTypedef{hostent}
@MmuxSetterGetter{hostent, h_name,              mmux_asciizp_t}
@MmuxSetterGetter{hostent, h_aliases,           mmux_asciizpp_t}
@MmuxSetterGetter{hostent, h_addrtype,          mmux_sint_t}
@MmuxSetterGetter{hostent, h_length,            mmux_sint_t}
@MmuxSetterGetter{hostent, h_addr_list,         mmux_asciizpp_t}
@MmuxSetterGetter{hostent, h_addr,              mmux_asciizp_t}
@MmuxStructDumper{hostent}


@deftypefun bool mmux_libc_sethostent (mmux_sint_t @var{stayopen})
@MmuxCInterface{sethostent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endhostent (void)
@MmuxCInterface{endhostent}.
@end deftypefun


@deftypefun bool mmux_libc_gethostent (mmux_libc_hostent_t const * * @var{result_hostent_pp})
@MmuxCInterface{gethostent}.
@end deftypefun

@c page
@node sockets servicesdb
@section Services database


@MmuxCStructOpaqueTypedef{servent}
@MmuxCStructPointerOpaqueTypedef{servent}
@MmuxSetterGetter{servent, s_name,		mmux_asciizp_t}
@MmuxSetterGetter{servent, s_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{servent, s_port,		mmux_sint_t}
@MmuxSetterGetter{servent, s_proto,		mmux_asciizp_t}
@MmuxStructDumper{servent}


@deftypefun bool mmux_libc_setservent (mmux_sint_t @var{stayopen})
@MmuxCInterface{setservent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endservent (void)
@MmuxCInterface{endservent}.
@end deftypefun


@deftypefun bool mmux_libc_getservent (mmux_libc_servent_t const * * @var{result_servent_pp})
@MmuxCInterface{getservent}.
@end deftypefun


@deftypefun bool mmux_libc_getservbyname(mmux_libc_servent_t const * * @var{result_servent_pp}, mmux_asciizcp_t @var{service_name_p}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getservbyname}.  If an error occurs: @var{result_servent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_servent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 service_name_p  = "smtp";
mmux_asciizcp_t                 protocol_name_p = "tcp";
mmux_libc_servent_t const *     servent_p;

if (mmux_libc_getservbyname(&servent_p, service_name_p, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getservbyport (mmux_libc_servent_t const * * @var{result_servent_pp}, mmux_sint_t @var{host_byteorder_port}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getservbyport}.  If an error occurs: @var{result_servent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_servent_pp} is never set to
@cnull{}.

@example
mmux_sint_t                     host_byteorder_port = 25;
mmux_asciizcp_t                 protocol_name_p     = "tcp";
mmux_libc_servent_t const *     servent_p;

if (mmux_libc_getservbyport(&servent_p, host_byteorder_port, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node sockets protocolsdb
@section Protocols database


@MmuxCStructOpaqueTypedef{protoent}
@MmuxCStructPointerOpaqueTypedef{protoent}
@MmuxSetterGetter{protoent, p_name,		mmux_asciizp_t}
@MmuxSetterGetter{protoent, p_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{protoent, p_proto,		mmux_sint_t}
@MmuxStructDumper{protoent}


@deftypefun bool mmux_libc_setprotoent (mmux_sint_t @var{stayopen})
@MmuxCInterface{setprotoent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endprotoent (void)
@MmuxCInterface{endprotoent}.
@end deftypefun


@deftypefun bool mmux_libc_getprotoent (mmux_libc_protoent_t const * * @var{result_protoent_pp})
@MmuxCInterface{getprotoent}.
@end deftypefun


@deftypefun bool mmux_libc_getprotobyname (mmux_libc_protoent_t const * * @var{result_protoent_pp}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getprotobyname}.  If an error occurs: @var{result_protoent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_protoent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 protocol_name_p = "tcp";
mmux_libc_protoent_t const *    protoent_p;

if (mmux_libc_getprotobyname(&protoent_p, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getprotobynumber (mmux_libc_protoent_t const * * @var{result_protoent_pp}, mmux_sint_t @var{proto})
@MmuxCInterface{getprotobynumber}.  If an error occurs: @var{result_protoent_pp} is left untouched
and the return value is @ctrue{}.  The location referenced by @var{result_protoent_pp} is never set
to @cnull{}.

@example
mmux_libc_protoent_t const *    protoent_p;

if (mmux_libc_getprotobyname(&protoent_p, MMUX_LIBC_IPPROTO_TCP)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node sockets networksdb
@section Networks database


@MmuxCStructOpaqueTypedef{netent}
@MmuxCStructPointerOpaqueTypedef{netent}
@MmuxSetterGetter{netent, n_name,		mmux_asciizp_t}
@MmuxSetterGetter{netent, n_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{netent, n_addrtype,		mmux_sint_t}
@MmuxSetterGetter{netent, n_net,		mmux_ulong_t}
@MmuxStructDumper{netent}


@deftypefun bool mmux_libc_setnetent (mmux_sint_t @var{stayopen})
@MmuxCInterface{setnetent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endnetent (void)
@MmuxCInterface{endnetent}.
@end deftypefun


@deftypefun bool mmux_libc_getnetent (mmux_libc_netent_t const * * @var{result_netent_pp})
@MmuxCInterface{getnetent}.
@end deftypefun


@deftypefun bool mmux_libc_getnetbyname (mmux_libc_netent_t const * * @var{result_netent_pp}, mmux_asciizcp_t @var{network_name_p})
@MmuxCInterface{getnetbyname}.  If an error occurs: @var{result_netent_pp} is left untouched and the
return value is @ctrue{}.  The location referenced by @var{result_netent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 network_name_p = "loopback";
mmux_libc_netent_t const *      netent_p;

if (mmux_libc_getnetbyname(&netent_p, network_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getnetbyaddr (mmux_libc_netent_t const * * @var{result_netent_pp}, mmux_uint32_t @var{n_net}, mmux_sint_t @var{af_type})
@MmuxCInterface{getnetbyaddr}.  If an error occurs: @var{result_netent_pp} is left untouched and the
return value is @ctrue{}.  The location referenced by @var{result_netent_pp} is never set to
@cnull{}.

The argument @var{n_net} is homogeneous to the values of the field @samp{n_net} of
@MmuxCStruct{netent}: the network address in host byteorder.

@example
mmux_asciizcp_t                 dotted_quad = "127.0.0.0";
mmux_libc_in_addr_t             address;
mmux_uint32_t                   netw_byteorder_n_net;
mmux_uint32_t                   host_byteorder_n_net;
mmux_libc_netent_t const *      netent_p;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET, dotted_quad)) @{
  /* error */
@}
mmux_libc_s_addr_ref(&netw_byteorder_n_net, &address);
mmux_libc_ntohl(&host_byteorder_n_net, netw_byteorder_n_net);
if (mmux_libc_getnetbyaddr(&netent_p, host_byteorder_n_net, MMUX_LIBC_AF_INET)) @{
  /* error */
@}
/* do something with "netent_p" */
@end example
@end deftypefun

@c page
@node sockets byteorder
@section Converting byte order in socket addresses


@deftypefun bool mmux_libc_htons (mmux_uint16_t * network_byteorder_value_p, mmux_uint16_t host_byteorder_value)
@MmuxCInterface{htons}.  Host--to--network short--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_ntohs (mmux_uint16_t * host_byteorder_value_p, mmux_uint16_t network_byteorder_value)
@MmuxCInterface{ntohs}.  Network--to--host short--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_htonl (mmux_uint32_t * network_byteorder_value_p, mmux_uint32_t host_byteorder_value)
@MmuxCInterface{htonl}.  Host--to--network long--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_ntohl (mmux_uint32_t * host_byteorder_value_p, mmux_uint32_t network_byteorder_value)
@MmuxCInterface{ntohl}.  Network--to--host long--number byte order conversion.
@end deftypefun

@c page
@node sockets convaddr
@section Converting socket addresses between formats


@deftypefun bool mmux_libc_inet_pton (mmux_pointer_t @var{ouput_addr_p}, mmux_sint_t @var{input_af_family}, mmux_asciizcp_t @var{input_presentation_p})
@MmuxCInterface{inet_pton}.

Convert the @asciiz{} Internet address presentation referenced by @var{input_presentation_p} into a
binary data structure; the presentation is expected to represent an address in the format specified
by @var{input_af_family}, for example @samp{MMUX_LIBC_AF_INET} or @samp{MMUX_LIBC_AF_INET6}.

When successful, the resulting data structure is stored in the buffer referenced by
@var{ouput_addr_p}; when @var{input_af_family} equals:

@table @samp
@item MMUX_LIBC_AF_INET
The referenced buffer must be a data structure of type @objtype{mmux_libc_in_addr_t}.

@item MMUX_LIBC_AF_INET6
The referenced buffer must be a data structure of type @objtype{mmux_libc_insix_addr_t}.
@end table

Example:

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET, dotted_quad)) @{
  /* error */
@}
@end example

Example:

@example
mmux_asciizcp_t         presentation = "1:2:3:4:5:6:7:8";
mmux_libc_insix_addr_t  address;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET6, presentation)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_ntop (mmux_asciizp_t @var{ouput_presentation_p}, mmux_usize_t @var{ouput_presentation_provided_nchars}, mmux_sint_t @var{input_af_family}, mmux_pointer_t @var{input_addr_p})
@MmuxCInterface{inet_ntop}.

Convert the Internet address data structure referenced by @var{input_addr_p} in its @asciiz{}
presentation and copy it into the buffer referenced by @var{ouput_presentation_p}; the data
structure is expected to represent an address in the format specified by @var{input_af_family}, for
example @samp{MMUX_LIBC_AF_INET} or @samp{MMUX_LIBC_AF_INET6}; when @var{input_af_family} equals:

@table @samp
@item MMUX_LIBC_AF_INET
The referenced data structure must be of type @objtype{mmux_libc_in_addr_t}.

@item MMUX_LIBC_AF_INET6
The referenced data structure must be of type @objtype{mmux_libc_insix_addr_t}.
@end table

If the length of the @asciiz{} presentation, including its terminating nul, is less than or equal to
@var{ouput_presentation_provided_nchars}: the whole string, including its terminating nul, is
written in the output buffer; then the return value if @cfalse{}.  Otherwise nothing is written and
the return value is @ctrue{}.

Example:

@example
mmux_libc_in_addr_t     address;

if (mmux_libc_make_in_addr_broadcast(&address)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntop(str, IS_THIS_ENOUGH_QUESTION_MARK, MMUX_LIBC_AF_INET, &address)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example

Example:

@example
mmux_libc_insix_addr_t     address;

if (mmux_libc_make_insix_addr_loopback(&address)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntop(str, IS_THIS_ENOUGH_QUESTION_MARK, MMUX_LIBC_AF_INET6, &address)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_inet_aton (mmux_libc_in_addr_ptr_t @var{ouput_addr_p}, mmux_asciizcp_t @var{input_presentation_p})
@MmuxCInterface{inet_aton}.

Convert the dotted--quad @asciiz{} representation of an IPv4 address referenced by
@var{input_presentation_p} into a data structure of type @objtype{mmux_libc_in_addr_t}; store the
result in the data structure referenced by @var{ouput_addr_p}.

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_aton(&address, dotted_quad)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_ntoa (mmux_asciizp_t @var{ouput_presentation_p}, mmux_usize_t @var{ouput_presentation_provided_nchars}, mmux_libc_in_addr_t * @var{input_addr_p})
@MmuxCInterface{inet_ntoa}.

Convert the IPv4 address referenced by @var{input_addr_p} in its dotted--quad @asciiz{} presentation
and copy it into the buffer referenced by @var{ouput_presentation_p}.

If the length of the @asciiz{} presentation, including its terminating nul, is less than or equal to
@var{ouput_presentation_provided_nchars}: the whole string, including its terminating nul, is
written in the output buffer; then the return value if @cfalse{}.  Otherwise nothing is written and
the return value is @ctrue{}.

@example
mmux_libc_in_addr_t     in_addr;

if (mmux_libc_make_in_addr_broadcast(&in_addr)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntoa(str, IS_THIS_ENOUGH_QUESTION_MARK, &in_addr)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_addr (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_asciizcp_t @var{presentation_in_addr_p})
@MmuxCInterface{inet_addr}.

If an error occurs: the location referenced by @var{result_in_addr_p} is left untouched; the return
value if @ctrue{}.

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_addr(&address, dotted_quad)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_network (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_asciizcp_t @var{presentation_in_addr_p})
@MmuxCInterface{inet_addr}.

If an error occurs: the location referenced by @var{result_in_addr_p} is left untouched; the return
value if @ctrue{}.
@end deftypefun


@deftypefun bool mmux_libc_inet_makeaddr (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_libc_in_addr_ptr_t @var{net_in_addr_p}, mmux_libc_in_addr_ptr_t @var{local_in_addr_p})
@MmuxCInterface{inet_makeaddr}.
@end deftypefun


@deftypefun bool mmux_libc_inet_lnaof (mmux_libc_in_addr_ptr_t @var{local_in_addr_p}, mmux_libc_in_addr_ptr_t @var{in_addr_p})
@MmuxCInterface{inet_lnaof}.
@end deftypefun


@deftypefun bool mmux_libc_inet_netof (mmux_libc_in_addr_ptr_t @var{net_in_addr_p}, mmux_libc_in_addr_ptr_t @var{in_addr_p})
@MmuxCInterface{inet_netof}.
@end deftypefun

@c page
@node sockets getaddrinfo
@section Getting address informations


Usage example:

@example
mmux_asciizcp_t                 node    = "localhost";
mmux_asciizcp_t                 service = "smtp";
mmux_libc_addrinfo_t            hints;

mmux_libc_addrinfo_ptr_t        addrinfo_linked_list_p;
mmux_sint_t                     error_code;

mmux_libc_ai_flags_set    (&hints, MMUX_LIBC_AI_V4MAPPED | MMUX_LIBC_AI_ADDRCONFIG | MMUX_LIBC_AI_CANONNAME);
mmux_libc_ai_family_set   (&hints, MMUX_LIBC_AF_UNSPEC);
mmux_libc_ai_socktype_set (&hints, MMUX_LIBC_SOCK_STREAM);
mmux_libc_ai_protocol_set (&hints, MMUX_LIBC_IPPROTO_TCP);

if (mmux_libc_getaddrinfo(&addrinfo_linked_list, &error_code, node, service, &hints)) @{
  mmux_asciizcp_t      error_message;

  mmux_libc_gai_strerror(&error_message, error_code);
  /* handle the error */
@} else @{
  /* do something with "addrinfo_linked_list_p" */

  mmux_libc_freeaddrinfo(addrinfo_linked_list_p);
@}
@end example


@deftypefun bool mmux_libc_getaddrinfo (mmux_libc_addrinfo_ptr_t * @var{result_addrinfo_linked_list_pp}, mmux_sint_t * @var{result_error_code_p}, mmux_asciizcp_t @var{node}, mmux_asciizcp_t @var{service}, mmux_libc_addrinfo_ptr_t @var{hints_p})
@MmuxCInterface{getaddrinfo}.
@end deftypefun


@deftypefun bool mmux_libc_freeaddrinfo (mmux_libc_addrinfo_ptr_t @var{addrinfo_linked_list_p})
@MmuxCInterface{freeaddrinfo}.
@end deftypefun


@deftypefun bool mmux_libc_gai_strerror (mmux_asciizcp_t * @var{result_error_message_p}, mmux_sint_t @var{errnum})
@MmuxCInterface{gai_strerror}.
@end deftypefun

@c page
@node sockets getnameinfo
@section Getting address name informations


Usage example:

@example
mmux_libc_sockaddr_in_t input_sockaddr;
mmux_sint_t             error_code;
mmux_sint_t             flags = 0;

#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	512
char                    hostname[IS_THIS_ENOUGH_QUESTION_MARK];
char                    servname[IS_THIS_ENOUGH_QUESTION_MARK];

gimme_an_address(&input_sockaddr);

if (mmux_libc_getnameinfo (hostname, IS_THIS_ENOUGH_QUESTION_MARK,
                           servname, IS_THIS_ENOUGH_QUESTION_MARK,
                           &error_code,
                           &input_sockaddr, sizeof(mmux_libc_sockaddr_in_t), flags)) @{
  mmux_asciizcp_t      error_message;

  mmux_libc_gai_strerror(&error_message, error_code);
  /* handle the error */
@} else @{
  /* do something with "hostname" and "servname" */
@}
@end example


@deftypefun bool mmux_libc_getnameinfo (mmux_asciizcp_t @var{result_hostname_p}, mmux_socklen_t @var{provided_hostname_len}, mmux_asciizcp_t @var{result_servname_p}, mmux_socklen_t @var{provided_servname_len}, mmux_sint_t * @var{result_error_code_p}, mmux_libc_sockaddr_ptr_t @var{input_sockaddr_p}, mmux_socklen_t @var{input_sockaddr_size}, mmux_sint_t @var{flags})
@MmuxCInterface{getnameinfo}.
@end deftypefun

@c page
@node sockets creating
@section Sockets: creating, pairs, shutting down, inspecting


@deftp {Opaque Typedef} mmux_libc_network_socket_t
An alias for @objtype{mmux_libc_file_descriptor_t} representing a networking socket.
@end deftp


@deftypefun bool mmux_libc_make_network_socket (mmux_libc_network_socket_t * @var{result_p}, mmux_sint_t @var{sock_num})
Initialise the value referenced by @var{result_p} with the given integer.
@end deftypefun


@deftypefun bool mmux_libc_socket (mmux_libc_network_socket_t * @var{result_sock_p}, mmux_sint_t @var{pf_namespace}, mmux_sint_t @var{sock_style}, mmux_sint_t @var{ipproto})
@MmuxCInterface{socket}.

@example
mmux_libc_network_socket_t      sock;

if (mmux_libc_socket(&sock, MMUX_LIBC_PF_INET, MMUX_LIBC_SOCK_STREAM, MMUX_LIBC_IPPROTO_TCP)) @{
  /* error */
@}

mmux_libc_shutdown(sock, MMUX_LIBC_SHUT_RDWR);
@end example
@end deftypefun


@deftypefun bool mmux_libc_shutdown (mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{shut_how})
@MmuxCInterface{shutdown}.
@end deftypefun


@deftypefun bool mmux_libc_socketpair (mmux_libc_network_socket_t * @var{result_sock1_p}, mmux_libc_network_socket_t * @var{result_sock2_p}, mmux_sint_t @var{pf_namespace}, mmux_sint_t @var{sock_style}, mmux_sint_t @var{ipproto})
@MmuxCInterface{socketpair}.

@example
mmux_libc_network_socket_t      sock1, sock2;

if (mmux_libc_socketpair(&sock1, &sock2, MMUX_LIBC_PF_LOCAL, MMUX_LIBC_SOCK_STREAM, MMUX_LIBC_IPPROTO_IP)) @{
  /* error */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_getpeername (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t * @var{provided_sockaddr_size})
@MmuxCInterface{getpeername}.

@example
mmux_libc_network_socket_t      sock;
mmux_libc_sockaddr_t            sockaddr;
mmux_socklen_t                  sockaddr_size = sizeof(mmux_libc_sockaddr_t);

gimme_a_stream_sock(&sock);

if (mmux_libc_getpeername(sock, &sockaddr, &sockaddr_size)) @{
  /* error */
@}

/* do something with "sockaddr", whose real size is "sockaddr_size" */
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_getsockname (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t * @var{provided_sockaddr_size})
@MmuxCInterface{getsockname}.

@example
mmux_libc_network_socket_t      sock;
mmux_libc_sockaddr_t            sockaddr;
mmux_socklen_t                  sockaddr_size = sizeof(mmux_libc_sockaddr_t);

gimme_a_stream_sock(&sock);

if (mmux_libc_getsockname(sock, &sockaddr, &sockaddr_size)) @{
  /* error */
@}

/* do something with "sockaddr", whose real size is "sockaddr_size" */
@end example
@end deftypefun

@c page
@node sockets stream
@section Sending and receiving data through a stream socket


@deftypefun bool mmux_libc_send (mmux_usize_t * @var{result_number_of_bytes_sent_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{send}.
@end deftypefun


@deftypefun bool mmux_libc_recv (mmux_usize_t * @var{result_number_of_bytes_received_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{recv}.
@end deftypefun

@c page
@node sockets server
@section Stream socket servers


@deftypefun bool mmux_libc_bind (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t @var{sockaddr_size})
@MmuxCInterface{bind}.
@end deftypefun


@deftypefun bool mmux_libc_listen (mmux_libc_network_socket_t @var{sock}, mmux_uint_t @var{pending_connections_queue_length}a)
@MmuxCInterface{listen}.
@end deftypefun


@deftypefun bool mmux_libc_accept (mmux_libc_network_socket_t * @var{result_connected_sock_p}, mmux_libc_sockaddr_ptr_t @var{result_client_sockaddr_p}, mmux_socklen_t * @var{result_client_sockaddr_size_p}, mmux_libc_network_socket_t @var{server_sock})
@MmuxCInterface{accept}.

@itemize
@item
Upon calling: the location referenced by @var{result_client_sockaddr_size_p} must be set to the
number of bytes allocated for the address referenced by @var{result_client_sockaddr_p}.

@item
Upon successfully returning: the location referenced by @var{result_client_sockaddr_size_p} is reset
to the actual size of the client address.
@end itemize
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_accept4 (mmux_libc_network_socket_t * @var{result_connected_sock_p}, mmux_libc_sockaddr_ptr_t @var{result_client_sockaddr_p}, mmux_socklen_t * @var{result_client_sockaddr_size_p}, mmux_libc_network_socket_t @var{server_sock}, mmux_sint_t @var{flags})
@MmuxCInterface{accept4}.

@itemize
@item
Upon calling: the location referenced by @var{result_client_sockaddr_size_p} must be set to the
number of bytes allocated for the address referenced by @var{result_client_sockaddr_p}.

@item
Upon successfully returning: the location referenced by @var{result_client_sockaddr_size_p} is reset
to the actual size of the client address.
@end itemize
@end deftypefn

@c page
@node sockets client
@section Stream socket clients


@deftypefun bool mmux_libc_connect (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t @var{sockaddr_size})
@MmuxCInterface{connect}.
@end deftypefun

@c page
@node sockets dgram
@section Sending and receiving data through a datagram socket


@deftypefun bool mmux_libc_sendto (mmux_usize_t * @var{result_number_of_bytes_sent_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags}, mmux_libc_sockaddr_ptr_t @var{destination_sockaddr_p}, mmux_socklen_t @var{destination_sockaddr_size})
@MmuxCInterface{sendto}.
@end deftypefun


@deftypefun bool mmux_libc_recvfrom (mmux_usize_t * @var{result_number_of_bytes_received_p}, mmux_libc_sockaddr_ptr_t @var{result_sender_sockaddr_p}, mmux_socklen_t * @var{result_sender_sockaddr_size_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{recvfrom}.

The arguments @var{result_sender_sockaddr_p} and @var{result_sender_sockaddr_size_p} can be
@cnull{} if we are not interested in retrieving the sender address; if they are not @cnull{}:

@itemize
@item
Upon entering the call: the location referenced by @var{result_sender_sockaddr_size_p} must be set
to the number of bytes allocated to contain the sender address.

@item
Upon successfully returning from the call: the location referenced by
@var{result_sender_sockaddr_size_p} is reset to the actual number of bytes required to contain the
sender address.
@end itemize
@end deftypefun

@c page
@node sockets options
@section Socket options


@MmuxCStructOpaqueTypedef{linger}
@MmuxCStructPointerOpaqueTypedef{linger}
@MmuxSetterGetter{linger, l_onoff,		mmux_sint_t}
@MmuxSetterGetter{linger, l_linger,		mmux_sint_t}
@MmuxStructDumper{linger}


@deftypefun bool mmux_libc_getsockopt (mmux_pointer_t @var{result_optval_p}, mmux_socklen_t * @var{result_optlen_p}, mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{level}, mmux_sint_t @var{optname})
@MmuxCInterface{getsockopt}.
@end deftypefun


@deftypefun bool mmux_libc_setsockopt (mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{level}, mmux_sint_t @var{optname}, mmux_pointer_t @var{optval_p}, mmux_socklen_t @var{optlen})
@MmuxCInterface{setsockopt}.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
the package @mmux{} CC Types is available online:

@center @url{https://github.com/marcomaggi/mmux-cc-types/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

