\input texinfo.tex
@c %**start of header
@setfilename mmux-cc-libc.info
@settitle MMUX CC Types
@c %**end of header

@c @include version.texi
@include mmux-version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX CC Libc

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX CC Libc

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-cc-libc

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024, 2025

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_CC_LIBC
@set PackagePkgconfigModule             mmux-cc-libc
@set PackageLibsVar                     @env{MMUX_CC_LIBC_LIBS}
@set PackageCflagsVar                   @env{MMUX_CC_LIBC_CFLAGS}
@c This is the stem of the library in "libmmux-cc-libc.so".
@set PackageLibstem                     mmux-cc-libc
@set PackageApiPrefixLower              mmux_libc_
@set PackageApiPrefixUpper              MMUX_LIBC_

@set PackageHeader                      mmux-cc-libc.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@macro mmuxcctypesref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,mmux-cc-types}
@end macro

@macro MmuxCFuncpage{FUNCNAME}
@ref{\FUNCNAME\,\FUNCNAME\,\FUNCNAME\,*manpages*}
@end macro

@macro MmuxCStruct{NAME}
@code{struct \NAME\}
@end macro

@macro MmuxCInterfaceTwo{FUNCNAME,MANPAGE}
Interface to the function @cfunc{\FUNCNAME\}, @MmuxCFuncpage{\MANPAGE\}
@end macro

@macro MmuxCInterface{FUNCNAME}
@MmuxCInterfaceTwo{\FUNCNAME\,\FUNCNAME\}
@end macro

@macro MmuxCInterfaceGlibc{FUNCNAME,GLIBCNODENAME}
Interface to the function @cfunc{\FUNCNAME\}, @glibcref{\GLIBCNODENAME\,\GLIBCNODENAME\}
@end macro

@macro MmuxCMacroInterfaceTwo{FUNCNAME,MANPAGE}
Interface to the preprocessor macro @cfunc{\FUNCNAME\}, @MmuxCFuncpage{\MANPAGE\}
@end macro

@macro MmuxCMacroInterface{FUNCNAME}
@MmuxCMacroInterfaceTwo{\FUNCNAME\,\FUNCNAME\}
@end macro

@c ------------------------------------------------------------------------

@macro MmuxCStructOpaqueTypedef{STRUCTNAME}
@deftp {Opaque Struct Typedef} mmux_libc_\STRUCTNAME\_t
An opaque alias for @MmuxCStruct{\STRUCTNAME\}.
@end deftp

@end macro

@macro MmuxCStructPointerOpaqueTypedef{STRUCTNAME}
@deftp {Opaque Struct Pointer Typedef} mmux_libc_\STRUCTNAME\_ptr_t
An opaque alias for @code{mmux_libc_\STRUCTNAME\_t *}.
@end deftp

@end macro

@macro MmuxSetterGetter{STRUCTNAME, FIELDNAME, FIELDTYPE}
@deftypefun bool mmux_libc_\FIELDNAME\_set (mmux_libc_\STRUCTNAME\_t * @var{\STRUCTNAME\_p}, \FIELDTYPE\ @var{\FIELDNAME\})
@deftypefunx bool mmux_libc_\FIELDNAME\_ref (\FIELDTYPE\ * @var{result_p}, mmux_libc_\STRUCTNAME\_t const * @var{\STRUCTNAME\_p})
Setter and getter for the field @code{\FIELDNAME\} of @objtype{mmux_libc_\STRUCTNAME\_t}.
@end deftypefun

@end macro


@macro MmuxStructDumper{STRUCTNAME}
@MmuxStructDumperTwo{\STRUCTNAME\,struct \STRUCTNAME\}
@end macro


@macro MmuxStructDumperTwo{STRUCTNAME,STRUCTTYPE}
@deftypefun bool mmux_libc_\STRUCTNAME\_dump (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_\STRUCTNAME\_t const * @var{struct_p}, mmux_asciizcp_t @var{struct_name})
Write to @var{fd} a description of the fields of the @MmuxCStruct{\STRUCTNAME\} referenced by
@var{struct_p}.  @var{struct_name} must be a pointer to an @asciiz{} string representing the name of
the data structure used in the description; when @cnull{}: it defaults to @samp{\STRUCTTYPE\}.
@end deftypefun

@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C11 language
library implementing a wrapper to the @gnu{} C Library that makes it easier to interface it to
high--level platforms.

The package targets @posix{} platforms.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{MmuxPkgSemanticVersion}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-cc-libc: (mmux-cc-libc).       C11 language library wrapper for the @gnu{} C Library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* constants::                   Constants.
* version::                     Version functions.
* initialisation::              Library initialisation.
* errors::                      Errors management.
* memory::                      Memory management.
* strings::                     String operations.
* characters::                  Character operations.
* time::                        Times and dates.
* system::                      System configuration.
* persona::                     Persona operations.
* processes::                   Processes.
* signals::                     Interprocess signals handling.
* fds::                         File descriptors.
* fs::                          File system.
* sockets::                     Networking sockets.
* interface specifications::    Interface specifications.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C11 language
library implementing a wrapper to the @gnu{} C Library that makes it easier to interface it to
high--level platforms.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs multiple header files, of which @value{PackageHeaderFile} is the main one,
exporting the whole library @api{}.  All the function names in the @api{} are prefixed with
@code{@value{PackageApiPrefixLower}}; all the preprocessor symbol names are prefixed with
@code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

The library is installed under @code{$libdir}; for example:

@example
/usr/local/lib64/lib@value{PackageLibstem}.so
@end example

@noindent
C language header files are installed under @code{$includedir}, for example:

@example
/usr/local/include/@value{PackageHeaderFile}
@end example

Before using the library, we must initialise it by calling the appropriate function:

@example
mmux_cc_libc_init();
@end example

@menu
* overview stems::              Specifying C language types with their stem.
* overview errors::             Error handling.
* overview results::            Results handling.
* overview linking::            Linking code with the shared library.
@end menu

@c page
@node overview stems
@section Specifying C language types with their stem


@value{PACKAGE} uses the type definitions of the external package @emph{@mmux{} CC Types},
@mmuxcctypesref{overview stems, Specifying C language types with their stem}.

@c page
@node overview errors
@section Error handling


All the functions return a @objtype{bool} value: @cfalse{} when successful; @ctrue{} when an error
occurs.  The usual function call should look like this:

@example
if (mmux_libc_do_something()) @{
  /* error */
@}
@end example

If a function implemented by the @gnu{} C Library is interfaced by @value{PACKAGE} but it is not
available under a specific platform: the corresponding @value{PACKAGE} function is always
implemented; its return value is a @objtype{bool} and it is always @ctrue{}; it sets @code{errno} to
@samp{MMUX_LIBC_ENOSYS}.

@c page
@node overview results
@section Results handling


Unless otherwise specified, if the first argument of a function is a pointer named @var{result_p},
@var{output_p}, @var{ouput_p}, or similar: the function will store in the referenced location the
result of the call.

For example, we can write:

@example
mmux_slong_t    result;

if (mmux_libc_sysconf(&result, MMUX_LIBC__SC_PAGESIZE)) @{
  /* error */
@}
/* the result is in "result" */
@end example

@c page

@include overview-linking.texi

@c page
@node constants
@chapter Constants


@value{PACKAGE} attempts to offer all the constants implemented by the @gnu{} C Library; the name of
the @value{PACKAGE} constant is the original name prefixed with
@code{@value{PackageApiPrefixUpper}}.


@macro MmuxDefineConstant{NAME}
@defvr {Constant} @value{PackageApiPrefixUpper}\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{@value{PackageApiPrefixUpper}\NAME\} evaluates to the C language constant @code{\NAME\}; it can be
either a preprocessor symbol or an enumerated symbol; it can be defined or not depending on the
features of the underlying platform.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbol
@samp{@value{PackageApiPrefixUpper}\NAME\} is available.
@end defvr

@end macro

@MmuxDefineConstant{AT_EMPTY_PATH}
@MmuxDefineConstant{AT_FDCWD}
@MmuxDefineConstant{AT_NOAUTOMOUNT}
@MmuxDefineConstant{AT_REMOVEDIR}
@MmuxDefineConstant{AT_SYMLINK_FOLLOW}
@MmuxDefineConstant{EOF}
@MmuxDefineConstant{F_DUPFD}
@MmuxDefineConstant{F_GETFD}
@MmuxDefineConstant{F_GETFL}
@MmuxDefineConstant{F_GETLK}
@MmuxDefineConstant{F_GETOWN}
@MmuxDefineConstant{F_OFD_SETLK}
@MmuxDefineConstant{F_OFD_SETLKW}
@MmuxDefineConstant{F_OFD_GETLK}
@MmuxDefineConstant{F_OK}
@MmuxDefineConstant{F_RDLCK}
@MmuxDefineConstant{F_SETFD}
@MmuxDefineConstant{F_SETFL}
@MmuxDefineConstant{F_SETLK}
@MmuxDefineConstant{F_SETLKW}
@MmuxDefineConstant{F_SETOWN}
@MmuxDefineConstant{F_UNLCK}
@MmuxDefineConstant{F_WRLCK}
@MmuxDefineConstant{MAXSYMLINKS}
@MmuxDefineConstant{O_ACCMODE}
@MmuxDefineConstant{O_APPEND}
@MmuxDefineConstant{O_ASYNC}
@MmuxDefineConstant{O_CLOEXEC}
@MmuxDefineConstant{O_CREAT}
@MmuxDefineConstant{O_DIRECT}
@MmuxDefineConstant{O_DIRECTORY}
@MmuxDefineConstant{O_EXCL}
@MmuxDefineConstant{O_EXEC}
@MmuxDefineConstant{O_EXLOCK}
@MmuxDefineConstant{O_FSYNC}
@MmuxDefineConstant{O_IGNORE_CTTY}
@MmuxDefineConstant{O_LARGEFILE}
@MmuxDefineConstant{O_NDELAY}
@MmuxDefineConstant{O_NOATIME}
@MmuxDefineConstant{O_NOCTTY}
@MmuxDefineConstant{O_NOFOLLOW}
@MmuxDefineConstant{O_NOLINK}
@MmuxDefineConstant{O_NONBLOCK}
@MmuxDefineConstant{O_NOTRANS}
@MmuxDefineConstant{O_RDONLY}
@MmuxDefineConstant{O_RDWR}
@MmuxDefineConstant{O_READ}
@MmuxDefineConstant{O_SHLOCK}
@MmuxDefineConstant{O_SYNC}
@MmuxDefineConstant{O_TRUNC}
@MmuxDefineConstant{O_WRITE}
@MmuxDefineConstant{O_WRONLY}
@MmuxDefineConstant{R_OK}
@MmuxDefineConstant{RENAME_EXCHANGE}
@MmuxDefineConstant{RENAME_NOREPLACE}
@MmuxDefineConstant{RENAME_WITHEOUT}
@MmuxDefineConstant{RESOLVE_BENEATH}
@MmuxDefineConstant{RESOLVE_IN_ROOT}
@MmuxDefineConstant{RESOLVE_NO_MAGICLINKS}
@MmuxDefineConstant{RESOLVE_NO_SYMLINKS}
@MmuxDefineConstant{RESOLVE_NO_XDEV}
@MmuxDefineConstant{RESOLVE_CACHED}
@MmuxDefineConstant{SEEK_CUR}
@MmuxDefineConstant{SEEK_DATA}
@MmuxDefineConstant{SEEK_END}
@MmuxDefineConstant{SEEK_HOLE}
@MmuxDefineConstant{SEEK_SET}
@MmuxDefineConstant{S_IRGRP}
@MmuxDefineConstant{S_IROTH}
@MmuxDefineConstant{S_IRUSR}
@MmuxDefineConstant{S_IRWXG}
@MmuxDefineConstant{S_IRWXO}
@MmuxDefineConstant{S_IRWXU}
@MmuxDefineConstant{S_ISGID}
@MmuxDefineConstant{S_ISUID}
@MmuxDefineConstant{S_ISVTX}
@MmuxDefineConstant{S_IWGRP}
@MmuxDefineConstant{S_IWOTH}
@MmuxDefineConstant{S_IWUSR}
@MmuxDefineConstant{S_IXGRP}
@MmuxDefineConstant{S_IXOTH}
@MmuxDefineConstant{S_IXUSR}
@MmuxDefineConstant{MFD_CLOEXEC}
@MmuxDefineConstant{MFD_ALLOW_SEALING}
@MmuxDefineConstant{MFD_HUGETLB}
@MmuxDefineConstant{W_OK}
@MmuxDefineConstant{X_OK}
@MmuxDefineConstant{AF_ALG}
@MmuxDefineConstant{AF_APPLETALK}
@MmuxDefineConstant{AF_AX25}
@MmuxDefineConstant{AF_BLUETOOTH}
@MmuxDefineConstant{AF_CAN}
@MmuxDefineConstant{AF_DECnet}
@MmuxDefineConstant{AF_IB}
@MmuxDefineConstant{AF_INET6}
@MmuxDefineConstant{AF_INET}
@MmuxDefineConstant{AF_IPX}
@MmuxDefineConstant{AF_KCM}
@MmuxDefineConstant{AF_KEY}
@MmuxDefineConstant{AF_LLC}
@MmuxDefineConstant{AF_LOCAL}
@MmuxDefineConstant{AF_MPLS}
@MmuxDefineConstant{AF_NETLINK}
@MmuxDefineConstant{AF_PACKET}
@MmuxDefineConstant{AF_PPPOX}
@MmuxDefineConstant{AF_RDS}
@MmuxDefineConstant{AF_TIPC}
@MmuxDefineConstant{AF_UNIX}
@MmuxDefineConstant{AF_UNSPEC}
@MmuxDefineConstant{AF_VSOCK}
@MmuxDefineConstant{AF_X25}
@MmuxDefineConstant{AF_XDP}
@MmuxDefineConstant{IFNAMSIZ}
@MmuxDefineConstant{PF_FILE}
@MmuxDefineConstant{PF_INET6}
@MmuxDefineConstant{PF_INET}
@MmuxDefineConstant{PF_LOCAL}
@MmuxDefineConstant{PF_UNIX}
@MmuxDefineConstant{PF_UNSPEC}
@MmuxDefineConstant{SHUT_RDWR}
@MmuxDefineConstant{SHUT_RD}
@MmuxDefineConstant{SHUT_WR}
@MmuxDefineConstant{MSG_CONFIRM}
@MmuxDefineConstant{MSG_DONTROUTE}
@MmuxDefineConstant{MSG_DONTWAIT}
@MmuxDefineConstant{MSG_EOR}
@MmuxDefineConstant{MSG_MORE}
@MmuxDefineConstant{MSG_NOSIGNAL}
@MmuxDefineConstant{MSG_OOB}
@MmuxDefineConstant{MSG_PEEK}
@MmuxDefineConstant{SOL_SOCKET}
@MmuxDefineConstant{SO_BROADCAST}
@MmuxDefineConstant{SO_DEBUG}
@MmuxDefineConstant{SO_DONTROUTE}
@MmuxDefineConstant{SO_ERROR}
@MmuxDefineConstant{SO_KEEPALIVE}
@MmuxDefineConstant{SO_LINGER}
@MmuxDefineConstant{SO_OOBINLINE}
@MmuxDefineConstant{SO_RCVBUF}
@MmuxDefineConstant{SO_REUSEADDR}
@MmuxDefineConstant{SO_SNDBUF}
@MmuxDefineConstant{SO_STYLE}
@MmuxDefineConstant{SO_TYPE}
@MmuxDefineConstant{INADDR_ANY}
@MmuxDefineConstant{INADDR_BROADCAST}
@MmuxDefineConstant{INADDR_LOOPBACK}
@MmuxDefineConstant{INADDR_NONE}
@MmuxDefineConstant{AI_ADDRCONFIG}
@MmuxDefineConstant{AI_ADDRCONFIG}
@MmuxDefineConstant{AI_ALL}
@MmuxDefineConstant{AI_CANONIDN}
@MmuxDefineConstant{AI_CANONNAME}
@MmuxDefineConstant{AI_IDN}
@MmuxDefineConstant{AI_NUMERICSERV}
@MmuxDefineConstant{AI_PASSIVE}
@MmuxDefineConstant{AI_V4MAPPED}
@MmuxDefineConstant{NI_DGRAM}
@MmuxDefineConstant{NI_IDN}
@MmuxDefineConstant{NI_NAMEREQD}
@MmuxDefineConstant{NI_NOFQDN}
@MmuxDefineConstant{NI_NUMERICHOST}
@MmuxDefineConstant{NI_NUMERICSERV}

@MmuxDefineConstant{RWF_APPEND}
@MmuxDefineConstant{RWF_DSYNC}
@MmuxDefineConstant{RWF_HIPRI}
@MmuxDefineConstant{RWF_NOWAIT}
@MmuxDefineConstant{RWF_SYNC}

@MmuxDefineConstant{IPPROTO_AH}
@MmuxDefineConstant{IPPROTO_BEETPH}
@MmuxDefineConstant{IPPROTO_COMP}
@MmuxDefineConstant{IPPROTO_DCCP}
@MmuxDefineConstant{IPPROTO_EGP}
@MmuxDefineConstant{IPPROTO_ENCAP}
@MmuxDefineConstant{IPPROTO_ESP}
@MmuxDefineConstant{IPPROTO_ETHERNET}
@MmuxDefineConstant{IPPROTO_GRE}
@MmuxDefineConstant{IPPROTO_ICMP}
@MmuxDefineConstant{IPPROTO_IDP}
@MmuxDefineConstant{IPPROTO_IGMP}
@MmuxDefineConstant{IPPROTO_IP}
@MmuxDefineConstant{IPPROTO_IPIP}
@MmuxDefineConstant{IPPROTO_IPV6}
@MmuxDefineConstant{IPPROTO_MPLS}
@MmuxDefineConstant{IPPROTO_MPTCP}
@MmuxDefineConstant{IPPROTO_MTP}
@MmuxDefineConstant{IPPROTO_PIM}
@MmuxDefineConstant{IPPROTO_PUP}
@MmuxDefineConstant{IPPROTO_RAW}
@MmuxDefineConstant{IPPROTO_RSVP}
@MmuxDefineConstant{IPPROTO_SCTP}
@MmuxDefineConstant{IPPROTO_TCP}
@MmuxDefineConstant{IPPROTO_TP}
@MmuxDefineConstant{IPPROTO_UDP}
@MmuxDefineConstant{IPPROTO_UDPLITE}

@MmuxDefineConstant{IPPORT_BIFFUDP}
@MmuxDefineConstant{IPPORT_CMDSERVER}
@MmuxDefineConstant{IPPORT_DAYTIME}
@MmuxDefineConstant{IPPORT_DISCARD}
@MmuxDefineConstant{IPPORT_ECHO}
@MmuxDefineConstant{IPPORT_EFSSERVER}
@MmuxDefineConstant{IPPORT_EXECSERVER}
@MmuxDefineConstant{IPPORT_FINGER}
@MmuxDefineConstant{IPPORT_FTP}
@MmuxDefineConstant{IPPORT_LOGINSERVER}
@MmuxDefineConstant{IPPORT_MTP}
@MmuxDefineConstant{IPPORT_NAMESERVER}
@MmuxDefineConstant{IPPORT_NETSTAT}
@MmuxDefineConstant{IPPORT_RESERVED}
@MmuxDefineConstant{IPPORT_RJE}
@MmuxDefineConstant{IPPORT_ROUTESERVER}
@MmuxDefineConstant{IPPORT_SMTP}
@MmuxDefineConstant{IPPORT_SUPDUP}
@MmuxDefineConstant{IPPORT_SYSTAT}
@MmuxDefineConstant{IPPORT_TELNET}
@MmuxDefineConstant{IPPORT_TFTP}
@MmuxDefineConstant{IPPORT_TIMESERVER}
@MmuxDefineConstant{IPPORT_TTYLINK}
@MmuxDefineConstant{IPPORT_USERRESERVED}
@MmuxDefineConstant{IPPORT_WHOIS}
@MmuxDefineConstant{IPPORT_WHOSERVER}

@MmuxDefineConstant{SOCK_CLOEXEC}
@MmuxDefineConstant{SOCK_DCCP}
@MmuxDefineConstant{SOCK_DGRAM}
@MmuxDefineConstant{SOCK_NONBLOCK}
@MmuxDefineConstant{SOCK_PACKET}
@MmuxDefineConstant{SOCK_RAW}
@MmuxDefineConstant{SOCK_RDM}
@MmuxDefineConstant{SOCK_SEQPACKET}
@MmuxDefineConstant{SOCK_STREAM}

@MmuxDefineConstant{WAIT_ANY}
@MmuxDefineConstant{WAIT_MYPGRP}

@MmuxDefineConstant{WEXITED}
@MmuxDefineConstant{WNOHANG}
@MmuxDefineConstant{WNOWAIT}
@MmuxDefineConstant{WSTOPPED}
@MmuxDefineConstant{WCONTINUED}
@MmuxDefineConstant{WUNTRACED}

@MmuxDefineConstant{P_ALL}
@MmuxDefineConstant{P_PID}
@MmuxDefineConstant{P_PIDFD}
@MmuxDefineConstant{P_PGID}

@MmuxDefineConstant{EXIT_SUCCESS}
@MmuxDefineConstant{EXIT_FAILURE}

@defvr Constant @value{PackageApiPrefixUpper}MSG_ZERO
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_MSG_ZERO
The symbol @code{@value{PackageApiPrefixUpper}MSG_ZERO} evaluates to zero; it is meant to be used as
@var{flags} argument for @cfunc{mmux_libc_send}, and similar functions, when no other
@code{@value{PackageApiPrefixUpper}MSG_*} flag is needed; it gives the reader of the code a
remainder of which flags are available for the operation.

The symbol @code{MMUX_HAVE_LIBC_MSG_ZERO} is always defined and it evaluates to @samp{1}.
@end defvr

@MmuxDefineConstant{_SC_2_CHAR_TERM}
@MmuxDefineConstant{_SC_2_C_BIND}
@MmuxDefineConstant{_SC_2_C_DEV}
@MmuxDefineConstant{_SC_2_C_VERSION}
@MmuxDefineConstant{_SC_2_FORT_DEV}
@MmuxDefineConstant{_SC_2_FORT_RUN}
@MmuxDefineConstant{_SC_2_LOCALEDEF}
@MmuxDefineConstant{_SC_2_PBS}
@MmuxDefineConstant{_SC_2_PBS_ACCOUNTING}
@MmuxDefineConstant{_SC_2_PBS_CHECKPOINT}
@MmuxDefineConstant{_SC_2_PBS_LOCATE}
@MmuxDefineConstant{_SC_2_PBS_MESSAGE}
@MmuxDefineConstant{_SC_2_PBS_TRACK}
@MmuxDefineConstant{_SC_2_SW_DEV}
@MmuxDefineConstant{_SC_2_UPE}
@MmuxDefineConstant{_SC_2_VERSION}
@MmuxDefineConstant{_SC_ADVISORY_INFO}
@MmuxDefineConstant{_SC_AIO_LISTIO_MAX}
@MmuxDefineConstant{_SC_AIO_MAX}
@MmuxDefineConstant{_SC_AIO_PRIO_DELTA_MAX}
@MmuxDefineConstant{_SC_ARG_MAX}
@MmuxDefineConstant{_SC_ASYNCHRONOUS_IO}
@MmuxDefineConstant{_SC_ATEXIT_MAX}
@MmuxDefineConstant{_SC_AVPHYS_PAGES}
@MmuxDefineConstant{_SC_BARRIERS}
@MmuxDefineConstant{_SC_BASE}
@MmuxDefineConstant{_SC_BC_BASE_MAX}
@MmuxDefineConstant{_SC_BC_DIM_MAX}
@MmuxDefineConstant{_SC_BC_SCALE_MAX}
@MmuxDefineConstant{_SC_BC_STRING_MAX}
@MmuxDefineConstant{_SC_CHARCLASS_NAME_MAX}
@MmuxDefineConstant{_SC_CHAR_BIT}
@MmuxDefineConstant{_SC_CHAR_MAX}
@MmuxDefineConstant{_SC_CHAR_MIN}
@MmuxDefineConstant{_SC_CHILD_MAX}
@MmuxDefineConstant{_SC_CLK_TCK}
@MmuxDefineConstant{_SC_CLOCK_SELECTION}
@MmuxDefineConstant{_SC_COLL_WEIGHTS_MAX}
@MmuxDefineConstant{_SC_CPUTIME}
@MmuxDefineConstant{_SC_C_LANG_SUPPORT}
@MmuxDefineConstant{_SC_C_LANG_SUPPORT_R}
@MmuxDefineConstant{_SC_DELAYTIMER_MAX}
@MmuxDefineConstant{_SC_DEVICE_IO}
@MmuxDefineConstant{_SC_DEVICE_SPECIFIC}
@MmuxDefineConstant{_SC_DEVICE_SPECIFIC_R}
@MmuxDefineConstant{_SC_EQUIV_CLASS_MAX}
@MmuxDefineConstant{_SC_EXPR_NEST_MAX}
@MmuxDefineConstant{_SC_FD_MGMT}
@MmuxDefineConstant{_SC_FIFO}
@MmuxDefineConstant{_SC_FILE_ATTRIBUTES}
@MmuxDefineConstant{_SC_FILE_LOCKING}
@MmuxDefineConstant{_SC_FILE_SYSTEM}
@MmuxDefineConstant{_SC_FSYNC}
@MmuxDefineConstant{_SC_GETGR_R_SIZE_MAX}
@MmuxDefineConstant{_SC_GETPW_R_SIZE_MAX}
@MmuxDefineConstant{_SC_HOST_NAME_MAX}
@MmuxDefineConstant{_SC_INT_MAX}
@MmuxDefineConstant{_SC_INT_MIN}
@MmuxDefineConstant{_SC_IOV_MAX}
@MmuxDefineConstant{_SC_IPV6}
@MmuxDefineConstant{_SC_JOB_CONTROL}
@MmuxDefineConstant{_SC_LEVEL1_DCACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL1_DCACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL1_DCACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL1_ICACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL1_ICACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL1_ICACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL2_CACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL2_CACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL2_CACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL3_CACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL3_CACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL3_CACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL4_CACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL4_CACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL4_CACHE_SIZE}
@MmuxDefineConstant{_SC_LINE_MAX}
@MmuxDefineConstant{_SC_LOGIN_NAME_MAX}
@MmuxDefineConstant{_SC_LONG_BIT}
@MmuxDefineConstant{_SC_MAPPED_FILES}
@MmuxDefineConstant{_SC_MB_LEN_MAX}
@MmuxDefineConstant{_SC_MEMLOCK}
@MmuxDefineConstant{_SC_MEMLOCK_RANGE}
@MmuxDefineConstant{_SC_MEMORY_PROTECTION}
@MmuxDefineConstant{_SC_MESSAGE_PASSING}
@MmuxDefineConstant{_SC_MONOTONIC_CLOCK}
@MmuxDefineConstant{_SC_MQ_OPEN_MAX}
@MmuxDefineConstant{_SC_MQ_PRIO_MAX}
@MmuxDefineConstant{_SC_MULTI_PROCESS}
@MmuxDefineConstant{_SC_NETWORKING}
@MmuxDefineConstant{_SC_NGROUPS_MAX}
@MmuxDefineConstant{_SC_NL_ARGMAX}
@MmuxDefineConstant{_SC_NL_LANGMAX}
@MmuxDefineConstant{_SC_NL_MSGMAX}
@MmuxDefineConstant{_SC_NL_NMAX}
@MmuxDefineConstant{_SC_NL_SETMAX}
@MmuxDefineConstant{_SC_NL_TEXTMAX}
@MmuxDefineConstant{_SC_NPROCESSORS_CONF}
@MmuxDefineConstant{_SC_NPROCESSORS_ONLN}
@MmuxDefineConstant{_SC_NZERO}
@MmuxDefineConstant{_SC_OPEN_MAX}
@MmuxDefineConstant{_SC_PAGESIZE}
@MmuxDefineConstant{_SC_PAGE_SIZE}
@MmuxDefineConstant{_SC_PASS_MAX}
@MmuxDefineConstant{_SC_PHYS_PAGES}
@MmuxDefineConstant{_SC_PII}
@MmuxDefineConstant{_SC_PII_INTERNET}
@MmuxDefineConstant{_SC_PII_INTERNET_DGRAM}
@MmuxDefineConstant{_SC_PII_INTERNET_STREAM}
@MmuxDefineConstant{_SC_PII_OSI}
@MmuxDefineConstant{_SC_PII_OSI_CLTS}
@MmuxDefineConstant{_SC_PII_OSI_COTS}
@MmuxDefineConstant{_SC_PII_OSI_M}
@MmuxDefineConstant{_SC_PII_SOCKET}
@MmuxDefineConstant{_SC_PII_XTI}
@MmuxDefineConstant{_SC_PIPE}
@MmuxDefineConstant{_SC_POLL}
@MmuxDefineConstant{_SC_PRIORITIZED_IO}
@MmuxDefineConstant{_SC_PRIORITY_SCHEDULING}
@MmuxDefineConstant{_SC_RAW_SOCKETS}
@MmuxDefineConstant{_SC_READER_WRITER_LOCKS}
@MmuxDefineConstant{_SC_REALTIME_SIGNALS}
@MmuxDefineConstant{_SC_REGEXP}
@MmuxDefineConstant{_SC_REGEX_VERSION}
@MmuxDefineConstant{_SC_RE_DUP_MAX}
@MmuxDefineConstant{_SC_RTSIG_MAX}
@MmuxDefineConstant{_SC_SAVED_IDS}
@MmuxDefineConstant{_SC_SCHAR_MAX}
@MmuxDefineConstant{_SC_SCHAR_MIN}
@MmuxDefineConstant{_SC_SELECT}
@MmuxDefineConstant{_SC_SEMAPHORES}
@MmuxDefineConstant{_SC_SEM_NSEMS_MAX}
@MmuxDefineConstant{_SC_SEM_VALUE_MAX}
@MmuxDefineConstant{_SC_SHARED_MEMORY_OBJECTS}
@MmuxDefineConstant{_SC_SHELL}
@MmuxDefineConstant{_SC_SHRT_MAX}
@MmuxDefineConstant{_SC_SHRT_MIN}
@MmuxDefineConstant{_SC_SIGNALS}
@MmuxDefineConstant{_SC_SIGQUEUE_MAX}
@MmuxDefineConstant{_SC_SINGLE_PROCESS}
@MmuxDefineConstant{_SC_SPAWN}
@MmuxDefineConstant{_SC_SPIN_LOCKS}
@MmuxDefineConstant{_SC_SPORADIC_SERVER}
@MmuxDefineConstant{_SC_SSIZE_MAX}
@MmuxDefineConstant{_SC_STREAMS}
@MmuxDefineConstant{_SC_STREAM_MAX}
@MmuxDefineConstant{_SC_SYMLOOP_MAX}
@MmuxDefineConstant{_SC_SYNCHRONIZED_IO}
@MmuxDefineConstant{_SC_SYSTEM_DATABASE}
@MmuxDefineConstant{_SC_SYSTEM_DATABASE_R}
@MmuxDefineConstant{_SC_THREADS}
@MmuxDefineConstant{_SC_THREAD_ATTR_STACKADDR}
@MmuxDefineConstant{_SC_THREAD_ATTR_STACKSIZE}
@MmuxDefineConstant{_SC_THREAD_CPUTIME}
@MmuxDefineConstant{_SC_THREAD_DESTRUCTOR_ITERATIONS}
@MmuxDefineConstant{_SC_THREAD_KEYS_MAX}
@MmuxDefineConstant{_SC_THREAD_PRIORITY_SCHEDULING}
@MmuxDefineConstant{_SC_THREAD_PRIO_INHERIT}
@MmuxDefineConstant{_SC_THREAD_PRIO_PROTECT}
@MmuxDefineConstant{_SC_THREAD_PROCESS_SHARED}
@MmuxDefineConstant{_SC_THREAD_SAFE_FUNCTIONS}
@MmuxDefineConstant{_SC_THREAD_SPORADIC_SERVER}
@MmuxDefineConstant{_SC_THREAD_STACK_MIN}
@MmuxDefineConstant{_SC_THREAD_THREADS_MAX}
@MmuxDefineConstant{_SC_TIMEOUTS}
@MmuxDefineConstant{_SC_TIMERS}
@MmuxDefineConstant{_SC_TIMER_MAX}
@MmuxDefineConstant{_SC_TRACE}
@MmuxDefineConstant{_SC_TRACE_EVENT_FILTER}
@MmuxDefineConstant{_SC_TRACE_INHERIT}
@MmuxDefineConstant{_SC_TRACE_LOG}
@MmuxDefineConstant{_SC_TTY_NAME_MAX}
@MmuxDefineConstant{_SC_TYPED_MEMORY_OBJECTS}
@MmuxDefineConstant{_SC_TZNAME_MAX}
@MmuxDefineConstant{_SC_T_IOV_MAX}
@MmuxDefineConstant{_SC_UCHAR_MAX}
@MmuxDefineConstant{_SC_UINT_MAX}
@MmuxDefineConstant{_SC_UIO_MAXIOV}
@MmuxDefineConstant{_SC_ULONG_MAX}
@MmuxDefineConstant{_SC_USER_GROUPS}
@MmuxDefineConstant{_SC_USER_GROUPS_R}
@MmuxDefineConstant{_SC_USHRT_MAX}
@MmuxDefineConstant{_SC_V6_ILP32_OFF32}
@MmuxDefineConstant{_SC_V6_ILP32_OFFBIG}
@MmuxDefineConstant{_SC_V6_LP64_OFF64}
@MmuxDefineConstant{_SC_V6_LPBIG_OFFBIG}
@MmuxDefineConstant{_SC_VERSION}
@MmuxDefineConstant{_SC_WORD_BIT}
@MmuxDefineConstant{_SC_XBS5_ILP32_OFF32}
@MmuxDefineConstant{_SC_XBS5_ILP32_OFFBIG}
@MmuxDefineConstant{_SC_XBS5_LP64_OFF64}
@MmuxDefineConstant{_SC_XBS5_LPBIG_OFFBIG}
@MmuxDefineConstant{_SC_XOPEN_CRYPT}
@MmuxDefineConstant{_SC_XOPEN_ENH_I18N}
@MmuxDefineConstant{_SC_XOPEN_LEGACY}
@MmuxDefineConstant{_SC_XOPEN_REALTIME}
@MmuxDefineConstant{_SC_XOPEN_REALTIME_THREADS}
@MmuxDefineConstant{_SC_XOPEN_SHM}
@MmuxDefineConstant{_SC_XOPEN_UNIX}
@MmuxDefineConstant{_SC_XOPEN_VERSION}
@MmuxDefineConstant{_SC_XOPEN_XCU_VERSION}
@MmuxDefineConstant{_SC_XOPEN_XPG2}
@MmuxDefineConstant{_SC_XOPEN_XPG3}
@MmuxDefineConstant{_SC_XOPEN_XPG4}

@MmuxDefineConstant{_CS_LFS64_CFLAGS}
@MmuxDefineConstant{_CS_LFS64_LDFLAGS}
@MmuxDefineConstant{_CS_LFS64_LIBS}
@MmuxDefineConstant{_CS_LFS64_LINTFLAGS}
@MmuxDefineConstant{_CS_LFS_CFLAGS}
@MmuxDefineConstant{_CS_LFS_LDFLAGS}
@MmuxDefineConstant{_CS_LFS_LIBS}
@MmuxDefineConstant{_CS_LFS_LINTFLAGS}
@MmuxDefineConstant{_CS_PATH}

@MmuxDefineConstant{_PC_ASYNC_IO}
@MmuxDefineConstant{_PC_CHOWN_RESTRICTED}
@MmuxDefineConstant{_PC_FILESIZEBITS}
@MmuxDefineConstant{_PC_LINK_MAX}
@MmuxDefineConstant{_PC_MAX_CANON}
@MmuxDefineConstant{_PC_MAX_INPUT}
@MmuxDefineConstant{_PC_NAME_MAX}
@MmuxDefineConstant{_PC_NO_TRUNC}
@MmuxDefineConstant{_PC_PATH_MAX}
@MmuxDefineConstant{_PC_PIPE_BUF}
@MmuxDefineConstant{_PC_PRIO_IO}
@MmuxDefineConstant{_PC_REC_INCR_XFER_SIZE}
@MmuxDefineConstant{_PC_REC_MAX_XFER_SIZE}
@MmuxDefineConstant{_PC_REC_MIN_XFER_SIZE}
@MmuxDefineConstant{_PC_REC_XFER_ALIGN}
@MmuxDefineConstant{_PC_SYNC_IO}
@MmuxDefineConstant{_PC_VDISABLE}

@MmuxDefineConstant{RLIMIT_AS}
@MmuxDefineConstant{RLIMIT_CORE}
@MmuxDefineConstant{RLIMIT_CPU}
@MmuxDefineConstant{RLIMIT_DATA}
@MmuxDefineConstant{RLIMIT_FSIZE}
@MmuxDefineConstant{RLIMIT_LOCKS}
@MmuxDefineConstant{RLIMIT_MEMLOCK}
@MmuxDefineConstant{RLIMIT_MSGQUEUE}
@MmuxDefineConstant{RLIMIT_NICE}
@MmuxDefineConstant{RLIMIT_NOFILE}
@MmuxDefineConstant{RLIMIT_NPROC}
@MmuxDefineConstant{RLIMIT_RSS}
@MmuxDefineConstant{RLIMIT_RTPRIO}
@MmuxDefineConstant{RLIMIT_RTTIME}
@MmuxDefineConstant{RLIMIT_SIGPENDING}
@MmuxDefineConstant{RLIMIT_STACK}
@MmuxDefineConstant{RLIM_INFINITY}

@MmuxDefineConstant{NSIG}
@MmuxDefineConstant{SIGFPE}
@MmuxDefineConstant{SIGILL}
@MmuxDefineConstant{SIGSEGV}
@MmuxDefineConstant{SIGBUS}
@MmuxDefineConstant{SIGABRT}
@MmuxDefineConstant{SIGIOT}
@MmuxDefineConstant{SIGTRAP}
@MmuxDefineConstant{SIGEMT}
@MmuxDefineConstant{SIGSYS}
@MmuxDefineConstant{SIGTERM}
@MmuxDefineConstant{SIGINT}
@MmuxDefineConstant{SIGQUIT}
@MmuxDefineConstant{SIGKILL}
@MmuxDefineConstant{SIGHUP}
@MmuxDefineConstant{SIGALRM}
@MmuxDefineConstant{SIGVRALRM}
@MmuxDefineConstant{SIGPROF}
@MmuxDefineConstant{SIGIO}
@MmuxDefineConstant{SIGURG}
@MmuxDefineConstant{SIGPOLL}
@MmuxDefineConstant{SIGCHLD}
@MmuxDefineConstant{SIGCLD}
@MmuxDefineConstant{SIGCONT}
@MmuxDefineConstant{SIGSTOP}
@MmuxDefineConstant{SIGTSTP}
@MmuxDefineConstant{SIGTTIN}
@MmuxDefineConstant{SIGTTOU}
@MmuxDefineConstant{SIGPIPE}
@MmuxDefineConstant{SIGLOST}
@MmuxDefineConstant{SIGXCPU}
@MmuxDefineConstant{SIGXSFZ}
@MmuxDefineConstant{SIGUSR1}
@MmuxDefineConstant{SIGUSR2}
@MmuxDefineConstant{SIGWINCH}
@MmuxDefineConstant{SIGINFO}

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {mmux_asciizcp_t} mmux_cc_libc_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_libc_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_libc_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun mmux_sint_t mmux_cc_libc_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun


@deftypevr {Struct Pointer} {mmux_libc_interface_specification_t const *} mmux_libc_interface_specification
Interface specification for @value{PACKAGE}, @ref{interface specifications} for details.
@end deftypevr

@c page
@node initialisation
@chapter Library initialisation


@deftypefun bool mmux_cc_libc_init (void)
Initialise library's internal state; we can safely call this function multimple times.  When
successful return @cfalse{}; otherwise return @ctrue{}.
@end deftypefun

@c page
@node errors
@chapter Errors management


@cindex @code{errno} variable
@cindex Variacle @code{errno}
@cindex Error handling
@cindex Handling errors


@deftp {Struct Typedef} mmux_libc_errno_t
Data structure type representing the constants of @code{errno}.  All the known standard constants
like @samp{EINVAL} are available as preprocessor symbols like @samp{MMUX_LIBC_EINVAL}, which expand
to an expression evaluating to an instance of this data type.
@end deftp


@deftypefun bool mmux_libc_errno_equal (mmux_libc_errno_t @vari{errnum}, mmux_libc_errno_t @varii{errnum})
Return @ctrue{} if @vari{errnum} equal @varii{errnum}, otherwise return @cfalse{}.

@example
mmux_libc_errno_t       errnum;

mmux_libc_errno_consume(&errno);
if (mmux_libc_errno_equal(MMUX_LIBC_EINVAL, errno)) @{
  ...
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_errno_set (mmux_libc_errno_t @var{errnum})
Setter for the standard @code{errno} variable.  The return value is always @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_errno_ref (mmux_libc_errno_t * @var{result_errnum_p})
Getter for the standard @code{errno} variable: always store the current value of @code{errno} in the
location referenced by @var{result_errnum_p}.  When @code{errno} is zero: the return value is
@ctrue{}, there is no reason to query @code{errno}; otherwise it is @cfalse{}.

@example
mmux_libc_errno_t     errnum;

if (mmux_libc_errno_ref(&errnum)) @{
  ... /* there was no error: why are we querying "errno"? */
@} else @{
  mmux_asciizcp_t       errmsg;

  mmux_libc_strerror(&errmsg, errnum);
  ... /* handle the error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_errno_clear (void)
Set @code{errno} to zero.  Always return @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_errno_consume (mmux_libc_errno_t * @var{result_errnum_p})
Getter--and--resetter for the standard @code{errno} variable: always store the current value of
@code{errno} in the location referenced by @var{result_errnum_p}, then reset @code{errno} to zero.
Upon calling this function, when @code{errno} is zero: the return value is @ctrue{}, there is no
reason to query @code{errno}; otherwise it is @cfalse{}.

@example
mmux_libc_errno_t     errnum;

if (mmux_libc_errno_consume(&errnum)) @{
  ... /* there was no error: why are we querying "errno"? */
@} else @{
  mmux_asciizcp_t       errmsg;

  mmux_libc_strerror(&errmsg, errnum);
  ... /* handle the error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strerror (mmux_asciizcp_t * @var{result_error_message_p}, mmux_libc_errno_t @var{errnum})
@MmuxCInterface{strerror}.  The return value is always @cfalse{}.

Often we want to compose strings using a memory--mapped file descriptor, so we call
@cfunc{mmux_libc_memfd_strerror} instead of this function, @ref{mmux_libc_memfd_strerror} for details.

Otherwise we may want to call @cfunc{mmux_libc_dprintf_strerror}; @ref{mmux_libc_dprintf_strerror}
for details.
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_strerror_r (mmux_asciizcpp_t @var{result_p}, mmux_asciizp_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_libc_errno_t @var{errnum})
@MmuxCInterface{strerror_r}.  This is the @gnu{} variant of this function.

We must use the arguments @var{bufptr} and @var{buflen} to provide a buffer in which the string
could be written: it is up to @cfunc{strerror_r} to use it or not.  If the call is successful: we
just use the pointer stored in the variable referenced by @var{result_p}.  A @var{buflen} of
@samp{1024} should be enough to hold any string.

@example
mmux_asciizcp_t         result;
mmux_usize_t            buflen = 1024;
mmux_char_t             bufptr[buflen];

if (mmux_libc_strerror_r(&result, bufptr, buflen, MMUX_LIBC_EINVAL)) @{
  /* error */
@}

if (mmux_libc_dprintfer("strerror_r result: %s\n", result)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_strerrorname_np (mmux_asciizcpp_t result_p, mmux_libc_errno_t errnum)
@MmuxCInterface{strerrorname_np}.  This is the @gnu{} variant of this function.

The following code example should print @samp{EINVAL}:

@example
mmux_asciizcp_t result;

if (mmux_libc_strerrorname_np(&result, MMUX_LIBC_EINVAL)) @{
  /* error */
@}

if (mmux_libc_dprintfer("strerrorname_np result: %s", result)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_strerrordesc_np (mmux_asciizcpp_t result_p, mmux_libc_errno_t errnum)
@MmuxCInterface{strerrordesc_np}.  This is the @gnu{} variant of this function.

The following code example should print @samp{Invalid argument}:

@example
mmux_asciizcp_t result;

if (mmux_libc_strerrordesc_np(&result, MMUX_LIBC_EINVAL)) @{
  /* error */
@}

if (mmux_libc_dprintfer("strerrordesc_np result: %s", result)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_program_invocation_name (mmux_asciizcpp_t @var{result_p})
Store in the variable referenced by @var{result_p} a pointer to the @gnu{} C Library global variable
@code{program_invocation_name}.  @glibcref{Error Messages, Error Messages}.
@end deftypefn


@deftypefn {@gnu{} Function} bool mmux_libc_program_invocation_short_name (mmux_asciizcpp_t @var{result_p})
Store in the variable referenced by @var{result_p} a pointer to the @gnu{} C Library global variable
@code{program_invocation_short_name}.  @glibcref{Error Messages, Error Messages}.
@end deftypefn

@c ------------------------------------------------------------------------

@macro MmuxLibcDefineErrnoConstant{NAME}
@deftypevr {Constant} mmux_libc_errno_t MMUX_LIBC_\NAME\
@deftypevrx {Preprocessor Symbol} int MMUX_LIBC_VALUEOF_\NAME\
@deftypevrx {Preprocessor Symbol} int MMUX_HAVE_LIBC_\NAME\
Error code @code{\NAME\}.
@end deftypevr

@end macro


@MmuxLibcDefineErrnoConstant{EPERM}
@MmuxLibcDefineErrnoConstant{ENOENT}
@MmuxLibcDefineErrnoConstant{ESRCH}
@MmuxLibcDefineErrnoConstant{EINTR}
@MmuxLibcDefineErrnoConstant{EIO}
@MmuxLibcDefineErrnoConstant{ENXIO}
@MmuxLibcDefineErrnoConstant{E2BIG}
@MmuxLibcDefineErrnoConstant{ENOEXEC}
@MmuxLibcDefineErrnoConstant{EBADF}
@MmuxLibcDefineErrnoConstant{ECHILD}
@MmuxLibcDefineErrnoConstant{EAGAIN}
@MmuxLibcDefineErrnoConstant{ENOMEM}
@MmuxLibcDefineErrnoConstant{EACCES}
@MmuxLibcDefineErrnoConstant{EFAULT}
@MmuxLibcDefineErrnoConstant{ENOTBLK}
@MmuxLibcDefineErrnoConstant{EBUSY}
@MmuxLibcDefineErrnoConstant{EEXIST}
@MmuxLibcDefineErrnoConstant{EXDEV}
@MmuxLibcDefineErrnoConstant{ENODEV}
@MmuxLibcDefineErrnoConstant{ENOTDIR}
@MmuxLibcDefineErrnoConstant{EISDIR}
@MmuxLibcDefineErrnoConstant{EINVAL}
@MmuxLibcDefineErrnoConstant{ENFILE}
@MmuxLibcDefineErrnoConstant{EMFILE}
@MmuxLibcDefineErrnoConstant{ENOTTY}
@MmuxLibcDefineErrnoConstant{ETXTBSY}
@MmuxLibcDefineErrnoConstant{EFBIG}
@MmuxLibcDefineErrnoConstant{ENOSPC}
@MmuxLibcDefineErrnoConstant{ESPIPE}
@MmuxLibcDefineErrnoConstant{EROFS}
@MmuxLibcDefineErrnoConstant{EMLINK}
@MmuxLibcDefineErrnoConstant{EPIPE}
@MmuxLibcDefineErrnoConstant{EDOM}
@MmuxLibcDefineErrnoConstant{ERANGE}
@MmuxLibcDefineErrnoConstant{EDEADLK}
@MmuxLibcDefineErrnoConstant{ENAMETOOLONG}
@MmuxLibcDefineErrnoConstant{ENOLCK}
@MmuxLibcDefineErrnoConstant{ENOSYS}
@MmuxLibcDefineErrnoConstant{ENOTEMPTY}
@MmuxLibcDefineErrnoConstant{ELOOP}
@MmuxLibcDefineErrnoConstant{EWOULDBLOCK}
@MmuxLibcDefineErrnoConstant{ENOMSG}
@MmuxLibcDefineErrnoConstant{EIDRM}
@MmuxLibcDefineErrnoConstant{ECHRNG}
@MmuxLibcDefineErrnoConstant{EL2NSYNC}
@MmuxLibcDefineErrnoConstant{EL3HLT}
@MmuxLibcDefineErrnoConstant{EL3RST}
@MmuxLibcDefineErrnoConstant{ELNRNG}
@MmuxLibcDefineErrnoConstant{EUNATCH}
@MmuxLibcDefineErrnoConstant{ENOCSI}
@MmuxLibcDefineErrnoConstant{EL2HLT}
@MmuxLibcDefineErrnoConstant{EBADE}
@MmuxLibcDefineErrnoConstant{EBADR}
@MmuxLibcDefineErrnoConstant{EXFULL}
@MmuxLibcDefineErrnoConstant{ENOANO}
@MmuxLibcDefineErrnoConstant{EBADRQC}
@MmuxLibcDefineErrnoConstant{EBADSLT}
@MmuxLibcDefineErrnoConstant{EDEADLOCK}
@MmuxLibcDefineErrnoConstant{EBFONT}
@MmuxLibcDefineErrnoConstant{ENOSTR}
@MmuxLibcDefineErrnoConstant{ENODATA}
@MmuxLibcDefineErrnoConstant{ETIME}
@MmuxLibcDefineErrnoConstant{ENOSR}
@MmuxLibcDefineErrnoConstant{ENONET}
@MmuxLibcDefineErrnoConstant{ENOPKG}
@MmuxLibcDefineErrnoConstant{EREMOTE}
@MmuxLibcDefineErrnoConstant{ENOLINK}
@MmuxLibcDefineErrnoConstant{EADV}
@MmuxLibcDefineErrnoConstant{ESRMNT}
@MmuxLibcDefineErrnoConstant{ECOMM}
@MmuxLibcDefineErrnoConstant{EPROTO}
@MmuxLibcDefineErrnoConstant{EMULTIHOP}
@MmuxLibcDefineErrnoConstant{EDOTDOT}
@MmuxLibcDefineErrnoConstant{EBADMSG}
@MmuxLibcDefineErrnoConstant{EOVERFLOW}
@MmuxLibcDefineErrnoConstant{ENOTUNIQ}
@MmuxLibcDefineErrnoConstant{EBADFD}
@MmuxLibcDefineErrnoConstant{EREMCHG}
@MmuxLibcDefineErrnoConstant{ELIBACC}
@MmuxLibcDefineErrnoConstant{ELIBBAD}
@MmuxLibcDefineErrnoConstant{ELIBSCN}
@MmuxLibcDefineErrnoConstant{ELIBMAX}
@MmuxLibcDefineErrnoConstant{ELIBEXEC}
@MmuxLibcDefineErrnoConstant{EILSEQ}
@MmuxLibcDefineErrnoConstant{ERESTART}
@MmuxLibcDefineErrnoConstant{ESTRPIPE}
@MmuxLibcDefineErrnoConstant{EUSERS}
@MmuxLibcDefineErrnoConstant{ENOTSOCK}
@MmuxLibcDefineErrnoConstant{EDESTADDRREQ}
@MmuxLibcDefineErrnoConstant{EMSGSIZE}
@MmuxLibcDefineErrnoConstant{EPROTOTYPE}
@MmuxLibcDefineErrnoConstant{ENOPROTOOPT}
@MmuxLibcDefineErrnoConstant{EPROTONOSUPPORT}
@MmuxLibcDefineErrnoConstant{ESOCKTNOSUPPORT}
@MmuxLibcDefineErrnoConstant{EOPNOTSUPP}
@MmuxLibcDefineErrnoConstant{EPFNOSUPPORT}
@MmuxLibcDefineErrnoConstant{EAFNOSUPPORT}
@MmuxLibcDefineErrnoConstant{EADDRINUSE}
@MmuxLibcDefineErrnoConstant{EADDRNOTAVAIL}
@MmuxLibcDefineErrnoConstant{ENETDOWN}
@MmuxLibcDefineErrnoConstant{ENETUNREACH}
@MmuxLibcDefineErrnoConstant{ENETRESET}
@MmuxLibcDefineErrnoConstant{ECONNABORTED}
@MmuxLibcDefineErrnoConstant{ECONNRESET}
@MmuxLibcDefineErrnoConstant{ENOBUFS}
@MmuxLibcDefineErrnoConstant{EISCONN}
@MmuxLibcDefineErrnoConstant{ENOTCONN}
@MmuxLibcDefineErrnoConstant{ESHUTDOWN}
@MmuxLibcDefineErrnoConstant{ETOOMANYREFS}
@MmuxLibcDefineErrnoConstant{ETIMEDOUT}
@MmuxLibcDefineErrnoConstant{ECONNREFUSED}
@MmuxLibcDefineErrnoConstant{EHOSTDOWN}
@MmuxLibcDefineErrnoConstant{EHOSTUNREACH}
@MmuxLibcDefineErrnoConstant{EALREADY}
@MmuxLibcDefineErrnoConstant{EINPROGRESS}
@MmuxLibcDefineErrnoConstant{ESTALE}
@MmuxLibcDefineErrnoConstant{EUCLEAN}
@MmuxLibcDefineErrnoConstant{ENOTNAM}
@MmuxLibcDefineErrnoConstant{ENAVAIL}
@MmuxLibcDefineErrnoConstant{EISNAM}
@MmuxLibcDefineErrnoConstant{EREMOTEIO}
@MmuxLibcDefineErrnoConstant{EDQUOT}
@MmuxLibcDefineErrnoConstant{ENOMEDIUM}
@MmuxLibcDefineErrnoConstant{EMEDIUMTYPE}
@MmuxLibcDefineErrnoConstant{ECANCELED}
@MmuxLibcDefineErrnoConstant{ENOKEY}
@MmuxLibcDefineErrnoConstant{EKEYEXPIRED}
@MmuxLibcDefineErrnoConstant{EKEYREVOKED}
@MmuxLibcDefineErrnoConstant{EKEYREJECTED}
@MmuxLibcDefineErrnoConstant{EOWNERDEAD}
@MmuxLibcDefineErrnoConstant{ENOTRECOVERABLE}

@c page
@node memory
@chapter Memory management


@menu
* memory core::                 Core memory allocation operations.
* memory operations::           Memory operations.
* memory allocators::           Memory allocator.
@end menu

@c page
@node memory core
@section Core memory allocation operations


Among the following operations: those that allocate or reallocate a block of memory have a result
argument @code{mmux_pointer_t * @var{result_p}}; all of them have both a function and a macro, the
latter just casts a pointer @var{result_p} of any type to @code{mmux_pointer_t *}.


@deftypefn {Preprocessor Macro} bool mmux_libc_malloc (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{len})
@deftypefnx {Function} bool mmux_libc_malloc_ (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{len})
@MmuxCInterface{malloc}.  Upon successful return: the pointer variable referenced by @var{result_p}
is set to the pointer referencing the newly allocated memory block.

@example
auto                     nbytes = mmux_usize_literal(213);
mmux_standard_octet_t *  ptr;

if (mmux_libc_malloc(&ptr, nbytes)) @{
  /* error */
@} else @{
  ...
  mmux_libc_free(ptr);
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_calloc (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx Function bool mmux_libc_calloc_ (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@MmuxCInterface{calloc}.  Upon successful return: the pointer variable referenced by @var{result_p}
is set to the pointer referencing the newly allocated memory block.

@example
@{
  auto                     item_num = mmux_usize_literal(12);
  auto                     item_len = mmux_usize_literal(34);
  mmux_standard_octet_t *  ptr;

  if (mmux_libc_calloc(&ptr, item_num, item_len)) @{
    /* error */
  @} else @{
    ...
    mmux_libc_free(ptr);
  @}
@}

@{
  auto                 item_num = mmux_usize_literal(12);
  auto                 item_len = mmux_flonumd128_sizeof();
  mmux_flonumd128_t *  ptr;

  if (mmux_libc_calloc(&ptr, item_num, item_len)) @{
    /* error */
  @} else @{
    for (auto i = mmux_usize_constant_zero();
         mmux_ctype_less(i, item_num);
         mmux_ctype_incr_variable(i)) @{
      ptr[i.value] = mmux_flonumd128(i.value);
    @}
    mmux_libc_free(ptr);
  @}
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_realloc (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{newlen})
@deftypefnx Function bool mmux_libc_realloc_ (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{newlen})
@MmuxCInterface{realloc}.

@itemize
@item
Upon calling this function: @var{result_p} must reference a pointer variable holding the pointer to the
memory block to reallocate.

@item
Upon successfully returning from this function: the pointer variable referenced by @var{result_p} holds
the new pointer.
@end itemize

@example
auto                     nbytes1 = mmux_usize_literal(56);
auto                     nbytes2 = mmux_usize_literal(89);
mmux_standard_octet_t *  ptr;

if (mmux_libc_malloc(&ptr, nbytes1)) @{
  /* error */
@}
...
if (mmux_libc_realloc(&ptr, nbytes2)) @{
  /* error */
@}
...
mmux_libc_free(ptr);
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_reallocarray (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx Function bool mmux_libc_reallocarray_ (mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@MmuxCInterface{reallocarray}.  Upon successful return: the pointer variable referenced by
@var{result_p} is set to the pointer referencing the newly allocated memory block.

@example
auto                item_num1 = mmux_usize_literal(12);
auto                item_num2 = mmux_usize_literal(34);
auto                item_len  = mmux_flonumd128_sizeof();
mmux_flonumd128_t * ptr;

if (mmux_libc_calloc(&ptr, item_num1, item_len)) @{
  /* error */
@}
...
if (mmux_libc_reallocarray(&ptr, item_num2, item_len)) @{
  /* error */
@}
...
mmux_libc_free(ptr);
@end example
@end deftypefn


@deftypefun bool mmux_libc_free (mmux_pointer_t @var{P})
@MmuxCInterface{free}.
@end deftypefun


@deftypefn {Preprocessor Macro} bool mmux_libc_malloc_and_copy (mmux_pointer_t * @var{dstptr_p}, mmux_pointer_t @var{srcptr}, mmux_usize_t @var{srclen})
@deftypefnx {Function} bool mmux_libc_malloc_and_copy_ (mmux_pointer_t * @var{dstptr_p}, mmux_pointer_t @var{srcptr}, mmux_usize_t @var{srclen})
Allocate @var{srclen} bytes using @cfunc{mmux_libc_malloc}; then copy @var{srclen} bytes from
@var{srcptr} to the newly allocated memory block; finally store the resulting pointer in the
variable referenced by @var{result_p}.

To copy bytes from a buffer we do:

@example
auto                      buflen = mmux_usize_literal(12);
mmux_standard_byte_t      srcbuf[buflen.value];
mmux_standard_byte_t *    dstbuf;

for (mmux_standard_usize_t i=0; i<buflen.value; ++i) @{
  srcbuf[i] = ...;
@}
if (mmux_libc_malloc_and_copy(&dstbuf, srcbuf, buflen)) @{
  /* error */
@}
for (mmux_standard_usize_t i=0; i<buflen.value; ++i) @{
  do_something_with(dstbuf[i]);
@}
mmux_libc_free(dstbuf);
@end example

To copy an @asciiz{} string we do:

@example
mmux_standard_char_t *    srcbuf = "the colour of water";
mmux_standard_char_t *    dstbuf;
mmux_usize_t              buflen;

mmux_libc_strlen_plus_nil(&buflen, srcbuf);
if (mmux_libc_malloc_and_copy(&dstbuf, srcbuf, buflen)) @{
  /* error */
@}
if (mmux_libc_dprintfer("@{%s@}\n", dstbuf)) @{
  /* error */
@}
mmux_libc_free(dstbuf);
@end example
@end deftypefn

@c page
@node memory operations
@section Memory operations


@deftypefun bool mmux_libc_memset (mmux_pointer_t @var{ptr}, mmux_octett @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memset}.

@example
auto                    value  = mmux_octet(13);
auto                    buflen = mmux_usize_literal(5);
mmux_standard_octet_t   bufptr[buflen.value];

mmux_libc_memset(bufptr, value, buflen);
@end example
@end deftypefun


@deftypefun bool mmux_libc_memzero (mmux_pointer_t @var{ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memzero}.

@example
auto                   buflen = mmux_usize_literal(5);
mmux_standard_octet_t  bufptr[buflen.value];

mmux_libc_memzero(bufptr, buflen);
@end example
@end deftypefun


@deftypefun bool mmux_libc_memcpy (mmux_pointer_t @var{dst_ptr}, mmux_pointerc_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memcpy}.

@example
auto                   buflen = mmux_usize_literal(5);
mmux_standard_octet_t  srcptr[buflen.value];
mmux_standard_octet_t  dstptr[buflen.value];

...
mmux_libc_memcpy(dstptr, srcptr, buflen);
@end example
@end deftypefun


@deftypefn {Preprocessor Macro} bool mmux_libc_mempcpy (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@deftypefnx {@gnu{} Function} bool mmux_libc_mempcpy_ (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{mempcpy}.

@example
@{
  auto                     buflen = mmux_usize_literal(5);
  mmux_standard_octet_t    srcptr[buflen.value];
  mmux_standard_octet_t    dstptr[buflen.value];
  mmux_standard_octet_t *  nxtptr;

  ...
  mmux_libc_mempcpy(&nxtptr, dstptr, srcptr, buflen);
  assert((mmux_standard_usize_t)(nxtptr - dstptr) == buflen.value);
@}

@{
  mmux_standard_char_t *    srcptr = "the colour of water";
  mmux_usize_t              buflen;

  mmux_libc_strlen(&buflen, srcptr);
  @{
    mmux_standard_char_t    dstptr[buflen.value];
    mmux_standard_char_t *  nxtptr;

    mmux_libc_mempcpy(&nxtptr, dstptr, srcptr, buflen);
    assert( (mmux_standard_usize_t)(nxtptr - dstptr) == buflen.value);
  @}
@}
@end example
@end deftypefn


@deftypefn {Preprocssor Macro} bool mmux_libc_memccpy (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_uint8_t @var{octet}, mmux_usize_t @var{nbytes})
@deftypefnx {Function} bool mmux_libc_memccpy_ (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_uint8_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memccpy}.

@example
@{
  auto                      it     = mmux_octet(3);
  auto                      buflen = mmux_usize_literal(5);
  mmux_standard_octet_t     srcptr[buflen.value];
  mmux_standard_octet_t     dstptr[buflen.value];
  mmux_standard_octet_t *   nxtptr;

  ...
  mmux_libc_memccpy(&nxtptr, dstptr, srcptr, it, buflen);
@}

@{
  mmux_standard_char_t *    srcptr = "the colour of water";
  mmux_usize_t              buflen;

  mmux_libc_strlen(&buflen, srcptr);
  @{
    auto                    it = mmux_octet('w');
    mmux_standard_char_t    dstptr[buflen.value];
    mmux_standard_char_t *  nxtptr;

    mmux_libc_memccpy(&nxtptr, dstptr, srcptr, it, buflen);
  @}
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_memmove (mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memmove}.

@example
@{
  auto                   buflen = mmux_usize_literal(5);
  mmux_standard_octet_t  srcptr[buflen.value];
  mmux_standard_octet_t  dstptr[buflen.value];

  ...
  mmux_libc_memmove(dstptr, srcptr, buflen);
@}

@{
  mmux_standard_char_t *  srcptr = "the colour of water";
  mmux_usize_t            buflen;

  mmux_libc_strlen_plus_nil(&buflen, srcptr);
  @{
    mmux_standard_char_t  dstptr[buflen.value];

    mmux_libc_memmove(dstptr, srcptr, buflen);
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_memcmp (mmux_sint_t * @var{result_p}, mmux_pointerc_t @vari{ptr}, mmux_pointerc_t @varii{ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memcmp}.

@example
@{
  auto                   buflen = mmux_usize_literal(5);
  mmux_standard_octet_t  bufptr1[buflen.value];
  mmux_standard_octet_t  bufptr2[buflen.value];
  mmux_sint_t            ternary_result;

  ...
  mmux_libc_memcmp(&ternary_result, bufptr1, bufptr2, buflen);
  examine_the_value_of(ternary_result);
@}

@{
  mmux_standard_char_t *  bufptr1 = "the colour of water";
  mmux_standard_char_t *  bufptr2 = "the colour of water and quicksilver";
  mmux_usize_t            buflen;
  mmux_sint_t             ternary_result;

  mmux_libc_strlen(&buflen, bufptr1);
  mmux_libc_memcmp(&ternary_result, bufptr1, bufptr2, buflen);
  assert(mmux_ctype_is_zero(ternary_result));
@}
@end example
@end deftypefun


@deftypefn {Preprocessor Macro} bool mmux_libc_memchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@deftypefnx {Function} bool mmux_libc_memchr_ (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memchr}.

@example
@{
  auto                        it     = mmux_octet(3);
  auto                        buflen = mmux_usize_literal(5);
  mmux_standard_octet_t       bufptr[buflen.value];
  mmux_standard_octet_t *     result;

  ...
  mmux_libc_memchr(&result, bufptr, it, buflen);
  do_something_with(result);
@}

@{
  //                                    01234567890123456789
  mmux_standard_char_t *      bufptr = "the colour of water";
  mmux_usize_t                buflen;
  auto                        it     = mmux_octet('w');
  mmux_standard_char_t *      result;

  mmux_libc_strlen(&buflen, bufptr);
  mmux_libc_memchr(&result, bufptr, it, buflen);
  assert( (mmux_standard_usize_t)(result - bufptr) == 14 );
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_rawmemchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet})
@deftypefnx {@gnu{} Function} bool mmux_libc_rawmemchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet})
@MmuxCInterface{rawmemchr}.

@example
@{
  auto                        it     = mmux_octet(3);
  auto                        buflen = mmux_usize_literal(5);
  mmux_standard_octet_t       bufptr[buflen.value];
  mmux_standard_octet_t *     result;

  ...
  mmux_libc_rawmemchr(&result, bufptr, it);
  assert( (mmux_standard_usize_t)(result - bufptr) == 3);
@}

@{
  //                                    01234567890123456789
  mmux_standard_char_t *      bufptr = "the colour of water";
  auto                        it     = mmux_octet('w');
  mmux_standard_char_t *      result;

  mmux_libc_rawmemchr(&result, bufptr, it);
  assert( (mmux_standard_usize_t)(result - bufptr) == 14);
@}

/* Find the terminating nil character. */
@{
  //                                    01234567890123456789
  mmux_standard_char_t *      bufptr = "the colour of water";
  auto                        it     = mmux_octet_constant_zero();
  mmux_standard_char_t *      result;

  mmux_libc_rawmemchr(&result, bufptr, it);
  assert( (mmux_standard_usize_t)(result - bufptr) == 19);
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_memrchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@deftypefnx {Function} bool mmux_libc_memrchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memrchr}.

@example
@{
  auto                        it     = mmux_octet(3);
  auto                        buflen = mmux_usize_literal(5);
  mmux_standard_octet_t       bufptr[buflen.value];
  mmux_standard_octet_t *     result;

  ...
  mmux_libc_memrchr(&result, bufptr, it, buflen);
  do_something_with(result);
@}

@{
  //                                    01234567890123456789
  mmux_standard_char_t *      bufptr = "the colour of water";
  mmux_usize_t                buflen;
  auto                        it     = mmux_octet('o');
  mmux_standard_char_t *      result;

  mmux_libc_strlen(&buflen, bufptr);
  mmux_libc_memrchr(&result, bufptr, it, buflen);
  assert( NULL != result );
  assert( (mmux_standard_usize_t)(result - bufptr) == 11);
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_memmem (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{haystack_ptr}, mmux_usize_t @var{haystack_len}, mmux_pointer_t @var{needle_ptr}, mmux_usize_t @var{needle_len})
@deftypefnx {Function} bool mmux_libc_memmem (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{haystack_ptr}, mmux_usize_t @var{haystack_len}, mmux_pointer_t @var{needle_ptr}, mmux_usize_t @var{needle_len})
@MmuxCInterface{memmem}.

@example
@{
  auto                        haystack_len = mmux_usize_literal(11);
  mmux_standard_octet_t       haystack_ptr[haystack_len.value];
  auto                        needle_len = mmux_usize_literal(3);
  mmux_standard_octet_t       needle_ptr[] = @{ 3, 4, 5 @};
  mmux_standard_octet_t *     result;

  for (mmux_standard_usize_t i=0; i<buflen.value; ++i) @{
    bufptr[i] = (mmux_standard_octet_t) i;
  @}
  mmux_libc_memmem(&result,
                   haystack_ptr, haystack_len,
                   needle_ptr, needle_len);
  assert( NULL != result );
  assert( (mmux_standard_usize_t)(result - haystack_ptr) == 3);
@}

@{
  //                                          01234567890123456789
  mmux_standard_char_t *      haystack_ptr = "the colour of water";
  mmux_standard_char_t *      needle_ptr   = "colour";
  mmux_usize_t                haystack_len;
  mmux_usize_t                needle_len;
  mmux_standard_char_t *      result;

  mmux_libc_strlen(&haystack_len, haystack_ptr);
  mmux_libc_strlen(&needle_len,   needle_ptr);
  mmux_libc_memmem(&result,
                   haystack_ptr, haystack_len,
                   needle_ptr, needle_len);
  assert( NULL != result );
  assert( (mmux_standard_usize_t)(result - haystack_ptr) == 4);
@}
@end example
@end deftypefn

@c page
@node memory allocators
@section Memory allocators


It is often useful to define special memory allocators for specific data types or for data that we
know is short--lived or long--lived; the following definitions represent the memory allocator
defined by @value{PACKAGE}.

To allocate and release a memory block using the default memory allocator we do:

@example
mmux_libc_mall_t  AP;
mmux_pointer_t    bufptr;
auto              buflen = mmux_usize_literal(4096);

mmux_libc_default_memory_allocator_ref(&AP);

if (mmux_libc_memory_allocator_malloc(AP, &bufptr, buflen)) @{
  /* error */
@} else @{
  ...
  if (mmux_libc_memory_allocator_free(AP, bufptr)) @{
    /* error */
  @}
@}
@end example

Memory allocators implement the core operations @code{malloc}, @code{calloc}, @code{realloc},
@code{reallocarray}, @code{malloc_and_copy}, @code{free}.

@menu
* memory allocators types::     Memory allocator type definitions.
* memory allocators api::       Memory allocator programming interface.
* memory allocators default::   Default memory allocator.
* memory allocators fake::      Fake memory allocator.
* memory allocators example::   How to implement a memory allocator.
@end menu

@c page
@node memory allocators types
@subsection Memory allocator type definitions


@deftp {Struct Typedef} mmux_libc_memory_allocator_t
@deftpx {Struct Pointer Typedef} mmux_libc_mall_t
Data structure representing a memory allocator.  It has the following fields:

@table @code
@item mmux_libc_memory_allocator_value_t * const value
Pointer to an instance of @objtype{mmux_libc_memory_allocator_value_t}.

@item mmux_libc_memory_allocator_class_t const * const class
Pointer to an instance of @objtype{mmux_libc_memory_allocator_class_t} representing the class of
this memory allocator.
@end table

The type @objtype{mmux_libc_mall_t} is an alias for @code{mmux_libc_memory_allocator_t const *} and
we can use it as type for the argument to functions that reference a memory allocator.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Struct Typedef} mmux_libc_memory_allocator_value_t
Data structure representing the value of the memory allocator.  It has the following fields:

@table @code
@item mmux_pointer_t data
A pointer to be used for custom data.
@end table
@end deftp

@c ------------------------------------------------------------------------

@deftp {Struct Typedef} mmux_libc_memory_allocator_class_t
Data structure type representing the table of allocator--specific functions.  It has the following
fields:

@table @code
@item mmux_libc_memory_allocator_malloc_fun_t * const malloc
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_malloc}.

@item mmux_libc_memory_allocator_calloc_fun_t * const calloc
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_calloc}.

@item mmux_libc_memory_allocator_realloc_fun_t * const realloc
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_realloc}.

@item mmux_libc_memory_allocator_reallocarray_fun_t * const reallocarray
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_reallocarray}.

@item mmux_libc_memory_allocator_free_fun_t * const free
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_free}.

@item mmux_libc_default_memory_allocator_malloc_and_copy * const malloc_and_copy
Pointer to the allocator--specific function that behaves like @cfunc{mmux_libc_malloc_and_copy}.
@end table

If, for some reason, a custom memory allocator does not implement one or more of these operations:
we should just define the corresponding functions to always set @code{errno} to
@samp{MMUX_LIBC_ENOSYS} and always return @ctrue{}.
@end deftp

@c ------------------------------------------------------------------------

@deftypefn {Function Type} bool mmux_libc_memory_allocator_malloc_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{len})
Allocator--specific function that behaves like @cfunc{mmux_libc_malloc}.
@end deftypefn


@deftypefn {Function Type} bool mmux_libc_memory_allocator_calloc_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
Allocator--specific function that behaves like @cfunc{mmux_libc_calloc}.
@end deftypefn


@deftypefn {Function Type} bool mmux_libc_memory_allocator_realloc_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{newlen})
Allocator--specific function that behaves like @cfunc{mmux_libc_realloc}.
@end deftypefn


@deftypefn {Function Type} bool mmux_libc_memory_allocator_reallocarray_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
Allocator--specific function that behaves like @cfunc{mmux_libc_reallocarray}.
@end deftypefn


@deftypefn {Function Type} bool mmux_libc_memory_allocator_free_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t @var{p})
Allocator--specific function that behaves like @cfunc{mmux_libc_free}.
@end deftypefn


@deftypefn {Function Type} bool mmux_libc_memory_allocator_malloc_and_copy_fun_t (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{dstptr_p}, mmux_pointer_t @var{srcptr}, mmux_usize_t @var{srclen})
Allocator--specific function that behaves like @cfunc{mmux_libc_malloc_and_copy}.
@end deftypefn

@c page
@node memory allocators api
@subsection Memory allocator programming interface


To allocate and release a memory block using the default memory allocator we do:

@example
mmux_libc_mall_t  AP;
mmux_pointer_t    bufptr;
auto              buflen = mmux_usize_literal(4096);

mmux_libc_default_memory_allocator_ref(&AP);

if (mmux_libc_memory_allocator_malloc(AP, &bufptr, buflen)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, bufptr)) @{
  /* error */
@}
@end example

@noindent
while the standard @cfunc{free} function and its wrapper @cfunc{mmux_libc_free} will never return an
error condition: the same cannot be said for custom memory allocators; so it is better to test the
return value of @cfunc{mmux_libc_memory_allocator_free}.

For all the following definitions: the macro just casts a pointer @var{result_p} of any type to
@code{mmux_pointer_t *}.

@deftypefn {Preprocessor Macro} bool mmux_libc_memory_allocator_malloc (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{len})
@deftypefnx Function bool mmux_libc_memory_allocator_malloc_ (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{len})
Call the function of the given memory allocator.
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_memory_allocator_calloc (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx {Function} bool mmux_libc_memory_allocator_calloc_ (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
Call the function of the given memory allocator.

@example
mmux_libc_mall_t  AP;
mmux_pointer_t    items_ptr;
auto              item_num = mmux_usize(123);
auto              item_len = mmux_usize(4096);

mmux_libc_default_memory_allocator_ref(&AP);

if (mmux_libc_memory_allocator_calloc(AP, &items_ptr, item_num, item_len)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, items_ptr)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_memory_allocator_realloc (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{newlen})
@deftypefnx {Function} bool mmux_libc_memory_allocator_realloc_ (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{newlen})
Call the function of the given memory allocator.

@example
mmux_libc_mall_t  AP;
mmux_pointer_t    bufptr;
auto              buflen = mmux_usize(4096);
auto              newlen = mmux_usize(2 * 4096);

mmux_libc_default_memory_allocator_ref(&AP);

if (mmux_libc_memory_allocator_malloc(AP, &bufptr, buflen)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_realloc(AP, &bufptr, newlen)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, bufptr)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_memory_allocator_reallocarray (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx {Function} bool mmux_libc_memory_allocator_reallocarray_ (mmux_libc_mall_t @var{allocp}, mmux_pointer_t * @var{result_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
Call the function of the given memory allocator.

@example
mmux_libc_mall_t  AP;
mmux_pointer_t    items_ptr;
auto              item_num  = mmux_usize(123);
auto              item_len  = mmux_usize(4096);
auto              item_num2 = mmux_usize(2 * 123);

mmux_libc_default_memory_allocator_ref(&AP);

if (mmux_libc_memory_allocator_calloc(AP, &items_ptr, item_num, item_len)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_reallocarray(AP, &items_ptr, item_num2, item_len)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, bufptr)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_memory_allocator_free (mmux_libc_mall_t @var{allocp}, mmux_pointer_t @var{p})
Call the function of the given memory allocator.
@end deftypefun


@deftypefn {Preprocessor Macro} bool mmux_libc_memory_allocator_malloc_and_copy (mmux_libc_mall_t @var{allocator}, mmux_pointer_t * @var{dstptr_p}, mmux_pointer_t @var{srcptr}, mmux_usize_t @var{srclen})
@deftypefnx {Function} bool mmux_libc_memory_allocator_malloc_and_copy_ (mmux_libc_mall_t @var{allocator}, mmux_pointer_t * @var{dstptr_p}, mmux_pointer_t @var{srcptr}, mmux_usize_t @var{srclen})
Call the function of the given memory allocator.

@example
mmux_libc_mall_t  AP;
char              srcstr = "/path/to/file.ext";
mmux_usize_t      srclen_plus;
char *            dststr;

mmux_libc_default_memory_allocator_ref(&AP);

mmux_libc_strlen_plus_nil(&srclen_plus, srcstr);

if (mmux_libc_memory_allocator_malloc_and_copy(AP, &dststr, srcstr, srclen_plus)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, dststr)) @{
  /* error */
@}
@end example
@end deftypefn

@c page
@node memory allocators default
@subsection Default memory allocator


@value{PACKAGE} defines a default memory allocator that just uses the standard memory allocation
functions.


@deftypefun bool mmux_libc_default_memory_allocator_ref (mmux_libc_mall_t * @var{result_p})
Retrieve a pointer to the default memory allocator defined by @value{PACKAGE} and store it in the
variable referenced by @var{result_p}.
@end deftypefun

@c page
@node memory allocators fake
@subsection Fake memory allocator


@value{PACKAGE} defines a fake memory allocator to be used to manage statically allocated data.  In
the class of the fake memory allocator: only the following functions are actually implemented:

@table @code
@item malloc_and_copy
just store the argument @var{srcptr} in the variable referenced by the argument @var{dstptr_p}, then
return @cfalse{}.

@item free
does nothing and return @cfalse{};
@end table

@noindent
all the other functions set @code{errno} to @samp{MMUX_LIBC_ENOSYS} then return @ctrue{} to report
an error.

Let's look at the following code:

@example
mmux_libc_mall_t  AP;
char              srcstr = "/path/to/file.ext";
mmux_usize_t      srclen_plus;
char *            dststr;

retrieve_a_memory_allocator(&AP);

mmux_libc_strlen_plus_nil(&srclen_plus, srcstr)
if (mmux_libc_memory_allocator_malloc_and_copy(AP, &dststr, srcstr, srclen_plus)) @{
  /* error */
@}

...

if (mmux_libc_memory_allocator_free(AP, dststr)) @{
  /* error */
@}
@end example

@noindent
it will work with both the default and the fake allocators:

@itemize
@item
with the default allocator: a new copy of the string is dynamically allocated with the method
@code{malloc_and_copy} and then released with the method @code{free};

@item
with the fake allocator: @code{srcstr} is stored in @code{dststr} by the method
@code{malloc_and_copy} and the method @code{free} just does nothing;
@end itemize

@noindent
this way we can transparently use statically allocated data and dynamically allocated data.  It is
responsibility of the caller to handle correctly mutable and immutable data.


@deftypefun bool mmux_libc_fake_memory_allocator_ref (mmux_libc_mall_t * @var{result_p})
Retrieve a pointer to the fake memory allocator defined by @value{PACKAGE} and store it in the
variable referenced by @var{result_p}.
@end deftypefun

@c page
@node memory allocators example
@subsection How to implement a memory allocator


We can adapt the following implementation of the default allocator:

@example
static bool
spiffy_memory_allocator_malloc (mmux_libc_mall_t allocp __attribute__((__unused__)),
                                mmux_pointer_t * result_p, mmux_usize_t len)
@{
  return mmux_libc_malloc_(result_p, len);
@}
static bool
spiffy_memory_allocator_calloc (mmux_libc_mall_t allocp __attribute__((__unused__)),
                                mmux_pointer_t * result_p,
                                mmux_usize_t item_num, mmux_usize_t item_len)
@{
  return mmux_libc_calloc_(result_p, item_num, item_len);
@}
static bool
spiffy_memory_allocator_realloc (mmux_libc_mall_t allocp __attribute__((__unused__)),
                                 mmux_pointer_t * result_p, mmux_usize_t newlen)
@{
  return mmux_libc_realloc_(result_p, newlen);
@}
static bool
spiffy_memory_allocator_reallocarray (mmux_libc_mall_t allocp __attribute__((__unused__)),
                                      mmux_pointer_t * result_p, mmux_usize_t item_num,
                                      mmux_usize_t item_len)
@{
  return mmux_libc_reallocarray_(result_p, item_num, item_len);
@}
static bool
spiffy_memory_allocator_free (mmux_libc_mall_t allocp __attribute__((__unused__)),
                              mmux_pointer_t p)
@{
  return mmux_libc_free(p);
@}
bool
spiffy_memory_allocator_malloc_and_copy (mmux_libc_mall_t allocp __attribute__((__unused__)),
                                         mmux_pointer_t * dstptr_p,
                                         mmux_pointer_t srcptr, mmux_usize_t srclen)
@{
  return mmux_libc_malloc_and_copy_(dstptr_p, srcptr, srclen);
@}

static mmux_libc_memory_allocator_value_t const spiffy_memory_allocator_value = @{
  .data = NULL,
@};

static mmux_libc_memory_allocator_class_t const spiffy_memory_allocator_class = @{
  .malloc                      = spiffy_memory_allocator_malloc,
  .realloc                     = spiffy_memory_allocator_realloc,
  .calloc                      = spiffy_memory_allocator_calloc,
  .reallocarray                = spiffy_memory_allocator_reallocarray,
  .free                        = spiffy_memory_allocator_free,
  .malloc_and_copy             = mmux_libc_default_memory_allocator_malloc_and_copy,
@};

static mmux_libc_memory_allocator_t const spiffy_memory_allocator = @{
  .value      = (mmux_libc_memory_allocator_value_t *) &spiffy_memory_allocator_value,
  .class      = &spiffy_memory_allocator_class,
@};

bool
spiffy_memory_allocator_ref (mmux_libc_mall_t * result_p)
@{
  *result_p = &spiffy_memory_allocator;
  return false;
@}
@end example

@c page
@node strings
@chapter String operations


@menu
* strings inspection::          Inspecting @asciiz{} strings.
* strings duplication::         Duplicating @asciiz{} strings.
* strings concatenation::       Concatenating @asciiz{} strings.
* strings comparison::          Comparing @asciiz{} strings.
* strings collation::           Collation builtins for @asciiz{} strings.
* strings searching::           Searching in @asciiz{} strings.
* strings tokens::              Finding tokens in @asciiz{} strings.
@end menu

@c page
@node strings inspection
@section Inspecting @asciiz{} strings


@deftypefun bool mmux_libc_strlen (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr})
@MmuxCInterface{strlen}.

@example
mmux_asciizcp_t         bufptr = "the colour of water";
mmux_usize_t            buflen;

if (mmux_libc_strlen(&buflen, bufptr)) @{
  /* error, it should never happen */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strlen_plus_nil (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr})
Wrapper for @cfunc{mmux_libc_strlen} that adds @samp{1} to the result of the call to @cfunc{strlen};
so the number of characters stored in the variable referenced by @var{result_len_p} includes the
terminating null character.
@end deftypefun


@deftypefun bool mmux_libc_strnlen (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr}, mmux_usize_t @var{maxlen})
@MmuxCInterface{strnlen}.

@example
mmux_asciizcp_t  bufptr = "the colour of water";
auto             maxlen = mmux_usize_literal(10);
typeof(maxlen)   buflen;

if (mmux_libc_strnlen(&buflen, bufptr, maxlen)) @{
  /* error, it should never happen */
@}
@end example
@end deftypefun

@c page
@node strings duplication
@section Duplicating @asciiz{} strings


@deftypefun bool mmux_libc_strcpy (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{strcpy}.

@example
//                         01234567890123456789
mmux_asciizcp_t  srcptr = "the colour of water";
char             dstptr[20];

mmux_libc_strcpy(dstptr, srcptr);
assert('\0' == dstptr[19]);
@end example
@end deftypefun


@deftypefun bool mmux_libc_strncpy (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncpy}.

@example
//                         012345678901234567890
mmux_asciizcp_t  srcptr = "the colour of water";
auto             dstlen = mmux_usize_literal(64);
char             dstptr[dstlen.value];

assert(false == mmux_libc_strncpy(dstptr, srcptr, dstlen));
assert('\0' == dstptr[19]);
@end example
@end deftypefun


@deftypefun bool mmux_libc_stpcpy(mmux_asciizp_t * @var{result_next_ptr_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{stpcpy}.

@example
//                         012345678901234567890
mmux_asciizcp_t  srcptr = "the colour of water";
char             dstptr[20];
mmux_asciizp_t   next_dstptr;

assert(false == mmux_libc_stpcpy(&next_dstptr, dstptr, srcptr));
assert('\0' == *next_dstptr);
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_stpncpy(mmux_asciizp_t * @var{result_next_ptr_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{stpncpy}.

@example
//                         012345678901234567890
mmux_asciizcp_t  srcptr = "the colour of water";
auto             dstlen = mmux_usize_literal(64);
char             dstptr[dstlen.value];
mmux_asciizp_t   next_dstptr;

assert(false == mmux_libc_stpncpy(&next_dstptr, dstptr, srcptr, dstlen));
assert('\0' == *next_dstptr);
@end example
@end deftypefn


@deftypefun bool mmux_libc_strdup (mmux_asciizcp_t * @var{result_oustr_p}, mmux_asciizcp_t @var{instr})
@MmuxCInterface{strdup}.

@example
mmux_asciizcp_t     srcptr = "the colour of water";
mmux_asciizcp_t     dstptr;

if (mmux_libc_strdup(&dstptr, srcptr)) @{
  /* error */
@} else @{
  ...
  mmux_libc_free((mmux_pointer_t)dstptr);
@}
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_strndup (mmux_asciizcp_t * @var{result_oustr_p}, mmux_asciizcp_t @var{instr}, mmux_usize_t @var{len})
@MmuxCInterface{strndup}.

@example
//                         012345678901234567890
mmux_asciizcp_t  srcptr = "the colour of water";
auto             dstlen = mmux_usize_literal(10);
mmux_asciizcp_t  dstptr;

if (mmux_libc_strndup(&dstptr, srcptr, dstlen)) @{
  /* error */
@} else @{
  ...
  mmux_libc_free((mmux_pointer_t)dstptr);
@}
@end example
@end deftypefn

@c page
@node strings concatenation
@section Concatenating @asciiz{} strings


@deftypefun bool mmux_libc_strcat (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{strcat}.

@example
//                          01234567890123456789012345678901234567890
//                                    1         2         3         4
mmux_asciizcp_t  srcptr1 = "the colour of water";
mmux_asciizcp_t  srcptr2 =                    " and quicksilver";
auto             dstlen  = mmux_usize_literal(36);
char             dstptr[dstlen.value];

mmux_libc_memzero(dstptr, dstlen);

assert(false == mmux_libc_strcat(dstptr, srcptr1));
assert('\0' == dstptr[19]);

assert(false == mmux_libc_strcat(dstptr, srcptr2));
assert('\0' == dstptr[35]);
@end example
@end deftypefun


@deftypefun bool mmux_libc_strncat (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncat}.

@example
//                          01234567890123456789012345678901234567890
//                                    1         2         3         4
mmux_asciizcp_t  srcptr1 = "the colour of water ha! ha! ha!";
mmux_asciizcp_t  srcptr2 =                    " and quicksilver ha!";
//                                             012345678901234567890
auto             dstlen  = mmux_usize_literal(36);
char             dstptr[dstlen.value];

auto             len1    = mmux_usize_literal(19);
auto             len2    = mmux_usize_literal(16);

mmux_libc_memzero(dstptr, dstlen);

assert(false == mmux_libc_strncat(dstptr, srcptr1, len1));
assert('\0' == dstptr[19]);

assert(false == mmux_libc_strncat(dstptr, srcptr2, len2));
assert('\0' == dstptr[35]);
@end example
@end deftypefun

@c page
@node strings comparison
@section Comparing @asciiz{} strings


@deftypefun bool mmux_libc_strcmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr})
@MmuxCInterface{strcmp}.

@example
@{
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  mmux_sint_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strcmp(&result, bufptr_one, bufptr_two));
  assert(mmux_ctype_is_positive(result));
@}
@{
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  mmux_sint_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strcmp(&result, bufptr_two, bufptr_one));
  assert(mmux_ctype_is_negative(result));
@}
@{
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of water";
  mmux_sint_t       result;

  assert(false == mmux_libc_strcmp(&result, bufptr_two, bufptr_one));
  assert(mmux_ctype_is_zero(result));
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strncmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncmp}.
@end deftypefun


@deftypefun bool mmux_libc_strcasecmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr})
@MmuxCInterface{strcasecmp}.

@example
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  auto              buflen     = mmux_usize_literal(15);
  mmux_sint_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strncmp(&result, bufptr_one, bufptr_two, buflen));
  assert(mmux_ctype_is_positive(result));
@}
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  auto              buflen     = mmux_usize_literal(15);
  mmux_sint_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strncmp(&result, bufptr_two, bufptr_one, buflen));
  assert(mmux_ctype_is_negative(result));
@}
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the colour of water";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  auto              buflen     = mmux_usize_literal(10);
  mmux_sint_t       result;

  assert(false == mmux_libc_strncmp(&result, bufptr_two, bufptr_one, buflen));
  assert(mmux_ctype_is_zero(result));
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strncasecmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncasecmp}.

@example
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the COLOUR OF WAter";
  mmux_asciizcp_t   bufptr_two = "the colour of quicksilver";
  auto              buflen     = mmux_usize_literal(15);
  mmux_sint_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strncasecmp(&result, bufptr_one, bufptr_two, buflen));
  assert(mmux_ctype_is_positive(result));
@}
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the COLOUR OF water";
  mmux_asciizcp_t   bufptr_two = "the colour of QUICKSILVER";
  auto              buflen     = mmux_usize_literal(15);
  mmux_sint_t       result;

  // 'w' > 'q' so bufptr_one > bufptr_two */
  assert(false == mmux_libc_strncasecmp(&result, bufptr_two, bufptr_one, buflen));
  assert(mmux_ctype_is_negative(result));
@}
@{
  //                              01234567890123456789
  mmux_asciizcp_t   bufptr_one = "the COLOUR OF WATER";
  mmux_asciizcp_t   bufptr_two = "the colour OF quicksilver";
  auto              buflen     = mmux_usize_literal(10);
  mmux_sint_t       result;

  assert(false == mmux_libc_strncasecmp(&result, bufptr_two, bufptr_one, buflen));
  assert(mmux_ctype_is_zero(result));
@}
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_strverscmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr})
@MmuxCInterface{strverscmp}.

@example
@{
  mmux_asciizcp_t   bufptr_one = "1.2.3";
  mmux_asciizcp_t   bufptr_two = "1.2.8";
  mmux_sint_t       result;

  // '8' > '3' so bufptr_one < bufptr_two */
  assert(false == mmux_libc_strverscmp(&result, bufptr_one, bufptr_two));
  assert(mmux_ctype_is_negative(result));
@}
@{
  mmux_asciizcp_t   bufptr_one = "1.2.3";
  mmux_asciizcp_t   bufptr_two = "1.2.8";
  mmux_sint_t       result;

  // '8' > '3' so bufptr_one < bufptr_two */
  assert(false == mmux_libc_strverscmp(&result, bufptr_two, bufptr_one));
  assert(mmux_ctype_is_positive(result));
@}
@{
  mmux_asciizcp_t   bufptr_one = "1.2.3";
  mmux_asciizcp_t   bufptr_two = "1.2.3";
  mmux_sint_t       result;

  assert(false == mmux_libc_strverscmp(&result, bufptr_two, bufptr_one));
  assert(mmux_ctype_is_zero(result));
@}
@end example
@end deftypefn

@c page
@node strings collation
@section Collation builtins for @asciiz{} strings


@deftypefun bool mmux_libc_strcoll (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr})
@MmuxCInterface{strcoll}.
@end deftypefun


@deftypefun bool mmux_libc_strxfrm (mmux_usize_t * @var{result_size_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strxfrm}.
@end deftypefun

@c page
@node strings searching
@section Searching in @asciiz{} strings


@deftypefun bool mmux_libc_strchr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strchr}.
@end deftypefun


@deftypefun bool mmux_libc_strchrnul (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strchrnul}.
@end deftypefun


@deftypefun bool mmux_libc_strrchr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strrchr}.
@end deftypefun


@deftypefun bool mmux_libc_strstr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{haystack}, mmux_asciizcp_t @var{needle})
@MmuxCInterface{strstr}.
@end deftypefun


@deftypefun bool mmux_libc_strcasestr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{haystack}, mmux_asciizcp_t @var{needle})
@MmuxCInterface{strcasestr}.
@end deftypefun


@deftypefun bool mmux_libc_strspn (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{skipset})
@MmuxCInterface{strspn}.
@end deftypefun


@deftypefun bool mmux_libc_strcspn (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{stopset})
@MmuxCInterface{strcspn}.
@end deftypefun


@deftypefun bool mmux_libc_strpbrk (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{stopset})
@MmuxCInterface{strpbrk}.
@end deftypefun

@c page
@node strings tokens
@section Finding tokens in @asciiz{} strings


@deftypefun bool mmux_libc_strtok (mmux_asciizcp_t * @var{result_p}, mmux_asciizp_t @var{newstring}, mmux_asciizcp_t @var{delimiters})
@MmuxCInterface{strtok}.
@end deftypefun


@deftypefun bool mmux_libc_basename (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{pathname})
@MmuxCInterface{basename}.
@end deftypefun


@deftypefun bool mmux_libc_dirname (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{pathname})
@MmuxCInterface{dirname}.
@end deftypefun

@c page
@node characters
@chapter Character operations


@menu
* characters classes::          Character classes.
* characters capital::          Character capitalisation.
@end menu

@c page
@node characters classes
@section Character classes


@deftypefun bool mmux_libc_islower (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{islower}.
@end deftypefun


@deftypefun bool mmux_libc_isupper (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isupper}.
@end deftypefun


@deftypefun bool mmux_libc_isalpha (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isalpha}.
@end deftypefun


@deftypefun bool mmux_libc_isdigit (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isdigit}.
@end deftypefun


@deftypefun bool mmux_libc_isalnum (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isalnum}.
@end deftypefun


@deftypefun bool mmux_libc_isxdigit (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isxdigit}.
@end deftypefun


@deftypefun bool mmux_libc_ispunct (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{ispunct}.
@end deftypefun


@deftypefun bool mmux_libc_isspace (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isspace}.
@end deftypefun


@deftypefun bool mmux_libc_isblank (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isblank}.
@end deftypefun


@deftypefun bool mmux_libc_isgraph (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isgraph}.
@end deftypefun


@deftypefun bool mmux_libc_isprint (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isprint}.
@end deftypefun


@deftypefun bool mmux_libc_iscntrl (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{iscntrl}.
@end deftypefun


@deftypefun bool mmux_libc_isascii (bool * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{isascii}.
@end deftypefun

@c page
@node characters capital
@section Character capitalisation


@deftypefun bool mmux_libc_tolower (mmux_char_t * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{tolower}.
@end deftypefun


@deftypefun bool mmux_libc_toupper (mmux_char_t * @var{result_p}, mmux_char_t @var{ch})
@MmuxCInterface{toupper}.
@end deftypefun

@c page
@node time
@chapter Times and dates


@menu
* time timeval::                The @objtype{mmux_libc_timeval_t} type.
* time timespec::               The @objtype{mmux_libc_timespec_t} type.
* time tm::                     The @objtype{mmux_libc_tm_t} type.
* time acquiring::              Acquiring the current time.
* time epoch time::             Converting from Epoch time to other formats.
* time broken time::            Converting from broken time to other formats.
* time format::                 Formatting string timestamps.
* time parsing::               Converting from string timestamps to other formats.
* time sleeping::               Suspending a process for a time.
@end menu

@c page
@node time timeval
@section The @objtype{mmux_libc_timeval_t} type


@MmuxCStructOpaqueTypedef{timeval}
@MmuxSetterGetter{timeval, tv_sec,  mmux_time_t}
@MmuxSetterGetter{timeval, tv_usec, mmux_slong_t}
@MmuxStructDumper{timeval}


@deftypefun bool mmux_libc_timeval_set (mmux_libc_timeval_t * @var{timeval_p}, mmux_time_t @var{seconds}, mmux_slong_t @var{microseconds})
Initialise the fields of a @MmuxCStruct{timeval}.
@end deftypefun

@c page
@node time timespec
@section The @objtype{mmux_libc_timespec_t} type


To have more expressive names: in this @api{} we ``rename'' the fields @samp{tv_sec} and
@samp{tv_nsec} of @MmuxCStruct{timespec} to @samp{ts_sec} and @samp{ts_nsec}.


@MmuxCStructOpaqueTypedef{timespec}
@MmuxSetterGetter{timespec, ts_sec,  mmux_time_t}
@MmuxSetterGetter{timespec, ts_nsec, mmux_slong_t}
@MmuxStructDumper{timespec}


@deftypefun bool mmux_libc_timespec_set (mmux_libc_timeval_t * @var{timeval_p}, mmux_time_t @var{seconds}, mmux_slong_t @var{nanoseconds})
Initialise the fields of a @MmuxCStruct{timespec}.
@end deftypefun

@c page
@node time tm
@section The @objtype{mmux_libc_tm_t} type


@MmuxCStructOpaqueTypedef{tm}
@MmuxSetterGetter{tm, tm_sec,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_min,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_hour,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_mday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_mon,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_year,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_wday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_yday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_isdst,       mmux_sint_t}
@MmuxSetterGetter{tm, tm_gmtoff,      mmux_slong_t}
@MmuxSetterGetter{tm, tm_zone,        mmux_asciizcp_t}
@MmuxStructDumper{tm}


@deftypefun bool mmux_libc_tm_reset (mmux_libc_tm_t * @var{TM_P})
Reset the fields to:

@example
tm_sec    = 0
tm_min    = 0
tm_hour   = 0
tm_mday   = 1
tm_mon    = 0
tm_year   = 0
tm_wday   = 0
tm_yday   = 0
tm_isdst  = 0
tm_gmtoff = 0
tm_zone   = NULL
@end example
@end deftypefun

@c page
@node time acquiring
@section Acquiring the current time


@deftypefun bool mmux_libc_current_time (mmuc_time_t * @var{result_p})
@MmuxCInterface{time}.

@example
mmux_time_t         T;

mmux_libc_current_time(&T);
@{
  mmux_libc_fd_t    fd;

  mmux_libc_libou(&fd);
  if (mmux_libc_dprintf_time(fd, T)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node time epoch time
@section Converting from Epoch time to other formats


@deftypefun bool mmux_libc_localtime (mmux_libc_tm_t * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{localtime}.  Store in the variable referenced by @var{result_p} a pointer to a
statically allocated @objtype{mmux_libc_tm_t} that will be overwritten by future calls to time
functions; we should just use @cfunc{mmux_libc_localtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t *        BT;

mmux_libc_current_time(&T);
mmux_libc_localtime(&BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_localtime_r (mmux_libc_tm_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{localtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t          BT[1];

mmux_libc_current_time(&T);
mmux_libc_localtime_r(BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_gmtime (mmux_libc_tm_t * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{gmtime}.  Store in the variable referenced by @var{result_p} a pointer to a
statically allocated @objtype{mmux_libc_tm_t} that will be overwritten by future calls to time
functions; we should just use @cfunc{mmux_libc_gmtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t *        BT;

mmux_libc_current_time(&T);
mmux_libc_gmtime(&BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_gmtime_r (mmux_libc_tm_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{gmtime_r}.

@example
mmux_time_t             T;
mmux_libc_tm_t          BT[1];

mmux_libc_current_time(&T);
mmux_libc_gmtime_r(BT, T);
@{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_tm_dump(fd, BT, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_ctime (mmux_asciizcp_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{ctime}.  The variable referenced by @var{result_p} is set to a pointer to a
statically allocated string, which will be overwritten by future calls to time functions; we should
just use @cfunc{mmux_libc_ctime_r}.

@example
mmux_time_t         T;
mmux_asciizcp_t     bufptr;

mmux_libc_current_time(&T);
mmux_libc_asctime(&bufptr, T);
if (mmux_libc_dprintfer("the timestamp from ctime is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_ctime_r (mmux_asciizp_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{ctime_r}.

@example
mmux_time_t         T;
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK            512
mmux_char_t         bufptr[IS_THIS_ENOUGH_QUESTION_MARK];

mmux_libc_current_time(&T);
mmux_libc_asctime_r(bufptr, T);
if (mmux_libc_dprintfer("the timestamp from ctime_r is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node time broken time
@section Converting from broken time to other formats


@deftypefun bool mmux_libc_mktime (mmux_time_t * @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{mktime}.

@example
mmux_time_t     T1, T2;
mmux_libc_tm_t  BT[1];

mmux_libc_current_time(&T1);
mmux_libc_localtime_r(BT, T1);
mmux_libc_mktime(&T2, BT);
@{
  mmux_libc_fd_t    fd;

  mmux_libc_libou(&fd);
  if (mmux_libc_dprintf_time(fd, T2)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_timegm (mmux_time_t * @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{timegm}.

@example
mmux_time_t     T1, T2;
mmux_libc_tm_t  BT[1];

mmux_libc_current_time(&T1);
mmux_libc_localtime_r(BT, T1);
mmux_libc_timegm(&T2, BT);
@{
  mmux_libc_fd_t    fd;

  mmux_libc_libou(&fd);
  if (mmux_libc_dprintf_time(fd, T2)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_asctime (mmux_asciizcp_t * @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{asctime}.  The variable referenced by @var{result_p} is set to a pointer to a
statically allocated string, which will be overwritten by future calls to time functions; we should
just use @cfunc{mmux_libc_asctime_r}.

@example
mmux_time_t         T;
mmux_libc_tm_t      BT[1];
mmux_asciizcp_t     bufptr;

mmux_libc_current_time(&T);
mmux_libc_localtime_r(BT, T);
mmux_libc_asctime(&bufptr, BT);
if (mmux_libc_dprintfer("the timestamp from asctime is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_asctime_r (mmux_asciizcp_t @var{result_p}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{asctime_r}.

@example
mmux_time_t         T;
mmux_libc_tm_t      BT[1];
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK            512
mmux_char_t         bufptr[IS_THIS_ENOUGH_QUESTION_MARK];

mmux_libc_current_time(&T);
mmux_libc_localtime_r(BT, T);
mmux_libc_asctime_r(bufptr, BT);
if (mmux_libc_dprintfer("the timestamp from asctime_r is: \"%s\"\n", bufptr)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node time format
@section Formatting string timestamps


@deftypefun bool mmux_libc_strftime_required_nbytes_including_nil (mmux_usize_t * @var{required_nbytes_including_nil_p}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
When successful: store in the variable referenced by @var{required_nbytes_including_nil_p} the
number of bytes, @strong{including} the terminating zero, required to hold the string generated by
@cfunc{strftime} when applied to @var{template} to format a time specification from the broken time
@var{BT}.
@end deftypefun


@anchor{mmux_libc_strftime}
@deftypefun bool mmux_libc_strftime (mmux_usize_t * @var{required_nbytes_without_zero_p}, mmux_asciizp_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{strftime}.  Format an output string representation of the timestamp referenced by
@var{BT} according to @var{template}, and store it in the buffer referenced by @var{bufptr}; at
most @var{buflen} characters, including the terminating zero, will be written to @var{bufptr}.

When successful: the generated string length, without the terminating zero, is stored in the
variable referenced by @var{required_nbytes_without_zero_p}.

It is sometimes better to use the function @cfunc{mmux_libc_dprintf_strftime},
@ref{mmux_libc_dprintf_strftime} for details.

@example
mmux_asciizcp_t         template = "%Y-%m-%dT%H:%M:%S%z";
mmux_time_t             T;
mmux_libc_tm_t *        BT;
mmux_usize_t            required_nbytes_including_nil;

mmux_libc_current_time(&T);
mmux_libc_localtime(&BT, T);

if (mmux_libc_strftime_required_nbytes_including_nil(&required_nbytes_including_nil, template, BT) @{
  /* error */
@} else @{
  mmux_char_t           bufptr[required_nbytes_including_nil];
  mmux_usize_t          required_nbytes_without_zero;

  if (mmux_libc_strftime(&required_nbytes_without_zero, bufptr, required_nbytes_including_nil, template, BT)) @{
    /* error */
  @}
@}
mmux_libc_dprintfou("%s\n", bufptr);
@end example
@end deftypefun

@c page
@node time parsing
@section Converting from string timestamps to other formats


@deftypefun bool mmux_libc_strptime (mmux_asciizpp_t @var{first_unprocessed_after_timestamp_p}, mmux_asciizcp_t @var{input_string}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
@MmuxCInterface{strptime}.

@example
mmux_asciizcp_t         template     = "The timestamp is: %a, %d %b %Y %H:%M:%S %z";
mmux_asciizcp_t         input_string = "The timestamp is: Fri, 15 Nov 2024 23:11:20 +0100, and that's it!";
mmux_libc_tm_t          BT[1];
mmux_asciizp_t          first_unprocessed_after_timestamp;

if (mmux_libc_strptime(&first_unprocessed_after_timestamp, input_string, template, BT)) @{
  /* error */
@}

@{
  mmux_libc_fd_t    fd;

  mmux_libc_stder(&fd);
  mmux_libc_tm_dump(fd, BT, NULL);
@}
@end example
@end deftypefun

@c page
@node time sleeping
@section Suspending a process for a time


@deftypefun mmux_uint_t mmux_libc_sleep (mmux_uint_t * @var{leftover_result_p}, mmux_uint_t @var{seconds})
@MmuxCInterface{sleep}.
@end deftypefun


@deftypefun bool mmux_libc_nanosleep (mmux_libc_timespec_t * @var{requested_time}, mmux_libc_timespec_t * @var{remaining_time})
@MmuxCInterface{nanosleep}.

@example
mmux_libc_timespec_t    requested_time;
mmux_libc_timespec_t    remaining_time;

mmux_libc_timespec_set(&requested_time, 12, 34);
if (mmux_libc_nanosleep(&requested_time, &remaining_time)) @{
  /* error or interruption */
@}
@end example
@end deftypefun

@c page
@node system
@chapter System configuration


@menu
* system parameters::           Configuration parameters.
* system limits::               Configuration limits.
@end menu

@c page
@node system parameters
@section Configuration parameters


@cindex @samp{MMUX_LIBC_SC_} constants
@cindex @samp{MMUX_LIBC_CS_} constants
@cindex Constants @samp{MMUX_LIBC_SC_}
@cindex Constants @samp{MMUX_LIBC_CS_}


@deftypefun bool mmux_libc_sysconf (mmux_slong_t * @var{result_p}, mmux_sint_t @var{parameter})
@MmuxCInterface{sysconf}.  @var{parameter} must be one of the @samp{MMUX_LIBC__SC_*} constants.

@example
mmux_slong_t    result;

if (mmux_libc_sysconf(&result, MMUX_LIBC__SC_PAGESIZE)) @{
  /* error */
@}
/* the result is in "result" */
@end example
@end deftypefun


@deftypefun bool mmux_libc_confstr_size (mmux_usize_t * @var{result_required_nbytes_p}, mmux_sint_t @var{parameter})
@deftypefunx bool mmux_libc_confstr (mmux_sint_t @var{parameter}, char * @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{confstr}.  @var{parameter} must be one of the @samp{MMUX_LIBC__CS_*} constants.

@example
mmux_sint_t     parameter = MMUX_LIBC__CS_PATH;
mmux_usize_t    required_nbytes;

if (mmux_libc_confstr_size(&required_nbytes, parameter)) @{ /* error */ @}
@{
  char value[required_nbytes];

  if (mmux_libc_confstr(parameter, value, required_nbytes)) @{ /* error */ @}
  /* the result is in "value" */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pathconf (mmux_slong_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{parameter})
@MmuxCInterface{pathconf}.
@end deftypefun


@deftypefun bool mmux_libc_fpathconf (mmux_slong_t * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{parameter})
@MmuxCInterface{fpathconf}.
@end deftypefun

@c page
@node system limits
@section Configuration limits


@MmuxCStructOpaqueTypedef{rlimit}
@MmuxSetterGetter{rlimit, rlim_cur, mmux_rlim_t}
@MmuxSetterGetter{rlimit, rlim_max, mmux_rlim_t}
@MmuxStructDumper{rlimit}


@deftypefun bool mmux_libc_getrlimit (mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{rlimit_p})
@MmuxCInterface{getrlimit}.
@end deftypefun


@deftypefun bool mmux_libc_setrlimit (mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{rlimit_p})
@MmuxCInterface{setrlimit}.
@end deftypefun


@deftypefun bool mmux_libc_prlimit (mmux_libc_pid_t @var{pid}, mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{new_rlimit_p}, mmux_libc_rlimit_t * @var{old_rlimit_p})
@MmuxCInterface{prlimit}.
@end deftypefun

@c page
@node persona
@chapter Persona operations


@menu
* persona uids::                Representing UIDs.
* persona gids::                Representing GIDs.
* persona getting::             Getting users and groups.
* persona setting::             Setting users and groups.
* persona login::               Identifying who logged in.
* persona database user::       User database.
* persona database group::      Group database.
@end menu

@c page
@node persona uids
@section Representing UIDs


To obtain a UID value and convert it to string, we can do:

@example
mmux_libc_uid_t         the_uid;
mmux_usize_t            required_nchars;

mmux_libc_getuid(&the_uid);

if (mmux_libc_uid_sprint_size(&required_nchars, the_uid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_uid_sprint(str, required_nchars, the_uid) @{
    /* error */
  @}
@}
@end example


@deftp {Opaque Struct Alias} mmux_libc_uid_t
Type of data structure containing a value of type @objtype{mmux_uid_t}.
@end deftp


@deftypefun bool mmux_libc_make_uid (mmux_libc_uid_t * @var{result_p}, mmux_standard_libc_uid_t @var{uid_num})
Build a new value of type @objtype{mmux_libc_uid_t}.
@end deftypefun


@deftypefun bool mmux_libc_uid_parse (mmux_libc_uid_t * @var{uid_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_uid_t}
value; store the value in the location referenced by @var{uid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_uid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_uid_t @var{uid})
Determine the number of characters required to contain the string representation of @var{uid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_uid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_uid_t @var{uid})
Convert @var{uid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node persona gids
@section Representing GIDs


To obtain a GID value and convert it to string, we can do:

@example
mmux_libc_gid_t         the_gid;
mmux_usize_t            required_nchars;

mmux_libc_getgid(&the_gid);

if (mmux_libc_gid_sprint_size(&required_nchars, the_gid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_gid_sprint(str, required_nchars, the_gid) @{
    /* error */
  @}
@}
@end example


@deftp {Opaque Struct Alias} mmux_libc_gid_t
Type of data structure containing a value of type @objtype{mmux_gid_t}.
@end deftp


@deftypefun bool mmux_libc_make_gid (mmux_libc_gid_t * @var{result_p}, mmux_standard_libc_gid_t @var{gid_num})
Build a new value of type @objtype{mmux_libc_gid_t}.
@end deftypefun


@deftypefun bool mmux_libc_gid_parse (mmux_libc_gid_t * @var{gid_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_gid_t}
value; store the value in the location referenced by @var{gid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_gid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_gid_t @var{gid})
Determine the number of characters required to contain the string representation of @var{gid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_gid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_gid_t @var{gid})
Convert @var{gid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node persona getting
@section Getting users and groups


@deftypefun bool mmux_libc_getuid (mmux_libc_uid_t * @var{result_p})
@MmuxCInterface{getuid}.
@end deftypefun


@deftypefun bool mmux_libc_getgid (mmux_libc_gid_t * @var{result_p})
@MmuxCInterface{getgid}.
@end deftypefun


@deftypefun bool mmux_libc_geteuid (mmux_libc_uid_t * @var{result_p})
@MmuxCInterface{geteuid}.
@end deftypefun


@deftypefun bool mmux_libc_getegid (mmux_libc_gid_t * @var{result_p})
@MmuxCInterface{getegid}.
@end deftypefun


To retrieve the supplementary groups of the current process we do:

@example
mmux_usize_t    ngroups;

if (mmux_libc_getgroups_size(&ngroups)) @{
  /* error */
@} else @{
  mmux_libc_gid_t       gids[ngroups];

  if (mmux_libc_getgroups(&ngroups, gids)) @{
    /* error */
  @} else @{
    /* do something with gids */
  @}
@}
@end example


@deftypefun bool mmux_libc_getgroups_size (mmux_usize_t * @var{result_ngroups_p})
Determine the number of supplementary groups of the current process and store it in the location
referenced by @var{ngroups_p}.
@end deftypefun


@deftypefun bool mmux_libc_getgroups (mmux_usize_t * @var{ngroups_p}, mmux_libc_gid_t * @var{groups_p})
@MmuxCInterface{getgroups}.  Fill the array referenced by @var{groups_p} with values representing
the supplementary groups of the current process.

@itemize
@item
Upon entering the function call: the array must have a number of elements equal to the value
referenced by @var{ngroups_p}.

@item
Upon returning from the function call: the location referenced by @var{ngroups_p} is updated with
the actual number of values stored in the array.
@end itemize
@end deftypefun


To retrieve the groups a user belongs to we do:

@example
mmux_libc_uid_t         uid;
mmux_libc_passwd_t *    PW;

mmux_libc_getuid(&uid);
if (mmux_libc_getpwuid(&PW, uid)) @{
  /* error */
@} else @{
  mmux_asciizcp_t       name;
  mmux_libc_gid_t       gid;
  mmux_usize_t          ngroups;

  mmux_libc_pw_name_ref (&name, PW);
  mmux_libc_pw_gid_ref  (&gid,  PW);

  if (mmux_libc_getgrouplist_size(&ngroups, name, gid)) @{
    /* error */
  @} else @{
    mmux_libc_gid_t       gids[ngroups];

    if (mmux_libc_getgrouplist(name, gid, &ngroups, gids)) @{
      /* error */
    @} else @{
     /* do something with "gids" */
    @}
  @}
@}
@end example


@deftypefun bool mmux_libc_getgrouplist_size (mmux_usize_t * @var{result_ngroups_p}, mmux_asciizcp_t @var{username}, mmux_libc_gid_t @var{gid})
Determine the number of groups a user belongs to and store it in the location referenced by
@var{ngroups_p}.
@end deftypefun


@deftypefun bool mmux_libc_getgrouplist (mmux_asciizcp_t @var{username}, mmux_libc_gid_t @var{gid}, mmux_usize_t * @var{ngroups_p}, mmux_libc_gid_t * @var{groups_p})
@MmuxCInterface{getgrouplist}.  Fill the array referenced by @var{groups_p} with values representing
the groups a user belongs to.

@itemize
@item
Upon entering the function call: the array must have a number of elements equal to the value
referenced by @var{ngroups_p}.

@item
Upon returning from the function call: the location referenced by @var{ngroups_p} is updated with
the actual number of values stored in the array.
@end itemize
@end deftypefun

@c page
@node persona setting
@section Setting users and groups


@deftypefun bool mmux_libc_setuid (mmux_libc_uid_t @var{uid})
@MmuxCInterface{setuid}.

@example
mmux_libc_uid_t     uid;

if (mmux_libc_getuid(&uid)) @{
  /* error */
@}
if (mmux_libc_setuid(uid)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_seteuid (mmux_libc_uid_t @var{uid})
@MmuxCInterface{seteuid}.

@example
mmux_libc_uid_t     euid;

if (mmux_libc_geteuid(&euid)) @{
  /* error */
@}
if (mmux_libc_seteuid(euid)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_setreuid (mmux_libc_uid_t @var{uid}, mmux_libc_uid_t @var{euid})
@MmuxCInterface{setreuid}.

@example
mmux_libc_uid_t     uid;

if (mmux_libc_geteuid(&uid)) @{
  /* error */
@}
if (mmux_libc_setreuid(uid, uid)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_setgid (mmux_libc_gid_t @var{gid})
@MmuxCInterface{setgid}.

@example
mmux_libc_gid_t     gid;

if (mmux_libc_getgid(&gid)) @{
  /* error */
@}
if (mmux_libc_setgid(gid)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_setegid (mmux_libc_gid_t @var{gid})
@MmuxCInterface{setegid}.

@example
mmux_libc_gid_t     gid;

if (mmux_libc_getegid(&gid)) @{
  /* error */
@}
if (mmux_libc_setegid(gid)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_setregid (mmux_libc_gid_t @var{gid}, mmux_libc_gid_t @var{egid})
@MmuxCInterface{setregid}.

@example
mmux_libc_gid_t     gid;

if (mmux_libc_getegid(&gid)) @{
  /* error */
@}
if (mmux_libc_setregid(gid, gid)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node persona login
@section Identifying who logged in


@deftypefun bool mmux_libc_getlogin (mmux_asciizcpp_t @var{result_username_p})
@MmuxCInterface{getlogin}.

@example
mmux_asciizcp_t     name;

if (mmux_libc_getlogin(&name)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getlogin_r (mmux_asciizp_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{getlogin_r}.

@example
mmux_usize_t    buflen = 64;
mmux_char_t     bufptr[buflen];

if (mmux_libc_getlogin_r(bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node persona database user
@section User database


To print the whole @file{/etc/passwd} database using the non--reentrant function
@cfunc{mmux_libc_getpwent} we do:

@example
mmux_libc_setpwent();
@{
  mmux_libc_passwd_t *      PW;
  mmux_libc_fd_t            fd;

  mmux_libc_stder(&fd);
  for (;;) @{
    mmux_libc_getpwent(&PW);
    if (NULL == PW) @{
      break;
    @} else if (mmux_libc_passwd_dump(fd, PW, NULL)) @{
      /* error */
    @}
  @}
@}
mmux_libc_endpwent();
@end example


@MmuxCStructOpaqueTypedef{passwd}
@MmuxSetterGetter{passwd,	pw_name,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_passwd,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_uid,		mmux_libc_uid_t}
@MmuxSetterGetter{passwd,	pw_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{passwd,	pw_gecos,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_dir,		mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_shell,	mmux_asciizcp_t}
@MmuxStructDumper{passwd}


@deftypefun bool mmux_libc_setpwent (void)
@MmuxCInterface{setpwent}.
@end deftypefun


@deftypefun bool mmux_libc_endpwent (void)
@MmuxCInterface{endpwent}.
@end deftypefun


@deftypefun bool mmux_libc_getpwent (mmux_libc_passwd_t * * @var{result_passwd_pp})
@MmuxCInterface{getpwent}.
@end deftypefun


@deftypefun bool mmux_libc_getpwuid (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_libc_uid_t @var{uid})
@MmuxCInterface{getpwuid}.

@example
mmux_libc_uid_t             uid;
mmux_libc_passwd_t *        PW;
mmux_libc_fd_t              fd;

mmux_libc_stder(&fd);
if (mmux_libc_getuid(&uid)) @{
  /* error */
@} else if (mmux_libc_getpwuid(&PW, uid)) @{
  /* error */
@} else if (PW && mmux_libc_passwd_dump(fd, PW, NULL)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getpwnam (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_asciizcp_t @var{username})
@MmuxCInterface{getpwnam}.

@example
mmux_asciizcp_t             name = "root";
mmux_libc_passwd_t *        PW;
mmux_libc_fd_t              fd;

if (mmux_libc_getpwnam(&PW, name)) @{
  /* error */
@} else if (PW && mmux_libc_passwd_dump(fd, PW, NULL)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node persona database group
@section Group database


To print the whole @file{/etc/group} database using the non--reentrant function
@cfunc{mmux_libc_getgrent} we do:

@example
mmux_libc_setgrent();
@{
  mmux_libc_group_t *   GR;
  mmux_libc_fd_t        fd;

  mmux_libc_stder(&fd);
  for (;;) @{
    mmux_libc_getgrent(&GR);
    if (NULL == GR) @{
      break;
    @} else if (mmux_libc_group_dump(fd, GR, NULL)) @{
      /* error */
    @}
  @}
@}
mmux_libc_endgrent();
@end example


@MmuxCStructOpaqueTypedef{group}
@MmuxSetterGetter{group,	gr_name,	mmux_asciizcp_t}
@MmuxSetterGetter{group,	gr_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{group,	gr_mem,		mmux_asciizcp_t*}
@MmuxStructDumper{group}


@deftypefun bool mmux_libc_setgrent (void)
@MmuxCInterface{setgrent}.
@end deftypefun


@deftypefun bool mmux_libc_endgrent (void)
@MmuxCInterface{endgrent}.
@end deftypefun


@deftypefun bool mmux_libc_getgrent (mmux_libc_group_t * * @var{result_group_pp})
@MmuxCInterface{getgrent}.
@end deftypefun


@deftypefun bool mmux_libc_getgrgid (mmux_libc_group_t * * @var{result_group_pp}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{getgrgid}.

@example
mmux_libc_gid_t             gid;
mmux_libc_group_t *        GR;
mmux_libc_fd_t              fd;

mmux_libc_stder(&fd);
if (mmux_libc_getgid(&gid)) @{
  /* error */
@} else if (mmux_libc_getgrgid(&GR, gid)) @{
  /* error */
@} else if (GR && mmux_libc_group_dump(fd, GR, NULL)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getgrnam (mmux_libc_group_t * * @var{result_group_pp}, mmux_asciizcp_t @var{groupname})
@MmuxCInterface{getgrnam}.

@example
mmux_asciizcp_t             name = "root";
mmux_libc_group_t *         GR;
mmux_libc_fd_t              fd;

if (mmux_libc_getgrnam(&GR, name)) @{
  /* error */
@} else if (GR && mmux_libc_group_dump(fd, GR, NULL)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_group_member (bool * @var{result_is_member_p}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{group_member}.

@example
mmux_libc_gid_t     gid;
bool                this_process_belongs_to_group;

if (mmux_libc_getgid(&gid)) @{
  /* error */
@} else if (mmux_libc_group_member(&this_process_belongs_to_group, gid)) @{
  /* error */
@} else if (this_process_belongs_to_group) @{
  /* it belongs */
@} else @{
  /* it does not belong */
@}
@end example
@end deftypefn

@c page
@node processes
@chapter Processes


@menu
* processes pids::              Representing PIDs.
* processes statuses::          Representing process completion--statuses.
* processes getting::           Getting PIDs.
* processes forking::           Forking processes.
* processes waiting::           Waiting for process completion.
* processes exiting::           Exiting processes.
@end menu

@c page
@node processes pids
@section Representing PIDs


@deftp {Opaque Struct Typedef} mmux_libc_pid_t
Opaque data structure type representing a @objtype{mmux_pid_t}.
@end deftp


@deftypefun bool mmux_libc_make_pid (mmux_libc_pid_t * @var{result_p}, mmux_pid_t @var{pid_num})
Build a new value of type @objtype{mmux_libc_pid_t}.
@end deftypefun


@deftypefun bool mmux_libc_make_pid_zero (mmux_libc_pid_t * @var{result_p})
Build a new value of type @objtype{mmux_libc_pid_t} whose process identifier equals zero.  This is
useful for neutral initialisation of some data structures like @objtype{mmux_libc_flock_t}.
@end deftypefun


@deftypefun bool mmux_libc_make_pid_minus_one (mmux_libc_pid_t * @var{result_p})
Build a new value of type @objtype{mmux_libc_pid_t} whose process identifier equals @samp{-1}.  This
is useful for special initialisation of some data structures like @objtype{mmux_libc_flock_t}, in
which a process identifier equal to @samp{-1} is used for file description locks, @glibcref{Open
File Description Locks, Open File Description Locks}.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_pid_t the_pid;
mmux_usize_t    required_nchars;

mmux_libc_getpid (&the_pid);

if (mmux_libc_pid_sprint_size(&required_nchars, the_pid) @{
  /* error */
@} else @{
  char  str[required_nchars.value];

  if (mmux_libc_pid_sprint(str, required_nchars, the_pid) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_pid_parse (mmux_libc_pid_t * @var{pid_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_pid_t}
value; store the value in the location referenced by @var{pid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_pid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_pid_t @var{pid})
Determine the number of characters required to contain the string representation of @var{pid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_pid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_pid_t @var{pid})
Convert @var{pid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node processes statuses
@section Representing process completion--statuses


@deftp {Opaque Struct Typedef} mmux_libc_completed_process_status_t
Opaque data structure type representing a process completion--status, which is a
@objtype{mmux_sint_t} value.
@end deftp


@deftypefun bool mmux_libc_make_process_completion_status (mmux_libc_completed_process_status_t * @var{result_p}, mmux_sint_t @var{status_num})
Build a new value of type @objtype{mmux_libc_completed_process_status_t}.
@end deftypefun


@deftypefun bool mmux_libc_completed_process_status_equal (mmux_libc_completed_process_status_t @vari{status}, mmux_libc_completed_process_status_t @varii{status})
Return true if @vari{status} and @varii{status} are equal.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_completed_process_status_t    the_status = ...;
mmux_usize_t                            required_nchars;

if (mmux_libc_completed_process_status_sprint_size(&required_nchars, the_status) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_completed_process_status_sprint(str, required_nchars, the_status) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_completed_process_status_parse (mmux_libc_completed_process_status_t * @var{status_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a
@objtype{mmux_libc_completed_process_status_t} value; store the value in the location referenced by
@var{status_p}.  If an error occurs and @var{who} is not @cnull{}: print an error message to
@stderr{} using @var{who} as name of the entity that performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_completed_process_status_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_completed_process_status_t @var{status})
Determine the number of characters required to contain the string representation of @var{status} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_completed_process_status_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_completed_process_status_t @var{status})
Convert @var{status} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_WIFEXITED (bool * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFEXITED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WEXITSTATUS (mmux_sint_t * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WEXITSTATUS,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WIFSIGNALED (bool * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFSIGNALED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WTERMSIG (mmux_libc_interprocess_signal_t * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WTERMSIG,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WCOREDUMP (bool * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WCOREDUMP,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WIFSTOPPED (bool * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFSTOPPED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WSTOPSIG (mmux_libc_interprocess_signal_t * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WSTOPSIG,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun


@deftypefun bool mmux_libc_WIFCONTINUED (bool * @var{result_p}, mmux_libc_completed_process_status_t @var{completed_process_status})
@MmuxCMacroInterfaceTwo{WIFCONTINUED,waitpid}.  Set the variable referenced by @var{result_p} to the
value computed by the C preprocessor macro.
@end deftypefun

@c page
@node processes getting
@section Getting PIDs


@deftypefun bool mmux_libc_getpid  (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gitpid}.
@end deftypefun


@deftypefun  bool mmux_libc_getppid (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gitppid}.
@end deftypefun


@deftypefun bool mmux_libc_gettid (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gittid}.
@end deftypefun

@c page
@node processes forking
@section Forking processes


@deftypefun bool mmux_libc_fork (bool * @var{this_is_the_parent_process_p}, mmux_libc_pid_t * @var{child_process_pid_p})
@MmuxCInterface{fork}.  When a call is successful:

Regarding the argument @var{this_is_the_parent_process_p}: the referenced variable is mutated only
when a call is successful, otherwise it is left untouched.

@itemize
@item
In the parent process: the referenced variable is set to @ctrue{}.

@item
In the child process: the referenced variable is set to @cfalse{}.
@end itemize

Regarding the argument @var{child_process_pid_p}: the referenced variable is mutated only in the
parent process and when a call is successful, otherwise it is left untouched.

@itemize
@item
In the parent process: the referenced variable is set to the child process identifier.

@item
In the child process: the referenced variable is left untouched.
@end itemize

@example
bool                    this_is_the_parent_process;
mmux_libc_pid_t         child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  mmux_sint_t         errnum;

  mmux_libc_errno_consume(&errnum);
  ... /* handle the error */
@} else if (this_is_the_parent_process) @{
  ... /* do something in the parent process, maybe using "child_pid" */
@} else @{
  ... /* do something in the child process */
@}
@end example
@end deftypefun

@c page
@node processes waiting
@section Waiting for process completion


@menu
* processes waiting args::      Convention for common arguments.
* processes waiting waitpid::   Waiting with @cfunc{waitpid}.
* processes waiting other::     Waiting with other functions.
@end menu

@c page
@node processes waiting args
@subsection Convention for common arguments


This section documents the common arguments in calls to process--completion waiting--functions.  For
all the documented functions:

@table @code
@item bool * @var{completed_process_status_available_p}
pointer argument which cannot be @cnull{}; when the function call is successful:

@itemize
@item
if we have collected the completion status of a process: the referenced variable is set to @ctrue{};

@item
if no completion status was collected: the referenced variable is set to @cfalse{};
@end itemize

@noindent
when the function call is a failure: the referenced variable is left untouched;

@item mmux_libc_pid_t * @var{completed_process_pid_p}
pointer argument which cannot be @cnull{}; when the function call is successful and we have
collected the completion status of a process: the PID of the completed process is stored in the
referenced variable, otherwise the variable is left untouched;

@item mmux_libc_completed_process_status_t * @var{completed_process_status_p}
pointer argument which cannot be @cnull{}; when the function call is successful and we have
collected the completion status of a process: such status is stored in the referenced variable,
otherwise the variable is left untouched.
@end table

@c page
@node processes waiting waitpid
@subsection Waiting with @cfunc{waitpid}


For the documentation of the common arguments see @ref{processes waiting args, Convention for common
arguments}.


@deftypefun bool mmux_libc_wait_any_process (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of any child process.

@example
bool                                    completed_process_status_available;
mmux_libc_pid_t                         completed_process_pid;
mmux_libc_completed_process_status_t    completed_process_status;

if (mmux_libc_wait_any_process(&completed_process_status_available, &completed_process_pid,
                               &completed_process_status, MMUX_LIBC_WNOHANG)) @{
  ... /* handle the error */
@} else @{
  if (completed_process_status_available) @{
    ... /* do something with "completed_process_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_my_process_group (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of any child process in the same process group
of the calling process.

@example
bool                                    completed_process_status_available;
mmux_libc_pid_t                         completed_process_pid;
mmux_libc_completed_process_status_t    completed_process_status;

if (mmux_libc_wait_my_process_group(&completed_process_status_available, &completed_process_pid,
                                    &completed_process_status, MMUX_LIBC_WNOHANG)) @{
  ... /* handle the error */
@} else @{
  if (completed_process_status_available) @{
    ... /* do something with "completed_process_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_process_id (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p}, mmux_libc_pid_t @var{pid}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of a specific process whose process identifier
is @var{pid}.

@example
bool                    this_is_the_parent_process;
mmux_libc_pid_t         child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  ... /* handle the error */
@} else if (this_is_the_parent_process) @{
  bool                                  completed_process_status_available;
  mmux_libc_pid_t                       completed_process_pid;
  mmux_libc_completed_process_status_t  completed_process_status;

  if (mmux_libc_wait_process_id(&completed_process_status_available, &completed_process_pid,
                                &completed_process_status, child_pid, MMUX_LIBC_WNOHANG)) @{
    ... /* handle the error */
  @} else @{
    if (completed_process_status_available) @{
      ... /* do something with "completed_process_status" */
    @} else @{
      ... /* no completed process status was collected */
    @}
  @}
@} else @{
  ... /* do something in the child process */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_group_id (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_sint_t * @var{completed_process_status_p}, mmux_libc_gid_t @var{gid}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of any process belonging to the process group
@var{gid}.

@example
mmux_libc_gid_t       the_gid;

if (mmux_libc_getgid(&the_gid)) @{
  ... /* handle the error */
@} else @{
  bool                                  completed_process_status_available;
  mmux_libc_pid_t                       completed_process_pid;
  mmux_libc_completed_process_status_t  completed_process_status;

  if (mmux_libc_wait_group_id(&completed_process_status_available, &completed_process_pid,
                              &completed_process_status, the_gid, MMUX_LIBC_WNOHANG)) @{
    ... /* handle the error */
  @} else @{
    if (completed_process_status_available) @{
      ... /* do something with "completed_process_status" */
    @} else @{
      ... /* no completed process status was collected */
    @}
  @}
@}
@end example
@end deftypefun

@c page
@node processes waiting other
@subsection Waiting with other functions


For the documentation of the common arguments see @ref{processes waiting args, Convention for common
arguments}.


@deftypefun bool mmux_libc_wait (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p})
@MmuxCInterface{wait}.  Wait for the termination of any child process.

@example
bool                                    completed_process_status_available;
mmux_libc_pid_t                         completed_process_pid;
mmux_libc_completed_process_status_t    completed_process_status;

if (mmux_libc_wait(&completed_process_status_available, &completed_process_pid, &completed_process_status)) @{
  ... /* handle the error */
@} else @{
  if (completed_process_status_available) @{
    ... /* do something with "completed_process_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@}
@end example
@end deftypefun

@c page
@node processes exiting
@section Exiting processes


@deftp {Struct Typedef} mmux_libc_process_exit_status_t
Type of the exit status constants.
@end deftp


@deftypefun bool mmux_libc_exit (mmux_libc_process_exit_status_t @var{status})
@MmuxCInterface{exit}.
@end deftypefun


@deftypefun bool mmux_libc_exit_success (void)
@deftypefunx bool mmux_libc_exit_failure (void)
Wrappers for @cfunc{mmux_libc_exit} that terminate the current process with, respectively, the
status @code{MMUX_LIBC_EXIT_SUCCESS} or @code{MMUX_LIBC_EXIT_FAILURE}.
@end deftypefun


@deftypefun bool mmux_libc__exit (mmux_libc_process_exit_status_t @var{status})
@MmuxCInterface{_exit}.
@end deftypefun


@deftypefun bool mmux_libc_atexit (void (* @var{function_pointer}) (void))
@MmuxCInterface{atexit}.
@end deftypefun

@c page
@node signals
@chapter Interprocess signals handling


@menu
* signals signals::             Representing interprocess signals.
* signals delivering::          Delivering interprocess signals.
* signals bub::                 Block/unblock interprocess signals handling.
* signals handling::            Other interprocess signals delivering methods.
@end menu

@c page
@node signals signals
@section Representing interprocess signals


@deftp {Opaque Struct Typedef} mmux_libc_interprocess_signal_t
Opaque data structure type representing an interprocess signal number.
@end deftp


@deftypefun bool mmux_libc_make_interprocess_signal (mmux_libc_interprocess_signal_t * @var{result_p}, mmux_sint_t @var{signal_number})
Build a new value of type @objtype{mmux_libc_interprocess_signal_t}.

@example
mmux_libc_interprocess_signal_t ipxsig;

if (mmux_libc_make_interprocess_signal(&ipxsig, MMUX_LIBC_SIGUSR1) @{
  ... /* this error happens only if @var{signal_number} is negative */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signal_equal (mmux_libc_interprocess_signal_t @vari{ipxsig}, mmux_libc_interprocess_signal_t @varii{ipxsig})
Return true if @vari{ipxsig} and  @varii{ipxsig} are equal.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_interprocess_signal_t         ipxsig;
mmux_usize_t                            required_nchars;

mmux_libc_make_interprocess_signal(&the_signal_number, MMUX_LIBC_SIGUSR1);

if (mmux_libc_interprocess_signal_sprint_size(&required_nchars, ipxsig) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_interprocess_signal_sprint(str, required_nchars, ipxsig) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_interprocess_signal_parse (mmux_libc_interprocess_signal_t * @var{ipxsig_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a
@objtype{mmux_libc_interprocess_signal_t} value; store the value in the location referenced by
@var{ipxsig_p}.  If an error occurs and @var{who} is not @cnull{}: print an error message to
@stderr{} using @var{who} as name of the entity that performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signal_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_interprocess_signal_t @var{ipxsig})
Determine the number of characters required to contain the string representation of @var{ipxsig} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signal_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_interprocess_signal_t @var{ipxsig})
Convert @var{ipxsig} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node signals delivering
@subsection Delivering interprocess signals


@deftypefun bool mmux_libc_raise (mmux_libc_interprocess_signal_t @var{ipxsignal})
@MmuxCInterface{raise}.

To deliver a signal to the calling process we do:

@example
mmux_libc_interprocess_signal_t         ipxsignal;

mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
if (mmux_libc_raise(ipxsignal)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_kill (mmux_libc_pid_t pid, mmux_libc_interprocess_signal_t @var{ipxsignal})
@MmuxCInterface{kill}.

To deliver the signal @samp{SIGUSR1} to a child process we do:

@example
bool                    this_is_the_parent_process;
mmux_libc_pid_t         child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  /* error */
@} else if (this_is_the_parent_process) @{
  mmux_libc_interprocess_signal_t         ipxsignal;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  if (mmux_libc_kill(child_pid, ipxsignal)) @{
    /* error */
  @}
@} else @{
  ... /* do something in the child process */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_kill_all_processes_in_same_group (mmux_libc_interprocess_signal_t @var{ipxsignal})
Call the C library function @cfunc{signal} setting the first argument to @samp{0}: it delivers the
signal to all the processes in the same group as the delivering process.
@end deftypefun


@deftypefun bool mmux_libc_kill_group (mmux_libc_gid_t @var{gid}, mmux_libc_interprocess_signal_t @var{ipxsignal})
Deliver the signal to all the processes in the group @var{gid}.
@end deftypefun


@deftypefun bool mmux_libc_kill_all_processes (mmux_libc_interprocess_signal_t @var{ipxsignal})
Call the C library function @cfunc{signal} setting the first argument to @samp{-1}: it delivers the
signal to ``all'' processes, see the documentation for details.  @glibcref{Signaling Another
Process, Signaling Another Process}.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_tgkill (mmux_libc_pid_t @var{pid}, mmux_libc_pid_t @var{tid}, mmux_libc_interprocess_signal_t @var{ipxsignal})
@MmuxCInterface{tgkill}.  Deliver the signal to thread @var{tid} belonging to the process @var{pid}.
@end deftypefn

@c page
@node signals bub
@subsection Block/unblock interprocess signals handling


@cindex @bub{} interprocess signals @api{}
@cindex @bub{} signals @api{}
@cindex Block/unblock interprocess signals @api{}
@cindex Interprocess signals, block/unblock @api{}
@cindex Signals, block/unblock @api{}


The block/unblock (@bub{}) @api{} is a simplified interface to detect the arrival of interprocess
signals; if it does not suit the application's model, we should just ignore it.  It is impossible to
use the @bub{} @api{} along with other interprocess signal @api{}s.  Here is a meaningless usage
example:

@example
if (mmux_libc_interprocess_signals_bub_init()) @{
  /* error */
@}

/* Deliver a signal to the calling process. */
@{
  mmux_libc_interprocess_signal_t       ipxsignal;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  if (mmux_libc_raise(ipxsignal)) @{
    /* error */
  @}
@}

/* Unblock all the signals, then block them again. */
if (mmux_libc_interprocess_signals_bub_acquire()) @{
  /* error */
@}

/* Check if the signal was delivered. */
@{
  mmux_libc_interprocess_signal_t       ipxsignal;
  bool                                  delivered;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  if (mmux_libc_interprocess_signals_bub_delivered(&result, ipxsignal)) @{
    /* error */
  @}
  if (delivered) @{
    /* react to the signal */
  @}
@}

if (mmux_libc_interprocess_signals_bub_final()) @{
  /* error */
@}
@end example


@deftypefun bool mmux_libc_interprocess_signals_bub_init (void)
Block all the signals and initialise the @bub{} interface.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signals_bub_final (void)
Set all the signal handlers to @code{SIG_IGN}, then unblock all the signals and finalise the @bub{}
interface.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signals_bub_acquire (void)
Unblock all the signals, then block them again.  This should allow all the pending signals to be
delivered to the process.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signals_bub_delivered (bool * @var{result_p}, mmux_libc_interprocess_signal_t @var{ipxsignal})
When successful: store @ctrue{} in the variable referenced by @var{result_p} if the signal
@var{ipxsignal} has been delivered at least once @strong{before} the last call to
@cfunc{mmux_libc_interprocess_signal_bub_acquire}.

Calling this function with @var{ipxsignal} clears the internal flag for this signal, so calling it
again without acquiring new signals always stores @false{} in the variable referenced by
@var{result_p}.
@end deftypefun

@c page
@node signals handling
@subsection Other interprocess signals delivering methods


@deftypefn {Function Type} bool mmux_libc_sighandler_t (mmux_sint_t @var{signum})
Type of functions to be used as interprocess signal handlers.
@end deftypefn


@deftypefun bool mmux_libc_retrieve_signal_handler_SIG_DFL (mmux_libc_sighandler_t ** @var{result_p})
@deftypefunx bool mmux_libc_retrieve_signal_handler_SIG_IGN (mmux_libc_sighandler_t ** @var{result_p})
@deftypefunx bool mmux_libc_retrieve_signal_handler_SIG_ERR (mmux_libc_sighandler_t ** @var{result_p})
Store in the variable referenced by @var{result_p} the corresponding signal handling action.

The value @samp{SIG_ERR} is a special value used by @cfunc{signal} to return error, but it is
provided in this @api{} for completeness.
@end deftypefun


@deftypefun bool mmux_libc_signal (mmux_libc_sighandler_t ** @var{result_p}, mmux_libc_interprocess_signal_t @var{ipxsignal}, mmux_libc_sighandler_t @var{action})
@MmuxCInterface{signal}.  When successful: store in the variable referenced by @var{result_p} the
action that was previously set for @var{ipxsignal}.

To set the default action for @samp{SIGUSR1} we do:

@example
@{
  mmux_libc_interprocess_signal_t       ipxsignal;
  mmux_libc_sighandler_t *              the_old_handler;
  mmux_libc_sighandler_t *              the_new_handler;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  mmux_libc_retrieve_signal_handler_SIG_DFL(&the_new_handler);
  if (mmux_libc_signal(&the_old_hadler, ipxsignal, the_new_handler)) @{
    /* error */
  @}
@}
@end example

To set a custom action for @samp{SIGUSR1} we do:

@example
static void
my_handler (mmux_sint_t signum)
@{
  ...
@}

@{
  mmux_libc_interprocess_signal_t       ipxsignal;
  mmux_libc_sighandler_t *              the_old_handler;

  mmux_libc_make_interprocess_signal(&ipxsignal, MMUX_LIBC_SIGUSR1);
  if (mmux_libc_signal(&the_old_handler, ipxsignal, my_handler)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pause (void)
@MmuxCInterface{pause}.  It is usually not useful to check the return value of @cfunc{pause}.
@end deftypefun

@c page
@node fds
@chapter File descriptors


@menu
* fds fds::                     File descriptors type.
* fds printing::                Printing formatted output.
* fds opening::                 Opening file descriptors.
* fds closing::                 Closing file descriptors.
* fds reading::                 Reading from file descriptors.
* fds writing::                 Writing to file descriptors.
* fds seeking::                 Seeking position in file descriptors.
* fds duplicating::             Duplicating file descriptors.
* fds piping::                  Opening file descriptor pipes.
* fds selecting::               Selecting file descriptors.
* fds scatter-gather::          Scatter--gather input and output.
* fds copying::                 Copying ranges from file to file.
* fds flock::                   File locks.
* fds fun control::             File descriptors functionality control.
* fds io control::              File descriptors input/output control.
* fds memfd::                   Memory-mapped file descriptors.
* fds predicates::              File predicates with file descriptors.
* fds attributes::              Inspecting file attributes through file descriptors.
@end menu

@c page
@node fds fds
@section File descriptors type


@deftp {Opaque Type} mmux_libc_file_descriptor_t
@deftpx {Opaque Type} mmux_libc_fd_t
Opaque type representing file descriptors.  It must be passed by value.
@end deftp


@deftypefun bool mmux_libc_stdin (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard input.
@end deftypefun


@deftypefun bool mmux_libc_stdou (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard output.
@end deftypefun


@deftypefun bool mmux_libc_stder (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard error.
@end deftypefun


@deftypefun bool mmux_libc_at_fdcwd (mmux_libc_file_descriptor_t * @var{result_p})
Return the file descriptor associated to the constant @code{AT_FDCWD}.  We can use it with
@cfunc{mmux_libc_openat} and similar functions.
@end deftypefun


@deftypefun bool mmux_libc_make_fd (mmux_libc_file_descriptor_t * @var{result_p}, mmux_sint_t @var{fd_num})
Make a new file descriptor value.
@end deftypefun


@deftypefun bool mmux_libc_fd_equal (mmux_libc_fd_t @vari{fd}, mmux_libc_fd_t @varii{fd})
Return @ctrue{} if @vari{fd} is equal to @varii{fd}; otherwise return @cfalse{}.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_fd_t  the_fd = gimme_an_fd();
mmux_usize_t    required_nchars;

if (mmux_libc_fd_sprint_size(&required_nchars, the_fd) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_fd_sprint(str, required_nchars, the_fd) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_fd_parse (mmux_libc_fd_t * @var{fd_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_fd_t}
value; store the value in the location referenced by @var{fd_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_fd_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_fd_t @var{fd})
Determine the number of characters required to contain the string representation of @var{fd} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_fd_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_fd_t @var{fd})
Convert @var{fd} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node fds printing
@section Printing formatted output


@deftypefun bool mmux_libc_dprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_asciizcp_t @var{template}, ...)
@deftypefunx bool mmux_libc_dprintfou (mmux_asciizcp_t template, ...)
@deftypefunx bool mmux_libc_dprintfer (mmux_asciizcp_t template, ...)
@MmuxCInterface{dprintf}.  Print the message to, respectively: @var{fd}, @stdout{}, @stderr{}.

To print to a file descriptor:

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
mmux_sint_t             flags = MMUX_LIBC_O_RDONLY;
mmux_mode_t             mode  = 0;

if (mmux_libc_make_file_system_pathname(&ptn, "./file.ext")) @{
  /* error */
@}

if (mmux_libc_open(&fd, ptn, flags, mode)) @{
  /* error */
@}

if (mmux_libc_dprintf(fd, "the number is %d\n", 123)) @{
  /* error */
@}
@end example

To print to @stdout{} and @stderr{}:

@example
if (mmux_libc_dprintfou("the number is %d\n", 123)) @{
  /* error */
@}
if (mmux_libc_dprintfer("the number is %d\n", 456)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_vdprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_asciizcp_t @var{template}, va_list @var{ap})
@deftypefunx bool mmux_libc_vdprintfou (mmux_asciizcp_t @var{template}, va_list @var{ap})
@deftypefunx bool mmux_libc_vdprintfer (mmux_asciizcp_t @var{template}, va_list @var{ap})
@MmuxCInterface{vdprintf}.  Print the message to, respectively: @var{fd}, @stdout{}, @stderr{}.
Notice that @file{stdarg.h} is already included by @value{PackageHeaderFile}.

@example
bool
my_print_error (mmux_asciizcp_t template, ...)
@{
  bool          rv;
  va_list       ap;

  va_start(ap, template);
  @{
    rv = mmux_libc_vdprintfer(template, ap);
  @}
  va_end(ap);
  return rv;
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_dprintf_newline (mmux_libc_file_descriptor_t @var{fd})
@deftypefunx bool mmux_libc_dprintfou_newline (void)
@deftypefunx bool mmux_libc_dprintfer_newline (void)
Print a single newline character to, respectively: @var{fd}, @stdout{}, @stderr{}.
@end deftypefun


@anchor{mmux_libc_dprintf_strerror}
@deftypefun bool mmux_libc_dprintf_strerror (mmux_libc_fd_t @var{fd}, mmux_sint_t @var{errnum})
Wrapper for @cfunc{mmux_libc_dprintf} that prints to @var{fd} the @asciiz{} string resulting from a
call to @cfunc{mmux_libc_strerror}.
@end deftypefun


@anchor{mmux_libc_dprintf_strftime}
@deftypefun bool mmux_libc_dprintf_strftime (mmux_libc_fd_t @var{fd}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{BT})
Wrapper for @cfunc{mmux_libc_printf} that prints to @var{fd} the timestamp representation of
@var{BT} formatted according to @var{template} using @cfunc{mmux_libc_strftime},
@ref{mmux_libc_strftime} for details.
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineTypePrinterFunc{STEM}
@deftypefun bool mmux_libc_dprintf_\STEM\ (mmux_libc_file_descriptor_t @var{fd}, mmux_\STEM\_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun

@end macro

@MmuxDefineTypePrinterFunc{pointer}

@MmuxDefineTypePrinterFunc{schar}
@MmuxDefineTypePrinterFunc{uchar}
@MmuxDefineTypePrinterFunc{sshort}
@MmuxDefineTypePrinterFunc{ushort}
@MmuxDefineTypePrinterFunc{sint}
@MmuxDefineTypePrinterFunc{uint}
@MmuxDefineTypePrinterFunc{slong}
@MmuxDefineTypePrinterFunc{ulong}
@MmuxDefineTypePrinterFunc{sllong}
@MmuxDefineTypePrinterFunc{ullong}

@MmuxDefineTypePrinterFunc{sint8}
@MmuxDefineTypePrinterFunc{uint8}
@MmuxDefineTypePrinterFunc{sint16}
@MmuxDefineTypePrinterFunc{uint16}
@MmuxDefineTypePrinterFunc{sint32}
@MmuxDefineTypePrinterFunc{uint32}
@MmuxDefineTypePrinterFunc{sint64}
@MmuxDefineTypePrinterFunc{uint64}

@MmuxDefineTypePrinterFunc{float}
@MmuxDefineTypePrinterFunc{double}
@MmuxDefineTypePrinterFunc{ldouble}

@MmuxDefineTypePrinterFunc{float32}
@MmuxDefineTypePrinterFunc{float64}
@MmuxDefineTypePrinterFunc{float128}

@MmuxDefineTypePrinterFunc{float32x}
@MmuxDefineTypePrinterFunc{float64x}
@MmuxDefineTypePrinterFunc{float128x}

@MmuxDefineTypePrinterFunc{decimal32}
@MmuxDefineTypePrinterFunc{decimal64}
@MmuxDefineTypePrinterFunc{decimal128}

@MmuxDefineTypePrinterFunc{complexf}
@MmuxDefineTypePrinterFunc{complexd}
@MmuxDefineTypePrinterFunc{complexld}

@MmuxDefineTypePrinterFunc{complexf32}
@MmuxDefineTypePrinterFunc{complexf64}
@MmuxDefineTypePrinterFunc{complexf128}

@MmuxDefineTypePrinterFunc{complexf32x}
@MmuxDefineTypePrinterFunc{complexf64x}
@MmuxDefineTypePrinterFunc{complexf128x}

@MmuxDefineTypePrinterFunc{complexd32}
@MmuxDefineTypePrinterFunc{complexd64}
@MmuxDefineTypePrinterFunc{complexd128}

@MmuxDefineTypePrinterFunc{usize}
@MmuxDefineTypePrinterFunc{ssize}

@MmuxDefineTypePrinterFunc{sintmax}
@MmuxDefineTypePrinterFunc{uintmax}
@MmuxDefineTypePrinterFunc{sintptr}
@MmuxDefineTypePrinterFunc{uintptr}
@MmuxDefineTypePrinterFunc{ptrdiff}
@MmuxDefineTypePrinterFunc{mode}
@MmuxDefineTypePrinterFunc{off}
@MmuxDefineTypePrinterFunc{pid}
@MmuxDefineTypePrinterFunc{uid}
@MmuxDefineTypePrinterFunc{gid}
@MmuxDefineTypePrinterFunc{wchar}
@MmuxDefineTypePrinterFunc{wint}
@MmuxDefineTypePrinterFunc{time}
@MmuxDefineTypePrinterFunc{socklen}
@MmuxDefineTypePrinterFunc{rlim}
@MmuxDefineTypePrinterFunc{ino}
@MmuxDefineTypePrinterFunc{dev}
@MmuxDefineTypePrinterFunc{nlink}
@MmuxDefineTypePrinterFunc{blkcnt}

@anchor{mmux_libc_dprintf_libc_fd}
@deftypefun bool mmux_libc_dprintf_libc_fd (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_file_descriptor_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_libc_pid}
@deftypefun bool mmux_libc_dprintf_libc_pid (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_pid_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_libc_uid}
@deftypefun bool mmux_libc_dprintf_libc_uid (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_uid_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_libc_gid}
@deftypefun bool mmux_libc_dprintf_libc_gid (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_gid_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_libc_ptn}
@deftypefun bool mmux_libc_dprintf_libc_ptn (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_file_system_pathname_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_libc_ptn_extension}
@deftypefun bool mmux_libc_dprintf_libc_ptn_extension (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_file_system_pathname_extension_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_libc_ptn_segment}
@deftypefun bool mmux_libc_dprintf_libc_ptn_segment (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_file_system_pathname_segment_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_libc_completed_process_status}
@deftypefun bool mmux_libc_dprintf_libc_completed_process_status (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_completed_process_status_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@anchor{mmux_libc_dprintf_libc_interprocess_signal}
@deftypefun bool mmux_libc_dprintf_libc_interprocess_signal (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_interprocess_signal_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun

@c page
@node fds opening
@section Opening file descriptors


@menu
* fds opening standard::        Standard file descriptor opening.
* fds opening extended::        Extended file descriptor opening.
@end menu

@c page
@node fds opening standard
@subsection Standard file descriptor opening


@deftypefun bool mmux_libc_open (mmux_libc_file_descriptor_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{flags}, mmux_mode_t @var{mode})
@MmuxCInterface{open}.

@example
mmux_libc_file_system_pathname_t pathname;
mmux_libc_file_descriptor_t      fd;

mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

if (mmux_libc_make_file_system_pathname(&pathname, "/path/to/file.ext")) @{
  /* error */
@}

if (mmux_libc_open(&fd, pathname, flags, mode)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_openat (mmux_libc_file_descriptor_t * @var{result_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{flags}, mmux_mode_t @var{mode})
@MmuxCInterface{openat}.

@example
mmux_libc_file_system_pathname_t pathname;
mmux_libc_file_descriptor_t      dirfd;
mmux_libc_file_descriptor_t      fd;

mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

if (mmux_libc_make_file_system_pathname(&pathname, "/path/to/file.ext")) @{
  /* error */
@}

mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_openat(&fd, dirfd, pathname, flags, mode)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds opening extended
@subsection Extended file descriptor opening


The function @cfunc{openat2} and the data structure @code{struct open_how} are system extensions
implemented by the Linux kernel.


@MmuxCStructOpaqueTypedef{open_how}


@MmuxSetterGetter{open_how, flags,   mmux_uint64_t}
@MmuxSetterGetter{open_how, mode,    mmux_uint64_t}
@MmuxSetterGetter{open_how, resolve, mmux_uint64_t}
@MmuxStructDumper{open_how}


To dump the contents of @code{mmux_libc_open_how_t} we can do:

@example
mmux_libc_file_descriptor_t     fder;
mmux_libc_open_how_t            open_how;

mmux_libc_memzero(&open_how, sizeof(mmux_libc_open_how_t));

mmux_libc_open_how_flags_set(&open_how, \
  MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);

mmux_libc_open_how_mode_set(&open_how, \
  MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

mmux_libc_open_how_resolve_set(&open_how, \
  MMUX_LIBC_RESOLVE_BENEATH               \
  | MMUX_LIBC_RESOLVE_NO_MAGICLINKS       \
  | MMUX_LIBC_RESOLVE_NO_SYMLINKS         \
  | MMUX_LIBC_RESOLVE_NO_XDEV);

mmux_libc_stder(&fder);
if (mmux_libc_open_how_dump(fder, &open_how, NULL)) @{
  /* error */
@}
@end example

@noindent
notice how the Linux kernel demands the data structure to be reset to zero before use; this code
prints:

@example
struct open_how = 0x7ffca7af5b80
struct open_how->flags = 194 (O_ACCMODE | O_CREAT | O_EXCL | O_RDWR)
struct open_how->mode = 384 (S_IRUSR | S_IRWXU | S_IWUSR)
struct open_how->resolve = 15 (RESOLVE_BENEATH | RESOLVE_NO_MAGICLINKS | RESOLVE_NO_SYMLINKS | RESOLVE_NO_XDEV)
@end example


@deftypefn {Linux Function} bool mmux_libc_openat2 (mmux_libc_file_descriptor_t * @var{fd}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_open_how_t const * const @var{how_p})
@MmuxCInterface{openat2}.

@example
mmux_libc_file_system_pathname_t      ptn;
mmux_libc_file_descriptor_t           dirfd;
mmux_libc_file_descriptor_t           fd;
mmux_libc_open_how_t                  open_how;

/* required by the Linux kernel */
mmux_libc_memzero(&open_how, sizeof(mmux_libc_open_how_t));

mmux_libc_open_how_flags_set(&open_how, \
  MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);

mmux_libc_open_how_mode_set(&open_how, \
  MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

mmux_libc_open_how_resolve_set(&open_how, \
  MMUX_LIBC_RESOLVE_BENEATH               \
  | MMUX_LIBC_RESOLVE_NO_MAGICLINKS       \
  | MMUX_LIBC_RESOLVE_NO_SYMLINKS         \
  | MMUX_LIBC_RESOLVE_NO_XDEV);

if (mmux_libc_make_file_system_pathname(&ptn, "./file.ext")) @{
  /* error */
@}

mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_openat2(&fd, dirfd, ptn, &open_how)) @{
  /* error */
@}
@end example
@end deftypefn

@c page
@node fds closing
@section Closing file descriptors


@deftypefun bool mmux_libc_close (mmux_libc_file_descriptor_t @var{fd})
@MmuxCInterface{close}.
@end deftypefun

@c page
@node fds reading
@section Reading from file descriptors


@deftypefun bool mmux_libc_read (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{read}.

@example
mmux_libc_file_descriptor_t     fd;
mmux_usize_t                    nbytes_done;
mmux_usize_t                    buflen = 4096;
mmux_uint8_t                    bufptr[buflen];

mmux_libc_stdin(&fd);
if (mmux_libc_read(&nbytes_done, fd, bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pread (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_off_t @var{offset})
@MmuxCInterface{pread}.
@end deftypefun

@c page
@node fds writing
@section Writing to file descriptors


@deftypefun bool mmux_libc_write (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{write}.

@example
mmux_libc_file_descriptor_t     fd;
mmux_usize_t                    nbytes_done;
mmux_usize_t                    buflen;
mmux_asciizcp_t                 bufptr = "ciao";

mmux_libc_strlen(&buflen, bufptr);
mmux_libc_stdou(&fd);
if (mmux_libc_write(&nbytes_done, fd, bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pwrite (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_off_t @var{offset})
@MmuxCInterface{pwrite}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_write_buffer (mmux_libc_file_descriptor_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@deftypefunx bool mmux_libc_write_buffer_to_stdou (mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@deftypefunx bool mmux_libc_write_buffer_to_stder (mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
Like @cfunc{mmux_libc_write}, but write a buffer to the file descriptor, respectively: @var{fd},
@stdout{}, @stderr{}.  If the number of written bytes equals @var{buflen}: return @cfalse{},
otherwise return @ctrue{}.

These functions exist mostly as tools in debugging code.

@example
mmux_usize_t    buflen;
mmux_uint8_t    bufptr[buflen];

if (mmux_libc_write_buffer_to_stdou(bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds seeking
@section Seeking position in file descriptors


@deftypefun bool mmux_libc_lseek (mmux_libc_file_descriptor_t @var{fd}, mmux_off_t * @var{offset_p}, mmux_sint_t @var{whence})
@MmuxCInterface{lseek}.

Upon calling this function: @var{offset_p} must reference a variable whose value represents the
offset from the position selected by @var{whence}.

Upon successfully returning from this function: the variable referenced by @var{offset_p} has been
updated to represent the resulting position, measured in bytes, from the beginning of the file.

@example
mmux_libc_fd_t  fd     = get_some_fd();
mmux_off_t      offset = 123;
mmux_sint_t     whence = MMUX_LIBC_SEEK_SET;

if (mmux_libc_lseek(fd, &offset, whence)) @{
  /* error */
@}

/* now "offset" has been updated */
@end example
@end deftypefun

@c page
@node fds duplicating
@section Duplicating file descriptors


@deftypefun bool mmux_libc_dup (mmux_libc_fd_t @var{new_fd}, mmux_libc_fd_arg_t @var{old_fd})
@MmuxCInterface{dup}.
@end deftypefun


@deftypefun bool mmux_libc_dup2 (mmux_libc_fd_arg_t @var{new_fd}, mmux_libc_fd_arg_t @var{old_fd})
@MmuxCInterface{dup2}.
@end deftypefun


@deftypefun bool mmux_libc_dup3 (mmux_libc_fd_arg_t @var{new_fd}, mmux_libc_fd_arg_t @var{old_fd}, mmux_sint_t @var{flags})
@MmuxCInterface{dup3}.

@example
mmux_asciizcp_t pathname = "/path/to/file.ext";
auto            flags    = mmux_libc_open_flags(MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);
auto            mode     = mmux_libc_mode(MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

mmux_libc_fd_t  fd1, fd2;

if (mmux_libc_open(fd1, pathname, flags, mode)) @{
  /* error */
@}

/* I'm so dirty. */
mmux_libc_make_fd(fd2, 5);

if (mmux_libc_dup3(fd2, fd1, mmux_libc_open_flags(MMUX_LIBC_O_CLOEXEC))) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds piping
@section Opening file descriptor pipes


@deftypefun bool mmux_libc_pipe (mmux_libc_file_descriptor_t @var{fds}[2])
@MmuxCInterface{pipe}.

@example
@{
  bool                this_is_the_paren_process;
  mmux_libc_pid_t     child_pid;
  mmux_libc_fd_t      paren_to_child_fds[2];
  mmux_libc_fd_t      paren_fr_child_fds[2];

  if        (mmux_libc_pipe(paren_to_child_fds)) @{
    ... /* error */
  @} else if (mmux_libc_pipe(paren_fr_child_fds)) @{
    ... /* error */
  @} else if (mmux_libc_fork(&this_is_the_paren_process, &child_pid)) @{
    ... /* error */
  @} else if (this_is_the_paren_process) @{
    paren_play(paren_fr_child_fds[0], paren_to_child_fds[1], child_pid);
  @} else @{
    child_play(paren_to_child_fds[0], paren_fr_child_fds[1]);
  @}
@}
void
paren_play (mmux_libc_fd_t read_fr_child_fd, mmux_libc_fd_t writ_to_child_fd, mmux_libc_pid_t child_pid)
@{
  ...
@}
void
child_play (mmux_libc_fd_t read_fr_paren_fd, mmux_libc_fd_t writ_to_paren_fd)
@{
  ...
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_close_pipe (mmux_libc_file_descriptor_t @var{fds}[2])
Close both the file descriptors in @var{fds}.  If both closures succeed: return @cfalse{}; otherwise
return @ctrue{}.  If closing the first fails: this function still closes the second.

This function might be useful when an error occurs after we have created a pipe.
@end deftypefun

@c page
@node fds selecting
@section Selecting file descriptors


Example:

@example
mmux_libc_fd_set_t      read_fd_set[1], writ_fd_set[1], exce_fd_set[1];
mmux_uint_t             nfds_ready;
mmux_uint_t             maximum_nfds_to_check = MMUX_LIBC_FD_SETSIZE;
mmux_libc_timeval_t     timeout[1];
mmux_libc_fd_t          in, ou;
bool                    isset;

mmux_libc_stdin(&in);
mmux_libc_stdou(&ou);

mmux_libc_FD_ZERO(read_fd_set);
mmux_libc_FD_ZERO(writ_fd_set);
mmux_libc_FD_ZERO(exce_fd_set);

mmux_libc_FD_SET(in, read_fd_set);
mmux_libc_FD_SET(ou, writ_fd_set);

mmux_libc_timeval_set(timeout, 1, 0);

if (mmux_libc_select(&nfds_ready, maximum_nfds_to_check,
                     read_fd_set, writ_fd_set, exce_fd_set,
                     timeout)) @{
  /* error */
@}

mmux_libc_FD_ISSET(&isset, in, read_fd_set);
if (isset) @{
  /* do something */
@}

mmux_libc_FD_ISSET(&isset, ou, writ_fd_set);
if (isset) @{
  /* do something */
@}

mmux_libc_FD_ISSET(&isset, in, exce_fd_set);
if (isset) @{
  /* do something */
@}
@end example


@deftypefun bool mmux_libc_FD_ZERO (mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_ZERO}.
@end deftypefun


@deftypefun bool mmux_libc_FD_SET (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_SET}.
@end deftypefun


@deftypefun bool mmux_libc_FD_CLR (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_CLR}.
@end deftypefun


@deftypefun bool mmux_libc_FD_ISSET (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t const * @var{fd_set_p})
@MmuxCInterface{FD_ISSET}.
@end deftypefun


@deftypefun bool mmux_libc_select (mmux_uint_t * @var{nfds_ready_p}, mmux_uint_t @var{maximum_nfds_to_check}, mmux_libc_fd_set_t * @var{read_fd_set_p}, mmux_libc_fd_set_t * @var{writ_fd_set_p}, mmux_libc_fd_set_t * @var{exce_fd_set_p}, mmux_libc_timeval_t * @var{timeout_p})
@MmuxCInterface{select}.

Each of the arguments @var{read_fd_set_p}, @var{writ_fd_set_p}, @var{exce_fd_set_p} can be @cnull{}
if we are not interested in selecting the corresponding events.

The argument @var{timeout_p} can be @cnull{} if we want to set a timeout of infinite time.

After a successful call: the variable referenced by @var{nfds_ready_p} is set to the number of file
descriptors that are ready for an action.

The argument @var{maximum_nfds_to_check} must represent the maximum number of file descriptors to
check for events: if we want to check up to file descriptor @samp{10}, we have to set
@var{maximum_nfds_to_check} to @samp{11}; it is usually just set to the constant
@code{MMUX_LIBC_FD_SETSIZE}.
@end deftypefun


@deftypefun bool mmux_libc_select_fd_for_reading (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timeval_t * @var{timeout_p})
@deftypefunx bool mmux_libc_select_fd_for_writing (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timeval_t * @var{timeout_p})
@deftypefunx bool mmux_libc_select_fd_for_exception (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timeval_t * @var{timeout_p})
Like @cfunc{mmux_libc_select}, but select a single event for a single file descriptor; if the file
descriptor is ready the variable referenced by @var{result_p} is set to @ctrue{}, otherwise it is
set to @cfalse{}.

@example
mmux_libc_fd_t  fd;
bool            is_ready;

gimme_an_fd(&fd);

if (mmux_libc_select_fd_for_reading(&is_ready, fd, NULL)) @{
  /* error */
@}
if (is_ready) @{
  /* the fd is ready for reading */
@}
@end example
@end deftypefun

@c page
@node fds scatter-gather
@section Scatter--gather input and output


@menu
* fds scatter-gather buffer::   The input/output buffer data structure.
* fds scatter-gather array::    The input/output array data structure.
* fds scatter-gather reading::  Reading with the input/output vector programming interface.
* fds scatter-gather writing::  Writing with the input/output vector programming interface.
@end menu

@c page
@node fds scatter-gather buffer
@subsection The input/output buffer data structure


Data to be read from or written to a file descriptor using the scatter--gather facilities must be
stored in multiple buffers; a single buffer of data is represented by the data structure
@objtype{mmux_libc_iovec_t}.  To instantiate and inspect such data structure we do:

@example
mmux_usize_t const      bufnum = 16;
mmux_usize_t const      buflen = 4096;
mmux_octet_t            bufptr[bufnum][buflen];
mmux_libc_iovec_t       iov[bufnum];

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_iovec_dump(fd, &(iov[0]), NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
this code dumps to @stdout{} a string representation of a single @objtype{mmux_libc_iovec_t}:

@example
struct iovec = 0x7ffe8c4309d0
struct iovec->iov_base = 0x7ffe8c4209c0
struct iovec->iov_len = 4096
@end example


@MmuxCStructOpaqueTypedef{iovec}


@MmuxSetterGetter{iovec, iov_base, mmux_pointer_t}
@MmuxSetterGetter{iovec, iov_len,  mmux_usize_t}
@MmuxStructDumper{iovec}

@c page
@node fds scatter-gather array
@subsection The input/output array data structure


Data to be read from or written to a file descriptor using the scatter--gather facilities must be
stored in multiple buffers; an array of these buffers is represented by the data structure
@objtype{mmux_libc_iovec_array_t}.  To instantiate and inspect such data structure we do:

@example
mmux_usize_t const      bufnum = 16;
mmux_usize_t const      buflen = 4096;
mmux_octet_t            bufptr[bufnum][buflen];
mmux_libc_iovec_t       iov[bufnum];
mmux_libc_iovec_array_t iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_iovec_array_dump(fd, &iova, NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
this code dumps to @stdout{} a string representation of a single @objtype{mmux_libc_iovec_array_t}:

@example
mmux_libc_iovec_array_t = 0x7ffcd9306550
mmux_libc_iovec_array_t->iova_base = 0x7ffcd9306560
mmux_libc_iovec_array_t->iova_len = 4
mmux_libc_iovec_array_t->iova_base[0] = 0x7ffcd9306560
mmux_libc_iovec_array_t->iova_base[0]->iov_base = 0x7ffcd9302540
mmux_libc_iovec_array_t->iova_base[0]->iov_len = 4096
mmux_libc_iovec_array_t->iova_base[1] = 0x7ffcd9306570
mmux_libc_iovec_array_t->iova_base[1]->iov_base = 0x7ffcd9303540
mmux_libc_iovec_array_t->iova_base[1]->iov_len = 4096
mmux_libc_iovec_array_t->iova_base[2] = 0x7ffcd9306580
mmux_libc_iovec_array_t->iova_base[2]->iov_base = 0x7ffcd9304540
mmux_libc_iovec_array_t->iova_base[2]->iov_len = 4096
mmux_libc_iovec_array_t->iova_base[3] = 0x7ffcd9306590
mmux_libc_iovec_array_t->iova_base[3]->iov_base = 0x7ffcd9305540
mmux_libc_iovec_array_t->iova_base[3]->iov_len = 4096
@end example


@deftp {Opaque Struct Typedef} mmux_libc_iovec_array_t
Data structure type representing an array of @objtype{mmux_libc_iovec_t} data structures.  It has
the following fields:

@table @code
@item mmux_libc_iovec_t * iova_base
Pointer to an array of @objtype{mmux_libc_iovec_t} data structures.

@item mmux_usize_t iova_len
Number of items in the array referenced by @code{iova_base}.
@end table
@end deftp


@MmuxSetterGetter{iovec_array, iova_base, mmux_libc_iovec_t *}
@MmuxSetterGetter{iovec_array, iova_len,  mmux_usize_t}
@MmuxStructDumperTwo{iovec_array, mmux_libc_iovec_array_t}

@c page
@node fds scatter-gather reading
@subsection Reading with the input/output vector programming interface


@deftypefun bool mmux_libc_readv (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p})
@MmuxCInterface{readv}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

/* Perform the reading. */
@{
  mmux_usize_t      nbytes_done;

  if (mmux_libc_readv(&nbytes_done, mfd, &iova)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_preadv (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset})
@MmuxCInterface{preadv}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

/* Perform the reading. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;

  if (mmux_libc_preadv(&nbytes_done, mfd, &iova, offset)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_preadv2 (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset}, mmux_sint_t @var{flags})
@MmuxCInterface{preadv2}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

/* Perform the reading. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;
  mmux_sint_t   flags  = MMUX_LIBC_RWF_HIPRI;

  if (mmux_libc_preadv2(&nbytes_done, mfd, &iova, offset, flags)) @{
    /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fds scatter-gather writing
@subsection Writing with the input/output vector programming interface


@deftypefun bool mmux_libc_writev (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p})
@MmuxCInterface{writev}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

fill_buffers(iova);

/* Perform the writing. */
@{
  mmux_usize_t      nbytes_done;

  if (mmux_libc_writev(&nbytes_done, mfd, &iova)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pwritev (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset})
@MmuxCInterface{pwritev}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

fill_buffers(iova);

/* Perform the writing. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;

  if (mmux_libc_pwritev(&nbytes_done, mfd, &iova, offset)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_pwritev2 (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t * @var{iova_p}, mmux_off_t @var{offset}, mmux_sint_t @var{flags})
@MmuxCInterface{pwritev2}.

@example
mmux_usize_t const          bufnum = 4;
mmux_usize_t const          buflen = 8;
mmux_octet_t                bufptr[bufnum][buflen];
mmux_libc_iovec_t           iov[bufnum];
mmux_libc_iovec_array_t     iova;

for (mmux_uint_t i=0; i<bufnum; ++i) @{
  mmux_libc_iov_len_set  (&(iov[i]), buflen);
  mmux_libc_iov_base_set (&(iov[i]), &(bufptr[i][0]));
@}

mmux_libc_iova_len_set  (&iova, bufnum);
mmux_libc_iova_base_set (&iova, iov);

fill_buffers(iova);

/* Perform the writing. */
@{
  mmux_usize_t  nbytes_done;
  mmux_off_t    offset = 0;
  mmux_sint_t   flags  = MMUX_LIBC_RWF_HIPRI;

  if (mmux_libc_pwritev2(&nbytes_done, mfd, &iova, offset, flags)) @{
    /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fds copying
@section Copying ranges from file to file


@deftypefun bool mmux_libc_copy_file_range (mmux_usize_t * @var{number_of_bytes_copied_p}, mmux_libc_file_descriptor_t @var{input_fd}, mmux_sint64_t * @var{input_position_p}, mmux_libc_file_descriptor_t @var{ouput_fd}, mmux_sint64_t * @var{ouput_position_p}, mmux_usize_t @var{number_of_bytes_to_copy}, mmux_sint_t @var{flags})
@MmuxCInterface{copy_file_range}.
@end deftypefun


Here is an example to understand the mechanics of the function call:

@example
mmux_libc_file_descriptor_t     src_fd;
mmux_libc_file_descriptor_t     dst_fd;

/* Open the source and destination files. */
@{
  mmux_libc_file_system_pathname_t    src_ptn;
  mmux_libc_file_system_pathname_t    dst_ptn;
  mmux_sint_t  flags = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
  mmux_mode_t  mode  = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

  if (mmux_libc_make_file_system_pathname(&src_ptn, "source.ext")) @{
    /* error */
  @}
  if (mmux_libc_open(&src_fd, src_ptn, flags, mode)) @{
    /* error */
  @}

  if (mmux_libc_make_file_system_pathname(&dst_ptn, "destination.ext")) @{
    /* error */
  @}

  if (mmux_libc_open(&dst_fd, dst_ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Write data to the source file. */
@{
  mmux_usize_t        nbytes_done;
  //                            01234567890123456789012345678901234567890
  //                            0         1         2         3         4
  mmux_asciizcp_t     bufptr = "0123456789abcdefghilmnopqrstuvz0123456789";
  mmux_usize_t        buflen;

  mmux_libc_strlen(&buflen, bufptr);

  if (mmux_libc_write(&nbytes_done, src_fd, bufptr, buflen)) @{
    /* error */
  @}
  if (nbytes_done != buflen) @{
    /* it is an error for our purposes */
  @}
@}

/* Copy the alpha range of data "abcdefghilmnopqrstuvz" from the source
   file to the destination file. */
@{
  mmux_usize_t        nbytes_done;
  mmux_sint64_t       src_position = 10;
  mmux_sint64_t       dst_position = 0;
  mmux_usize_t        number_of_bytes_to_copy = 21;
  mmux_sint_t         flags = 0;

  if (mmux_libc_copy_file_range(&nbytes_done,
                                src_fd, &src_position,
                                dst_fd, &dst_position,
                                number_of_bytes_to_copy, flags)) @{
    /* error */
  @}
@}

if (mmux_libc_close(src_fd)) @{
  /* error */
@}
if (mmux_libc_close(dst_fd)) @{
  /* error */
@}
@end example

If we need to copy data between file descriptors, and we cannot use
@cfunc{mmux_libc_copy_file_range}, we can adapt the following code template:

@example
mmux_libc_fd_t                  infd, oufd;

static mmux_usize_t const       read_buflen = 1024;
mmux_octet_t                    read_bufptr[read_buflen];
mmux_usize_t                    nbytes_read;

gimme_an_input_fd(&infd);
gimme_an_ouput_fd(&oufd);

/* Loop reading while the number of bytes read is positive. */
do @{
  if (mmux_libc_read(&nbytes_read, infd, read_bufptr, read_buflen)) @{
    /* error */
  @}

  if (nbytes_read > 0) @{
    mmux_octet_t *  write_bufptr    = read_bufptr;
    mmux_usize_t    write_buflen    = nbytes_read;
    mmux_usize_t    nbytes_written  = 0;

    /* Loop writing until we have written all the bytes from the buffer. */
    do @{
      if (mmux_libc_write(&nbytes_written, oufd, write_bufptr, write_buflen)) @{
        /* error */
      @}

      if (nbytes_written < write_buflen) @{
        write_bufptr += nbytes_written;
        write_buflen -= nbytes_written;
      @}
    @} while (nbytes_written < write_buflen);
  @}
@} while (nbytes_read > 0);
@end example

@c page
@node fds flock
@section File locks


Data structures of type @objtype{mmux_libc_flock_t} are used to describe a file lock in some calls
to @cfunc{mmux_libc_fcntl}.  To declare and inspect such data structures we do:

@example
mmux_libc_flock_t     flo;
mmux_libc_pid_t       pid;

mmux_libc_make_pid_zero(&pid); /* should not fail */

mmux_libc_l_type_set   (&flo, MMUX_LIBC_F_RDLCK);
mmux_libc_l_whence_set (&flo, MMUX_LIBC_SEEK_SET);
mmux_libc_l_start_set  (&flo, 11);
mmux_libc_l_len_set    (&flo, 33);
mmux_libc_l_pid_set    (&flo, pid);

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_flock_dump(fd, &flo, NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
which will print:

@example
struct flock = "0x7ffcf5d55170"
struct flock.l_type = "0" (F_RDLCK)
struct flock.l_whence = "0" (SEEK_SET)
struct flock.l_start = "11"
struct flock.l_len = "33"
struct flock.l_pid = "0"
@end example


@MmuxCStructOpaqueTypedef{flock}
@MmuxSetterGetter{flock, l_type,   mmux_sshort_t}
@MmuxSetterGetter{flock, l_whence, mmux_sshort_t}
@MmuxSetterGetter{flock, l_start,  mmux_off_t}
@MmuxSetterGetter{flock, l_len,    mmux_off_t}
@MmuxSetterGetter{flock, l_pid,    mmux_libc_pid_t}
@MmuxStructDumper{flock}

@deftypefun bool mmux_libc_flag_to_symbol_struct_flock_l_type (mmux_asciizcp_t* @var{str_p}, mmux_sshort_t @var{flag})
Identify @var{flag} as a value for the field @code{l_type} of @objtype{mmux_libc_flock_t}; store in
the variable referenced by @var{str_p} a pointer to a statically allocated @asciiz{} string
representing the name of the value.
@end deftypefun

@c page
@node fds fun control
@section File descriptors functionality control


@deftypefun bool mmux_libc_fcntl (mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{command}, mmux_pointer_t @var{parameter_p})
@MmuxCInterface{fcntl}.  Arguments:

@table @var
@item fd
A file descriptor.

@item command
A constant representing a command for @cfunc{fcntl}.

@item parameter_p
Pointer to a variable representing a parameter that can be input or output depending on the
@var{command}.
@end table
@end deftypefun


@deftypefun bool mmux_libc_fcntl_command_flag_to_symbol (mmux_asciizcp_t* @var{str_p}, mmux_sint_t @var{command})
Identify @var{command} as a command argument for @cfunc{mmux_libc_fcntl}; store in the variable
referenced by @var{str_p} a pointer to a statically allocated @asciiz{} string representing a string
representation of the @var{command}.
@end deftypefun

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_DUPFD
Duplicate a file descriptor; @var{parameter_p} must reference a variable of type
@objtype{mmux_libc_file_descriptor_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETFD
Get file descriptor flags, like @samp{MMUX_LIBC_FD_CLOEXEC}; @var{parameter_p} must reference a variable
of type @objtype{mmux_sint_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETFD
Set file descriptor flags, like @samp{MMUX_LIBC_FD_CLOEXEC}; @var{parameter_p} must reference a variable
of type @objtype{mmux_sint_t} holding a bitwise OR combination of flags.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETFL
Get open file descriptor flags, like @samp{O_RDWR}; @var{parameter_p} must reference a variable of
type @objtype{mmux_sint_t}.

To set blocking mode for a file descriptor we do:

@example
mmux_libc_fd_t  fd;
mmux_sint_t     parameter;

/* Acquire current file descriptor flags. */
if (mmux_libc_fcntl(in, MMUX_LIBC_F_GETFL, &parameter)) @{
  /* error */
@}

/* Null the non-block flag. */
parameter &= (~ MMUX_LIBC_O_NONBLOCK);

/* Set the new flags. */
if (mmux_libc_fcntl(in, MMUX_LIBC_F_SETFL, &parameter)) @{
  /* error */
@}
@end example
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETFL
Set open file descriptor flags, like @samp{O_APPEND}; @var{parameter_p} must reference a variable of
type @objtype{mmux_sint_t} holding a bitwise OR combination of flags.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETLK
Get a @MmuxCStruct{flock} describing a lock that blocks a requested lock; @var{parameter_p} must
reference a value of type @objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETLK
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETLKW
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_GETLK
Get a @MmuxCStruct{flock} describing a lock that blocks a requested lock; @var{parameter_p} must
reference a value of type @objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_SETLK
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_SETLKW
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETOWN
Get the process or group id that receives the signal @samp{SIGIO}; @var{parameter_p} must reference
a variable of type @objtype{mmux_libc_pid_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETOWN
Set the process or group id that receives the signal @samp{SIGIO}; @var{parameter_p} must reference
a variable of type @objtype{mmux_libc_pid_t}.
@end defvr

@c page
@node fds io control
@section File descriptors input/output control


@deftypefun bool mmux_libc_ioctl (mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{command}, mmux_pointer_t @var{parameter_p})
@MmuxCInterface{ioctl}.  Arguments:

@table @var
@item fd
A file descriptor.

@item command
A constant representing a command for @cfunc{ioctl}.

@item parameter_p
Pointer to a variable representing a parameter that can be input or output depending on the
@var{command}.
@end table
@end deftypefun

@c ------------------------------------------------------------------------

@defvr {Iontl Command} MMUX_LIBC_SIOCATMARK
Detect if the data received through a socket has reached the mark; @var{parameter_p} must reference
a variable of type @objtype{mmux_sint_t}.
@end defvr

@c page
@node fds memfd
@section Memory--mapped file descriptors


@cindex Memory--mapped file descriptors
@cindex Memfds


Memory--mapped file descriptors (memfds for short) are constructed by @cfunc{memfd_create},
@MmuxCFuncpage{memfd_create}.  The device underlying a memfd exists only in memory, but we can apply
to it almost all the functions acting upon file descriptors.

@menu
* fds memfd intro::             Introduction to memfds and usage examples.
* fds memfd makers::            Constructing memfds.
* fds memfd inspect::           Inspecting memfds.
* fds memfd reading::           Special reading operations upon memfds.
* fds memfd writing::           Special writing operations upon memfds.
* fds memfd copying::           Special copying operations upon memfds.
@end menu

@c page
@node fds memfd intro
@subsection Introduction to memfds and usage examples


To use a memory--mapped file descriptor, we do:

@example
mmux_libc_fd_t  mfd;

if (mmux_libc_make_memfd(&mfd)) @{
  /* error */
@}
@{
  /* Write something. */
  if (mmux_libc_dprintf(mfd, "The value is %d.\n", 123)) @{
    /* error */
  @}

  @{
    mmux_double_t       rep = 1.2;
    mmux_double_t       imp = 3.4;
    mmux_complexd_t     Z;

    Z = mmux_complexd_make_rectangular(rep, imp);
    mmux_complexd_dprintf(mfd, Z);
  @}

  /* Copy the data to stdout. */
  if (mmux_libc_memfd_copyou(mfd)) @{
    /* error */
  @}
@}
if (mmux_libc_close(mfd)) @{
  /* error */
@}
@end example

@noindent
we can apply to a memfd almost all the functions that act upon ordinary file descriptors.

We need to remember to appropriately shift the input/output position of the underlying device with
@cfunc{mmux_libc_lseek}.  If we need to shift the position, do something, and then restore the
position to its original value, we do:

@example
mmux_libc_fd_t  mfd = ...;
mmux_off_t      position = 0; /* new position with respect to MMUX_LIBC_SEEK_SET */

/* Save the current position then seek to the beginning. */
if (mmux_libc_lseek(mfd, &position, MMUX_LIBC_SEEK_SET)) @{
  /* error */
@}

/* do something with mfd */

/* Restore the original position. */
if (mmux_libc_lseek(mfd, &position, MMUX_LIBC_SEEK_SET)) @{
  /* error */
@}
@end example

@noindent
also we can use @cfunc{mmux_libc_pread} and @cfunc{mmux_libc_pwrite} to read from and write to a
position from the beginning of the underlying device.

@c page
@node fds memfd makers
@subsection Constructing memfds


The core constructor for a memfd is @cfunc{mmux_libc_make_memfd}; we should always pair a call to it
with a call to @cfunc{mmux_libc_close}, which acts as destructor:

@example
mmux_libc_fd_t  mfd;

if (mmux_libc_make_memfd(&mfd)) @{
  /* error */
@}

@{
  /* do something with "mfd" */
@}

if (mmux_libc_close(mfd)) @{
  /* error */
@}
@end example


@deftypefun bool mmux_libc_make_memfd (mmux_libc_file_descriptor_t * @var{mfd_p})
Create a new file descriptor whose underlying device is mapped into ordinary memory; store the
resulting file descriptor in the variable referenced by @var{mfd_p}.
@end deftypefun

@c page
@node fds memfd inspect
@subsection Inspecting memfds


To acquire the number of bytes in the device underlying a memfd, we do:

@example
mmux_libc_fd_t  mfd;
mmux_usize_t    buflen;

if (mmux_libc_memfd_length(&buflen, mfd)) @{
  /* error */
@}
@end example

@noindent
this operation should not fail.

If the data in the device is to be interpreted as an @mmuxascii{} string, we can allocate a buffer
to contain it as @asciiz{} string as follows:

@example
mmux_libc_fd_t  mfd;
mmux_usize_t    buflen;

if (mmux_libc_memfd_length(&buflen, mfd)) @{
  /* error */
@}

@{
  mmux_char_t   bufptr[1+buflen];

  bufptr[buflen] = '\0';
  ...
@}
@end example


@deftypefun bool mmux_libc_memfd_length (mmux_usize_t * @var{len_p}, mmux_libc_file_descriptor_t @var{mfd})
Store in the variable referenced by @var{len_p} the number of bytes in the device underlying
@var{mfd}.
@end deftypefun

@c page
@node fds memfd reading
@subsection Special reading operations upon memfds


Applying the basic reading operation using @cfunc{mmux_libc_read} to a memfd, looks like this:

@example
mmux_usize_t    buflen = 4094;
mmux_octet_t *  bufptr[buflen];

mmux_libc_fd_t  mfd;
mmux_usize_t    nbytes_done;

gimme_a_memfd(&mfd);

if (mmux_libc_read(&nbytes_done, mfd, bufptr, buflen)) @{
  /* error */
@}
@end example

@noindent
this is quite verbose, and the read operation should not fail if the destination buffer is wide
enough.  So the following functions are implemented.

If the data in the device underlying the memfd is to be considered as an @mmuxascii{} string, we can
copy it into an external buffer as follows:

@example
mmux_usize_t    buflen;

if (mmux_libc_memfd_length(&buflen, mfd)) @{
  /* error */
@} else @{
  mmux_char_t   bufptr[1+buflen];

  bufptr[buflen] = '\0';
  if (mmux_libc_memfd_read_buffer(mfd, bufptr, buflen)) @{
    /* error */
  @}
  ...
@}
@end example

@noindent
we take advantage of the fact that we know the data size.


@deftypefun bool mmux_libc_memfd_read_buffer (mmux_libc_fd_t @var{mfd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{maximum_buflen})
Wrapper for @cfunc{mmux_libc_read}.  Copy up to @var{maximum_buflen} bytes from the device
underlying @var{mfd} to the buffer referenced by @var{bufptr}.
@end deftypefun

@c page
@node fds memfd writing
@subsection Special writing operations upon memfds


Applying the basic writing operation using @cfunc{mmux_libc_write} to a memfd, looks like this:

@example
mmux_usize_t    buflen = 4094;
mmux_octet_t *  bufptr[buflen];

mmux_libc_fd_t  mfd;
mmux_usize_t    nbytes_done;

fill_buffer(bufptr, buflen);
gimme_a_memfd(&mfd);

if (mmux_libc_write(&nbytes_done, mfd, bufptr, buflen)) @{
  /* error */
@}
@end example

@noindent
this is quite verbose, but we need to remember that the write operation could fail if there is not
enough memory available to enlarge the underlying device.  Anyway, the following functions are
implemented.


@deftypefun bool mmux_libc_memfd_write_buffer (mmux_libc_file_descriptor_t @var{mfd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
Write @var{buflen} bytes from the buffer @var{bufptr} into the device underlying @var{mfd}, at the
current position.  The return value is @ctrue{} if less than @var{buflen} bytes are written to
@var{mfd}.
@end deftypefun


@deftypefun bool mmux_libc_memfd_write_asciiz (mmux_libc_file_descriptor_t @var{mfd}, mmux_asciizcp_t @var{bufptr})
Write the @asciiz{} string referenced by @var{bufptr} into the device underlying @var{mfd}, at the
current position.  The return value is @ctrue{} if less than the whole string is written to
@var{mfd}.
@end deftypefun


@anchor{mmux_libc_memfd_strerror}
@deftypefun bool mmux_libc_memfd_strerror (mmux_libc_file_descriptor_t @var{mfd}, mmux_sint_t @var{errnum})
Write to @var{mfd}, at the current position for the underlying device, the error string associated
to @var{errnum} and retrieved using @cfunc{mmux_libc_strerror}.  The return value is @ctrue{} if
less than the whole error message is written to @var{mfd}.
@end deftypefun

@c page
@node fds memfd copying
@subsection Special copying operations upon memfds


@deftypefun bool mmux_libc_memfd_copy (mmux_libc_file_descriptor_t @var{oufd}, mmux_libc_file_descriptor_t @var{mfd})
Copy all the data in the device underlying @var{mfd} to the file descriptor @var{oufd}.

This function ignores the current device position, writing all the data from the beginning to the
end of the underlying device.  When successful: the current device position is restored to the
original value, so it is left unchanged.  If an error occurs: the underlying device position is
undefined.

@strong{NOTE} It appears the memfds cannot be used with @cfunc{mmux_libc_copy_file_range}.
@end deftypefun


@deftypefun bool mmux_libc_memfd_copyou (mmux_libc_file_descriptor_t @var{mfd})
@deftypefunx bool mmux_libc_memfd_copyer (mmux_libc_file_descriptor_t @var{mfd})
Wrappers for @cfunc{mmux_libc_memfd_copy} that write the underlying device contents to, respectively:
@stdout{}, @stderr{}.
@end deftypefun

@c page
@node fds predicates
@section File predicates with file descriptors


@deftypefun bool mmux_libc_file_descriptor_is_regular (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
regular file; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_regular;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_regular(&the_fd_is_regular, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_symlink (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
symbolic link; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_symlink;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_symlink(&the_fd_is_symlink, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_directory (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
directory; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_directory;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_directory(&the_fd_is_directory, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_character_special (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
character special device; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_character_special;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_character_special(&the_fd_is_character_special, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_block_special (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a block
special device; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_block_special;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_block_special(&the_fd_is_block_special, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_fifo (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a FIFO;
otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_fifo;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_fifo(&the_fd_is_fifo, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_descriptor_is_socket (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Store @ctrue{} in the variable referenced by @var{result_p} if the given file descriptor is a
socket; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
bool                    the_fd_is_socket;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_file_descriptor_is_socket(&the_fd_is_socket, ptn)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds attributes
@section Inspecting file attributes through file descriptors


The functions documented in this section retrieve the value of some fields from
@objtype{mmux_libc_stat_t} objects embedding the call to the standard @cfunc{stat} function and its
variants; true control about the resulting values is possible only by explicitly selecting which
@cfunc{stat} variant to call and which arguments to use in the function invocation.  But the
following functions are simpler and sometimes they are enough.


@deftypefun bool mmux_libc_file_descriptor_file_size_ref (mmux_usize_t * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Invoke @cfunc{mmux_libc_fstat} and retrieve the @code{st_size} field value of the resulting
@objtype{mmux_libc_stat_t}.  Store such field value in the variable referenced by @var{result_p},
casting the @objtype{mmux_off_t} value to @objtype{mmux_usize_t}.

@example
mmux_libc_file_system_pathname_t        ptn;
mmux_libc_file_descriptor_t             dirfd;
mmux_libc_file_descriptor_t             fd;
mmux_sint_t                             flags = MMUX_LIBC_O_RDWR;
mmux_mode_t                             mode  = 0;
mmux_usize_t                            size;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_openat(&fd, dirfd, ptn, flags, mode) @{
  /* error */
@} else if (mmux_libc_file_descriptor_file_size_ref(&size, fd)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs
@chapter File system


@menu
* fs pathnames::                File system pathnames type definition.
* fs directories::              File system directories.
* fs links::                    Hard and symbolic links.
* fs deleting::                 Deleting links.
* fs renaming::                 Renaming links.
* fs ownership::                File ownership.
* fs permissions::              File access permissions.
* fs attributes::               File attributes.
* fs truncating::               Truncating files.
* fs times::                    File system times.
@end menu

@c page
@node fs pathnames
@section File system pathnames type definition


@menu
* fs pathnames intro::          Introduction to file system pathnames.
* fs pathnames pathnames::      File system full pathnames.
* fs pathnames extensions::     Extensions of file system pathnames.
* fs pathnames segments::       Extensions of file system pathnames.
* fs pathnames examples::       Usage examples for file system pathnames.
@end menu

@c page
@node fs pathnames intro
@subsection Introduction to file system pathnames


A @dfn{file system pathname} is an array of octets terminated by a zero octet, to be interpreted as
@asciiz{} string; file system pathnames are naturally interpreted as representing a tree in the
hierarchy of file systems.  By convention: we consider the bytes in a file system pathname as
unsigned characters, so we refer to them as @dfn{octets}; even though their type, according to the
Unix standards, is @code{char} which does not specify if they are signed or unsigned.  In this
package a file system pathname is represented by the object type
@objtype{mmux_libc_file_system_pathname_t}.

For security and efficiency reasons: the constructors of the
@objtype{mmux_libc_file_system_pathname_t} object type enforce the arbitrary pathname length limit
of @math{4095} octets plus the terminating zero octet; in total, @math{4096} octets.

Most pathnames are composed of @dfn{segments} separated by the slash character @file{/}, examples:

@example
/path/to/file.ext
/path/to/directory/
./path/to/file.ext
/path/to/.dotfile
file.ext
@end example

@noindent
the segments of @file{/path/to/file.ext} are the three strings:

@example
path
to
file.ext
@end example

@noindent
the ``first segment'' is the leftmost segment @samp{path}; the ``last segment'' is the rightmost
segment @samp{file.ext}.  In this package a file system pathname segment is represented by the
object type @objtype{mmux_libc_file_system_package_segment_t}.

By convention, in the rightmost segment of a pathname: if there is a trailing sequence of octets
beginning with a dot character, such sequence is called @dfn{extension}; the extension of
@samp{file.ext} is @samp{.ext} and it includes the dot; the extension is defined only if it follows
other octets, so @file{.dotfile} has empty extension.  In this package a file system pathname
extension is represented by the object type @objtype{mmux_libc_file_system_pathname_extension_t}.

Some file system pathnames are ``special directories'':

@table @file
@item /
the root directory, the top of the tree for file system pathnames; it has no segments; it has no
extension;

@item .
the current directory; it has the single segment @samp{.}; it has no extension;

@item ..
the uplevel directory from the current directory; it has the single segment @samp{..}; it has no
extension.
@end table

When a file system pathname is @strong{not} a special directory:

@itemize
@item
if the file system pathname ends with a slash character: by convention it represents a directory;

@item
if the file system pathname does @strong{not} end with a slash character: it can represent both a
directory or a file.
@end itemize

When a file system pathname begins with a slash character: it is an @dfn{absolute} pathname.
Otherwise it is a @dfn{relative pathname} to be interpreted as child of the current working
directory in the hierarchy of file systems.

The syntax of file system pathnames allows some freedom, which pushes us to ``normalise'' a pathname
to simplify it and to make it more amenable to processing; examples:

@table @code
@item ///... -> /
a sequence of slash characters can be normalised to a single slash;

@item /./ -> /
a sequence slash, dot, slash can be normalised to a slash;

@item segment/..
a sequence segment, slash, double dot can be normalised to the empty string;

@item ./segment -> segment
a sequence dot, slash, segment can be normalised to the segment.
@end table

@c page
@node fs pathnames pathnames
@subsection File system full pathnames


@menu
* fs pathnames pathnames types::          File system pathname types.
* fs pathnames pathnames constructors::   Building file system pathnames.
* fs pathnames pathnames inspection::     Inspecting file system pathnames.
* fs pathnames pathnames comparison::     Comparing file system pathnames.
* fs pathnames pathnames predicates::     Predicates on file system pathnames.
* fs pathnames pathnames components::     Components of file system pathnames.
* fs pathnames pathnames normalisation::  Components of file system pathnames.
* fs pathnames pathnames operations::     Operations on file system pathnames.
@end menu

@c page
@node fs pathnames pathnames types
@subsubsection File system pathname types


@deftp {Struct Typedef} mmux_libc_file_system_pathname_t
@deftpx {Struct Typedef} mmux_libc_ptn_t
Data type representing a file system pathname as a non--@cnull{} pointer to non--empty @asciiz{}
string.  It has a single field:

@table @code
@item mmux_asciizcp_t value
Pointer to the first octet in the array of octets.
@end table
@end deftp

@c page
@node fs pathnames pathnames constructors
@subsubsection Building file system pathnames


@deftypefun bool mmux_libc_make_file_system_pathname (mmux_libc_file_system_pathname_t * @var{result_p}, mmux_asciizcp_t @var{ptn_asciiz})
Make a new file system pathname value; the pointer @var{ptn_asciiz} is stored in the data
structure referenced by @var{result_p}.  The @asciiz{} string @var{ptn_asciiz} is validated:

@enumerate
@item
@var{ptn_asciiz} itself must not be @cnull{};

@item
the string length must not be zero: the first character must not be null.
@end enumerate

@example
mmux_asciizcp_t         ptn_asciiz = "/path/to/file.ext";
mmux_libc_ptn_t         ptn;

if (mmux_libc_make_file_system_pathname(&ptn, ptn_asciiz)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname_malloc (mmux_libc_file_system_pathname_t * @var{result_p}, mmux_asciizcp_t @var{ptn_asciiz})
Make a new file system pathname value by allocating memory with @cfunc{mmux_libc_malloc} and copying
the given pathname.

@example
mmux_asciizcp_t         ptn_asciiz = "/path/to/file.ext";
mmux_libc_ptn_t         ptn;

if (mmux_libc_make_file_system_pathname_malloc(&ptn, ptn_asciiz)) @{
  /* error */
@}
@{
  ...
@}
if (mmux_libc_file_system_pathname_free(ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname_malloc_from_buffer (mmux_libc_file_system_pathname_t * @var{result_p}, mmux_asciizcp_t @var{bufptr}, mmux_usize_t @var{buflen})
Make a new file system pathname value by allocating memory with @cfunc{mmux_libc_malloc} and copying
@var{buflen} octets from the given buffer referenced by @var{bufptr}.

The argument @var{buflen} must @strong{not} include the terminating zero octet, but this function
will allocate enough octets for the buffer and the terminating zero and it will set to zero the
terminating octet.

@example
//                                  012345678
mmux_asciizcp_t         bufptr[] = "/path/to/file.ext";
mmux_usize_t            buflen   = 8;
mmux_libc_ptn_t         ptn;

if (mmux_libc_make_file_system_pathname_malloc_from_buffer(&ptn, bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_free (mmux_libc_file_system_pathname_t @var{pathname})
Release the memory holding the pathname as @asciiz{} string using @cfunc{mmux_libc_free}.
@end deftypefun

@c page
@node fs pathnames pathnames inspection
@subsubsection Inspecting file system pathnames


@deftypefun bool mmux_libc_file_system_pathname_ptr_ref (mmux_asciizcp_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store in the variable referenced by @var{result_p} a pointer to the first octet in the array
representing the file system pathname.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_len_ref (mmux_usize_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store in the variable referenced by @var{result_p} the number of characters in the pathname
@var{ptn}.  A call to this function should never fail, so we can avoid checking its return value.

@example
mmux_asciizcp_t         ptn_asciiz = "/path/to/file.ext";
mmux_libc_ptn_t         ptn;

if (mmux_libc_make_file_system_pathname(&ptn, ptn_asciiz)) @{
  /* error */
@} else @{
  mmux_usize_t          len;

  mmux_libc_file_system_pathname_len_ref(&len, ptn);
  ...
@}
@end example
@end deftypefun

@c page
@node fs pathnames pathnames comparison
@subsubsection Comparing file system pathnames


@deftypefun bool mmux_libc_file_system_pathname_compare (mmux_sint_t * @var{result_p}, mmux_libc_file_system_pathname_t @vari{ptn}, mmux_libc_file_system_pathname_t @varii{ptn})
Compare the @asciiz{} strings of two file system pathnames using @cfunc{mmux_libc_strcmp}, store the
result in the variable referenced by @var{result_p}.

@example
mmux_libc_ptn_t         ptn1, ptn2;
mmux_sint_t             cmpnum;

mmux_libc_make_file_system_pathname(&ptn1, "AAA");
mmux_libc_make_file_system_pathname(&ptn2, "BBB");

if (mmux_libc_file_system_pathname_compare(&cmpnum, ptn1, ptn2)) @{
  /* error */
@}
assert(-1 == cmpnum);

if (mmux_libc_file_system_pathname_compare(&cmpnum, ptn2, ptn1)) @{
  /* error */
@}
assert(+1 == cmpnum);
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_equal (bool * result_p, mmux_libc_file_system_pathname_t @vari{ptn}, mmux_libc_file_system_pathname_t @varii{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the two given pathnames are equal
when compared as @asciiz{} strings; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    eq;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

if (mmux_libc_file_system_pathname_compare(&eq, ptn, ptn)) @{
  /* error */
@}
assert(true == eq);
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_not_equal (bool * result_p, mmux_libc_file_system_pathname_t @vari{ptn}, mmux_libc_file_system_pathname_t @varii{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the two given pathnames are different
when compared as @asciiz{} strings; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_less (bool * result_p, mmux_libc_file_system_pathname_t @vari{ptn}, mmux_libc_file_system_pathname_t @varii{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @samp{@vari{ptn} < @varii{ptn}} when
compared as @asciiz{} strings; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_greater (bool * result_p, mmux_libc_file_system_pathname_t @vari{ptn}, mmux_libc_file_system_pathname_t @varii{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @samp{@vari{ptn} > @varii{ptn}} when
compared as @asciiz{} strings; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_less_equal (bool * result_p, mmux_libc_file_system_pathname_t @vari{ptn}, mmux_libc_file_system_pathname_t @varii{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @samp{@vari{ptn} <= @varii{ptn}} when
compared as @asciiz{} strings; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_greater_equal (bool * result_p, mmux_libc_file_system_pathname_t @vari{ptn}, mmux_libc_file_system_pathname_t @varii{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @samp{@vari{ptn} >= @varii{ptn}} when
compared as @asciiz{} strings; otherwise store @cfalse{}.
@end deftypefun

@c page
@node fs pathnames pathnames predicates
@subsubsection Predicates on file system pathnames


The following predicates work best when applied to file system pathnames that have been previously
normalised, either with @cfunc{mmux_libc_make_file_system_pathname_normalised} or
@cfunc{mmux_libc_realpath} and similar functions.


@deftypefun bool mmux_libc_file_system_pathname_is_standalone_dot (bool * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{ptn} is a standalone dot
(@file{.} or @file{/path/to/.}); otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    result;

mmux_libc_file_system_pathname_is_standalone_dot(&result, ptn);
if (result) @{
  ...
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_standalone_double_dot (bool * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{ptn} is a standalone double dot
(@file{..} or @file{/path/to/..}); otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_standalone_slash (bool * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{ptn} is a standalone slash
(@file{/}); otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_special_directory (bool * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{ptn} is on among: a standalone
slash, a standalone dot, a standalone double dot; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_absolute (bool * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the first octet in @var{ptn}
@strong{does} represent an @mmuxascii{} slash @samp{/}; otherwise store @cfalse{}.  If the first
octet represents an @mmuxascii{} slash: the process of finding the file corresponding to @var{ptn} on
the file system, @strong{does not} depend on the current working directory.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_relative (bool * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the first octet in @var{ptn}
@strong{does not} represent an @mmuxascii{} slash @samp{/}; otherwise store @cfalse{}.  If the first
octet does not represent an @mmuxascii{} slash: the process of finding the file corresponding to
@var{ptn} on the file system, @strong{does} depend on the current working directory.
@end deftypefun

@c page
@node fs pathnames pathnames components
@subsubsection Components of file system pathnames


@deftypefun bool mmux_libc_make_file_system_pathname_rootname (mmux_libc_ptn_t * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Build a new file system pathname representing the rootname of @var{ptn}; store in the variable
referenced by @var{result_p} the new pathname object.  The @dfn{rootname} of a file system pathname
is the whole pathname with the extension stripped:

@example
/path/to/file.ext       @result{} /path/to/file
/path/to/file           @result{} /path/to/file
/path/to/dir/           @result{} /path/to/dir
file.ext                @result{} file.ext
.fvwmrc                 @result{} .fvwmrc
.                       @error{} invalid argument
..                      @error{} invalid argument
/                       @error{} invalid argument
@end example

@noindent
if @var{ptn} is the root directory @file{/}, a standalone dot @file{.} or @file{/path/to/.}, a
standalone double dot @file{..} or @file{/path/to/..}, then the function call fails: @code{errno} is
set to @code{MMUX_LIBC_EINVAL} and the return value is true.

The memory required to contain the rootname is allocated with @cfunc{mmux_libc_malloc}, to it must
be released later with @cfunc{mmux_libc_file_system_pathname_free}.

@example
mmux_libc_ptn_t         ptn, root_ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@} else if (mmux_libc_make_file_system_pathname_rootname(&root_ptn, ptn)) @{
  /* error */
@} else @{
  ...
  mmux_libc_file_system_pathname_free(root_ptn);
@}
@end example

The main purpose of extracting the rootname from a pathname is to create a file pathname from a
another file pathname by changing the extension, for example to build @file{/path/to/file.o} from
@file{/path/to/file.c}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_make_file_system_pathname_dirname (mmux_libc_ptn_t * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Build a new file system pathname representing the dirname of @var{ptn}; store in the variable
referenced by @var{result_p} the new pathname object.  The @dfn{dirname} of a file system pathname
is its directory part; if the pathname is itself a directory: its dirname is the full pathname
itself.

@example
/path/to/file.ext       @result{} /path/to/
file.ext                @result{} .
/path/to/dir/           @result{} /path/to/dir/
/path/to/.              @result{} /path/to/
/path/to/..             @result{} /path/to/..
.                       @result{} .
..                      @result{} ..
/                       @result{} /
@end example

The memory required to contain the dirname is allocated with @cfunc{mmux_libc_malloc}, to it must be
released later with @cfunc{mmux_libc_file_system_pathname_free}.

@example
mmux_libc_ptn_t         ptn, dir_ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@} else if (mmux_libc_make_file_system_pathname_dirname(&dir_ptn, ptn)) @{
  /* error */
@} else @{
  ...
  mmux_libc_file_system_pathname_free(dir_ptn);
@}
@end example

The main purpose of extracting the dirname from a pathname is to create a file pathname from a
another file pathname by changing the filename, for example to build @file{/path/to/other.ext} from
@file{/path/to/some.ext}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_make_file_system_pathname_tailname (mmux_libc_ptn_t * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Build a new file system pathname representing the tailname of @var{ptn}; store in the variable
referenced by @var{result_p} the new pathname object.  The @dfn{tailname} of a file system pathname
is the last segment of the input pathname:

@example
/path/to/file.ext       @result{} file.ext
/path/to/dir/           @result{} dir
file.ext                @result{} file.ext
.                       @result{} .
..                      @result{} ..
/                       @result{} /
@end example

The memory required to contain the tailname is allocated with @cfunc{mmux_libc_malloc}, to it must
be released later with @cfunc{mmux_libc_file_system_pathname_free}.

@example
mmux_libc_ptn_t         ptn, tail_ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@} else if (mmux_libc_make_file_system_pathname_tailname(&tail_ptn, ptn)) @{
  /* error */
@} else @{
  ...
  mmux_libc_file_system_pathname_free(tail_ptn);
@}
@end example

The main purpose of extracting the tailname from a pathname is to create a pathname from a another
pathname using the same last segment, for example to build @file{/path/to/this} from
@file{/path/from/that}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_make_file_system_pathname_filename (mmux_libc_ptn_t * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Build a new file system pathname representing the filename of @var{ptn}; store in the variable
referenced by @var{result_p} the new pathname object.  The @dfn{filename} of a file system pathname
is the relative pathname representing the last segment of the input pathname, if it does not
represent a directory:

@example
/path/to/file.ext       @result{} file.ext
file.ext                @result{} file.ext
/path/to/dir/           @error{}  invalid argument
.                       @error{}  invalid argument
..                      @error{}  invalid argument
/                       @error{}  invalid argument
@end example

@noindent
if @var{ptn} represents a directory, then the function call fails: @code{errno} is set to
@code{MMUX_LIBC_EINVAL} and the return value is true.

The memory required to contain the filename is allocated with @cfunc{mmux_libc_malloc}, to it must
be released later with @cfunc{mmux_libc_file_system_pathname_free}.

@example
mmux_libc_ptn_t         ptn, file_ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@} else if (mmux_libc_make_file_system_pathname_filename(&file_ptn, ptn)) @{
  /* error */
@} else @{
  ...
  mmux_libc_file_system_pathname_free(file_ptn);
@}
@end example

The main purpose of extracting the filename from a pathname is to create a pathname from a another
pathname using the same filename, for example to build @file{/path/to/file.ext} from
@file{/path/from/file.ext}.
@end deftypefun

@c page
@node fs pathnames pathnames normalisation
@subsubsection Components of file system pathnames


@cindex Normalising file system pathnames
@cindex File system pathnames, normalisation


A @dfn{normalised} file system pathname: has no multiple slashes; has no useless terminating slash;
has no useless single--dot components; has the double--dot components removed as much as possible.
Examples:

@example
/                               @result{} /
file.ext                        @result{} file.ext
/path/to/file.ext               @result{} /path/to/file.ext
//                              @result{} /
/path///to///file.ext           @result{} /path/to/file.ext
/path/to/dir/                   @result{} /path/to/dir/
/path/to/././file.ext           @result{} /path/to/file.ext
/path/to/.                      @result{} /path/to
/path/to/../file.ext            @result{} /path/file.ext
/path/to/../../this/file.ext    @result{} /this/file.ext
path/../../../file.ext          @result{} ../../file.ext
./path/../../../file.ext        @result{} ../../file.ext
.                               @result{} .
..                              @result{} ..
./                              @result{} .
../                             @result{} ..
/.                              @result{} /
/..                             @error{} invalid pathname
/path/../..                     @error{} invalid pathname
@end example

Most of the times we want to normalise a pathname before using it with this package.


@deftypefun bool mmux_libc_make_file_system_pathname_normalised (mmux_libc_ptn_t * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Make a new file system pathname value normalising the pathname @var{ptn}; the new pathname has
memory allocated with @cfunc{mmux_libc_malloc}.

@example
mmux_libc_ptn_t         ptn, normal_ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path///to/.//.//file.ext")) @{
  /* error */
@} else if (mmux_libc_make_file_system_pathname_normalised(&normal_ptn, ptn) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs pathnames pathnames operations
@subsubsection Operations on file system pathnames


@deftypefun bool mmux_libc_make_file_system_pathname_concat (mmux_libc_ptn_t * @var{result_p}, mmux_libc_ptn_t @var{prefix}, mmux_libc_ptn_t @var{suffix})
Make a new file system pathname by concatenating the @var{prefix} with the @var{suffix}; the new
pathname has memory allocated with @cfunc{mmux_libc_malloc}.  The new pathname is normalised using
@cfunc{mmux_libc_make_file_system_pathname_normalised}.

Examples of concatenation:

@example
/path/to   +   file.ext     @result{} /path/to/file.ext
/path/to/  +   file.ext     @result{} /path/to/file.ext
/path/to   +   /file.ext    @result{} /path/to/file.ext
@end example

@noindent
the slash separator between prefix and suffix is inserted if needed.

@example
mmux_libc_file_system_pathname_t      prefix_ptn, suffix_ptn, result_ptn;

if        (mmux_libc_make_file_system_pathname(&prefix_ptn, "/path/to")) @{
  /* error */
@} else if (mmux_libc_make_file_system_pathname(&suffix_ptn, "this/file.ext")) @{
  /* error */
@} else if (mmux_libc_make_file_system_pathname_concat(&result_ptn, prefix_ptn, suffix_ptn)) @{
 printf_error("concatenating pathname prefix '%s' suffix '%s'", prefix_ptn_asciiz, suffix_ptn_asciiz);
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs pathnames extensions
@subsection Extensions of file system pathnames


Given that a file system pathname is an array of octets terminated by a zero octet, to be interpreted
as @asciiz{} string: a file system pathname extension is also an array of octets to be interpreted an
@mmuxascii{} string, but it is @strong{not} necessarily terminated by a zero octet.

Examples defining what a file system pathname extension is:

@example
/path/to/file.ext               @result{} .ext
/path/to/file                   @result{} <empty>
/path/to/file.                  @result{} .
/path/to/file-1.2.3.ext         @result{} .ext
/path/to/.dotfile.ext           @result{} .ext
/path/to/.dotfile               @result{} <empty>
/path/to/directory.d/           @result{} .d
/                               @error{} <invalid pathname>
.                               @error{} <invalid pathname>
..                              @error{} <invalid pathname>
/path/to/.                      @error{} <invalid pathname>
/path/to/..                     @error{} <invalid pathname>
@end example

Under @value{PACKAGE}: file system pathname extensions are represented with objects of type
@objtype{mmux_libc_file_system_pathname_extension_t}.  Some constructors of this object attempt to
determine the extension of the last portion of a file system pathname even when such pathname is not
normalised; it is the responsibility of the caller to make sure that the pathname can be parsed in
such a way that the correct extension is determined.

@menu
* fs pathnames extensions types::               Data types representing file names extensions.
* fs pathnames extensions inspection::          File system pathname extensions inspection.
* fs pathnames extensions constructors::        Building file system pathname extensions.
* fs pathnames extensions comparison::          Comparing file system pathname extensions.
* fs pathnames extensions predicates::          Predicates for file system pathname extensions.
@end menu

@c page
@node fs pathnames extensions types
@subsubsection Data types representing file names extensions


@deftp {Struct Typedef} mmux_libc_file_system_pathname_extension_t
@deftpx {Struct Typedef} mmux_libc_ptn_extension_t
Data structure representing a file system pathname extension.  Sometimes it is meant to be
associated to an object of type @objtype{mmux_libc_file_system_pathname_t} with which, usually, it
shares memory.

It has two fields:

@table @code
@item mmux_asciizcp_t ptr
Pointer to the first octet in the file pathname extension.  It cannot be @cnull{}: if this object
represents the empty extension, this field must reference the null character at the end of the
pathname.

@item mmux_usize_t len
Number of octets in the file pathname extension.  It can be zero if the associated pathname has
empty extension.
@end table

In a correctly built @objtype{mmux_libc_file_system_pathname_extension_t} object, the following
expression is true:

@example
(NULL != ptr)                           \
&& ('\0' == ptr[0]   || '.' == ptr[0])  \
&& ('\0' == ptr[len] || '/' == ptr[len])
@end example
@end deftp

@c page
@node fs pathnames extensions inspection
@subsubsection File system pathname extensions inspection


@deftypefun bool mmux_libc_file_system_pathname_extension_ptr_ref (mmux_asciizcpp_t @var{result_p}, mmux_libc_file_system_pathname_extension_t @var{ext})
Accessor for the field @code{ptr} of @var{E}.

@example
mmux_libc_ptn_t                 ptn;
mmux_libc_ptn_extension_t       ext;
mmux_asciizcp_t                 ptr;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

if (mmux_libc_make_file_system_pathname_extension(&ext, ptn)) @{
  /* error */
@}

mmux_libc_file_system_pathname_extension_ptr_ref(&ptr, ext);
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_len_ref (mmux_usize_t * @var{result_p}, mmux_libc_file_system_pathname_extension_t @var{ext})
Accessor for the field @code{len} of @var{E}.

@example
mmux_libc_ptn_t                 ptn;
mmux_libc_ptn_extension_t       ext;
mmux_usize_t                    len;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

if (mmux_libc_make_file_system_pathname_extension(&ext, ptn)) @{
  /* error */
@}

mmux_libc_file_system_pathname_extension_len_ref(&len, ext);
@end example
@end deftypefun

@c page
@node fs pathnames extensions constructors
@subsubsection Building file system pathnames extensions


@deftypefun bool mmux_libc_make_file_system_pathname_extension (mmux_libc_ptn_extension_t * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Build an already allocated @objtype{mmux_libc_file_system_pathname_extension_t} object from a file
system pathname object.  The resulting extension object shares memory with the pathname object.

If the pathname is a special directory (@file{/} or @file{.} or @file{..} or @file{/path/to/.} or
@file{/path/to/..}): this function sets @code{errno} to @samp{MMUX_LIBC_EINVAL}, then returns true.

@example
mmux_asciizcp_t                 ptn_asciiz = "/path/to/file.ext";
mmux_libc_ptn_t                 ptn;
mmux_libc_ptn_extension_t       ext;

if (mmux_libc_make_file_system_pathname(&ptn, ptn_asciiz)) @{
  /* error */
@}

if (mmux_libc_make_file_system_pathname_extension(&ext, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname_extension_raw (mmux_libc_ptn_extension_t * @var{result_p}, mmux_asciizcp_t ptr, mmux_usize_t @var{len})
Build an already allocated @objtype{mmux_libc_file_system_pathname_extension_t} object from raw
values.

@example
//                                            012345678901234567
//                                                         ^
mmux_asciizcp_t                 ptn_asciiz = "/path/to/file.ext";
mmux_libc_ptn_t                 ptn;
mmux_libc_ptn_extension_t       ext;

if (mmux_libc_make_file_system_pathname(&ptn, ptn_asciiz)) @{
  /* error */
@}

if (mmux_libc_make_file_system_pathname_extension_raw(&ext, ptn_asciiz + 13, 3)) @{
  /* error */
@}
@end example

For a pathname that has no extension:

@example
//                                            01234567890123
//                                                         ^
mmux_asciizcp_t                 ptn_asciiz = "/path/to/file";
mmux_libc_ptn_extension_t       ext;

if (mmux_libc_make_file_system_pathname(&ptn, ptn_asciiz)) @{
  /* error */
@}

if (mmux_libc_make_file_system_pathname_extension_raw(&ext, ptn_asciiz + 13, 0)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname_extension_raw_asciiz (mmux_libc_ptn_extension_t * @var{result_p}, mmux_asciizcp_t @var{ptr})
Build an already allocated file system pathname extension from the raw pointer to an @asciiz{}
string.

@example
mmux_libc_file_system_pathname_extension_t      ext;

if (mmux_libc_make_file_system_pathname_extension_raw_asciiz(&ext, ".ext")) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs pathnames extensions comparison
@subsubsection Comparing file system pathname extensions


@deftypefun bool mmux_libc_file_system_pathname_extension_compare (mmux_sint_t * @var{result_p}, mmux_libc_ptn_extension_t @vari{ext}, mmux_libc_ptn_extension_t @varii{ext})
Compare two extensions and store in the variable referenced by @var{result_p} the value:

@table @code
@item 0
when @code{@vari{ext} == @varii{ext}};
@item -1
when @code{@vari{ext} < @varii{ext}};
@item +1
when @code{@vari{ext} > @varii{ext}};
@end table

The file system pathname extensions are compared as strings, using the standard @cfunc{strncmp}:

@itemize
@item
if the extensions have the same length, @cfunc{strncmp} is applied to the whole strings;

@item
if the extensions have different length, @cfunc{strncmp} is applied to portion of the strings of
maximum common length; if these substrings are equal: the shortest is considered less than the
longest.
@end itemize
@end deftypefun


For all the functions below the comparison is performed using
@cfunc{mmux_libc_file_system_pathname_extension_compare}.


@deftypefun bool mmux_libc_file_system_pathname_extension_equal (bool * @var{result_p}, mmux_libc_ptn_extension_t @vari{ext}, mmux_libc_ptn_extension_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} == @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_not_equal (bool * @var{result_p}, mmux_libc_ptn_extension_t @vari{ext}, mmux_libc_ptn_extension_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} != @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_less (bool * @var{result_p}, mmux_libc_ptn_extension_t @vari{ext}, mmux_libc_ptn_extension_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} < @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_greater (bool * @var{result_p}, mmux_libc_ptn_extension_t @vari{ext}, mmux_libc_ptn_extension_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} > @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_less_equal (bool * @var{result_p}, mmux_libc_ptn_extension_t @vari{ext}, mmux_libc_ptn_extension_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} <= @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_extension_greater_equal (bool * @var{result_p}, mmux_libc_ptn_extension_t @vari{ext}, mmux_libc_ptn_extension_t @varii{ext})
Compare the file system pathname extensions and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} >= @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun

@c page
@node fs pathnames extensions predicates
@subsubsection Predicates for file system pathname extensions


@deftypefun bool mmux_libc_file_system_pathname_extension_is_empty (bool * @var{result_p}, mmux_libc_ptn_extension_t @var{ext})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{ext} represents the empty file
system pathname extension; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t                 ptn;
mmux_libc_ptn_extension_t       ext;
bool                            is_empty;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

if (mmux_libc_make_file_system_pathname_extension(&ext, ptn)) @{
  /* error */
@}

mmux_libc_file_system_pathname_extension_is_empty(&is_empty, ext);
if (is_empty) @{
  ...
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_has_extension (bool * @var{result_p}, mmux_libc_ptn_t @var{ptn}, mmux_libc_ptn_extension_t @var{ext})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{ptn} has extension @var{ext};
otherwise store @cfalse{}.

@example
mmux_libc_file_system_pathname_t              ptn;
mmux_libc_file_system_pathname_extension_t    ext;
bool                                          ptn_has_extension_ext;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}
if (mmux_libc_make_file_system_pathname_extension_raw_asciiz(&ext, ".ext")) @{
  /* error */
@}
mmux_libc_file_system_pathname_has_extension(&ptn_has_extension_ext, ptn, ext);
if (ptn_has_extension_ext) @{
   /* it has */
@} else @{
   /* it has not */
@}
@end example
@end deftypefun

@c page
@node fs pathnames segments
@subsection Extensions of file system pathnames


Given the file system pathname:

@example
/path/to/file.ext
@end example

@noindent
the segments are the strings:

@example
path
to
file.ext
@end example

@noindent
notice that the slash separators are @strong{excluded}.  There is a special case: if the pathname is
a single @samp{/} character, its only segment is a single @samp{/} character.  File system pathname
segments cannot be empty strings.

Given that a file system pathname is an array of octets terminated by a zero octet, to be
interpreted as @asciiz{} string: a file system pathname segment is also an array of octets to be
interpreted an @mmuxascii{} string, but it is @strong{not} necessarily terminated by a zero octet.

Under @value{PACKAGE}: file system pathname segments are represented with objects of type
@objtype{mmux_libc_file_system_pathname_segment_t}.  Some constructors of this object attempt to
determine the segments of a file system pathname even when such pathname is not normalised; it is
the responsibility of the caller to make sure that the pathname can be parsed in such a way that the
correct segment is determined.

@menu
* fs pathnames segments types::               Data types representing file system pathname segments.
* fs pathnames segments inspection::          File system pathname segments inspection.
* fs pathnames segments constructors::        Building file system pathname segments.
* fs pathnames segments comparison::          Comparing file system pathname segments.
* fs pathnames segments predicates::          Predicates on file system pathname segments.
@end menu

@c page
@node fs pathnames segments types
@subsubsection Data types representing file system pathname segments


@deftp {Struct Typedef} mmux_libc_file_system_pathname_segment_t
@deftpx {Struct Typedef} mmux_libc_ptn_segment_t
Data structure representing a file system pathname segment.  Sometimes it is meant to be
associated to an object of type @objtype{mmux_libc_file_system_pathname_t} with which, usually, it
shares memory.

It has two fields:

@table @code
@item mmux_asciizcp_t ptr
Pointer to the first octet in the file pathname segment.  It cannot be @cnull{}: if this object
represents the empty segment, this field must reference the null character at the end of the
pathname.

@item mmux_usize_t len
Number of octets in the file pathname segment.  It can be zero if the associated pathname has
empty segment.
@end table

In a correctly built @objtype{mmux_libc_file_system_pathname_segment_t} object, the following
expression is true:

@example
(NULL != ptr)                           \
&& ('\0' == ptr[0]   || '.' == ptr[0])  \
&& ('\0' == ptr[len] || '/' == ptr[len])
@end example
@end deftp

@c page
@node fs pathnames segments inspection
@subsubsection File system pathname segments inspection


@deftypefun bool mmux_libc_file_system_pathname_segment_ptr_ref (mmux_asciizcpp_t @var{result_p}, mmux_libc_file_system_pathname_segment_t @var{seg})
Accessor for the field @code{ptr} of @var{E}.

@example
mmux_libc_ptn_t                 ptn;
mmux_libc_ptn_segment_t         seg;
mmux_asciizcp_t                 ptr;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

if (mmux_libc_make_file_system_pathname_segment(&seg, ptn)) @{
  /* error */
@}

mmux_libc_file_system_pathname_segment_ptr_ref(&ptr, seg);
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_len_ref (mmux_usize_t * @var{result_p}, mmux_libc_file_system_pathname_segment_t @var{seg})
Accessor for the field @code{len} of @var{E}.

@example
mmux_libc_ptn_t                 ptn;
mmux_libc_ptn_segment_t         seg;
mmux_usize_t                    len;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

if (mmux_libc_make_file_system_pathname_segment(&seg, ptn)) @{
  /* error */
@}

mmux_libc_file_system_pathname_segment_len_ref(&len, seg);
@end example
@end deftypefun

@c page
@node fs pathnames segments constructors
@subsubsection Building file system pathnames segments


@deftypefun bool mmux_libc_make_file_system_pathname_segment_raw (mmux_libc_ptn_segment_t * @var{result_p}, mmux_asciizcp_t ptr, mmux_usize_t @var{len})
Build an already allocated @objtype{mmux_libc_file_system_pathname_segment_t} object from raw
values.

@example
//                                            012345678901234567
//                                                     ^
mmux_asciizcp_t                 ptn_asciiz = "/path/to/file.ext";
mmux_libc_ptn_segment_t         seg;

if (mmux_libc_make_file_system_pathname_segment_raw(&seg, ptn_asciiz + 9, 8)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_make_file_system_pathname_segment_raw_asciiz (mmux_libc_ptn_segment_t * @var{result_p}, mmux_asciizcp_t @var{ptr})
Build an already allocated file system pathname segment from the raw pointer to an @asciiz{} string.

@example
mmux_libc_file_system_pathname_segment_t        seg;

if (mmux_libc_make_file_system_pathname_segment_raw_asciiz(&seg, "file.ext")) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_find_last (mmux_libc_ptn_segment_t * @var{result_p}, mmux_libc_ptn_t @var{ptn})
Build an already allocated file system pathname segment representing the last segment in a given
file system pathname.

@example
mmux_libc_ptn_t                 ptn;
mmux_libc_ptn_segment_t         seg;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

if (mmux_libc_file_system_pathname_segment_find_last(&seg, ptn)) @{
  /* error */
@}

/* Here "seg" references the segment "file.ext". */
@end example
@end deftypefun

@c page
@node fs pathnames segments comparison
@subsubsection Comparing file system pathname segments


@deftypefun bool mmux_libc_file_system_pathname_segment_compare (mmux_sint_t * @var{result_p}, mmux_libc_ptn_segment_t @vari{ext}, mmux_libc_ptn_segment_t @varii{ext})
Compare two segments and store in the variable referenced by @var{result_p} the value:

@table @code
@item 0
when @code{@vari{ext} == @varii{ext}};
@item -1
when @code{@vari{ext} < @varii{ext}};
@item +1
when @code{@vari{ext} > @varii{ext}};
@end table

The file system pathname segments are compared as strings, using the standard @cfunc{strncmp}:

@itemize
@item
if the segments have the same length, @cfunc{strncmp} is applied to the whole strings;

@item
if the segments have different length, @cfunc{strncmp} is applied to portion of the strings of
maximum common length; if these substrings are equal: the shortest is considered less than the
longest.
@end itemize
@end deftypefun


For all the functions below the comparison is performed using
@cfunc{mmux_libc_file_system_pathname_segment_compare}.


@deftypefun bool mmux_libc_file_system_pathname_segment_equal (bool * @var{result_p}, mmux_libc_ptn_segment_t @vari{ext}, mmux_libc_ptn_segment_t @varii{ext})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} == @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_not_equal (bool * @var{result_p}, mmux_libc_ptn_segment_t @vari{ext}, mmux_libc_ptn_segment_t @varii{ext})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} != @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_less (bool * @var{result_p}, mmux_libc_ptn_segment_t @vari{ext}, mmux_libc_ptn_segment_t @varii{ext})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} < @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_greater (bool * @var{result_p}, mmux_libc_ptn_segment_t @vari{ext}, mmux_libc_ptn_segment_t @varii{ext})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} > @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_less_equal (bool * @var{result_p}, mmux_libc_ptn_segment_t @vari{ext}, mmux_libc_ptn_segment_t @varii{ext})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} <= @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_greater_equal (bool * @var{result_p}, mmux_libc_ptn_segment_t @vari{ext}, mmux_libc_ptn_segment_t @varii{ext})
Compare the file system pathname segments and store @ctrue{} in the variable referenced by
@var{result_p} if @code{@vari{ext} >= @varii{ext}}; otherwise store @cfalse{}.
@end deftypefun

@c page
@node fs pathnames segments predicates
@subsubsection Predicates on file system pathname segments


@deftypefun bool mmux_libc_file_system_pathname_segment_is_dot (bool * @var{result_p}, mmux_libc_ptn_segment_t @var{seg})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{seg} represents the single dot
segment @samp{.}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_is_double_dot (bool * @var{result_p}, mmux_libc_ptn_segment_t @var{seg})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{seg} represents the double dot
@samp{..}; otherwise store @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_segment_is_slash (bool * @var{result_p}, mmux_libc_ptn_segment_t @var{seg})
Store @ctrue{} in the variable referenced by @var{result_p} if @var{seg} represents the single slash
segment @samp{/}; otherwise store @cfalse{}.
@end deftypefun

@c page
@node fs pathnames examples
@subsection Usage examples for file system pathnames


Build a pathname from an @asciiz{} string, by allocating dynamic memory:

@example
mmux_asciizcp_t         ptn_asciiz = "/path/to/file.ext";
mmux_libc_ptn_t         ptn;

if (mmux_libc_make_file_system_pathname_malloc(&ptn, ptn_asciiz)) @{
  /* error */
@}
@{
  ...
@}
if (mmux_libc_file_system_pathname_free(ptn)) @{
  /* error */
@}
@end example

@c ------------------------------------------------------------------------

@noindent
Build a pathname from an @mmuxascii{} string, by allocating dynamic memory:

@example
//                                  012345678
mmux_asciizcp_t         bufptr[] = "/path/to/file.ext";
mmux_usize_t            buflen   = 8;
mmux_libc_ptn_t         ptn;

if (mmux_libc_make_file_system_pathname_malloc_from_buffer(&ptn, bufptr, buflen)) @{
  /* error */
@}
@{
  ...
@}
if (mmux_libc_file_system_pathname_free(ptn)) @{
  /* error */
@}
@end example

@c ------------------------------------------------------------------------

@noindent
Allocate a buffer containing the pathname, then store the buffer in the pathname object:

@example
mmux_asciizcp_t       ptn_asciiz = "/path/to/file.ext";
mmux_usize_t          buflen;
mmux_asciizp_t        bufptr;
mmux_libc_ptn_t       ptn;

mmux_libc_strlen(&buflen, ptn_asciiz);
if (mmux_libc_malloc(&bufptr, 1 + buflen)) @{
  /* error */
@} else @{
  bufptr[buflen]='\0';
  mmux_libc_strncpy(bufptr, ptn_asciiz, buflen);
  if (mmux_libc_make_file_system_pathname(&ptn, bufptr)) @{
    /* error */
  @}
@}
@end example

@c ------------------------------------------------------------------------

@noindent
We can print a file system pathname to a file descriptor using the function
@cfunc{mmux_libc_dprintf_libc_ptn}; @ref{mmux_libc_dprintf_libc_ptn} for details.

@example
mmux_libc_ptn_t         ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@} else @{
  mmux_libc_fd_t        fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_dprintf_libc_ptn(fd, ptn)) @{
    /* error */
  @}
@}
@end example

@c page
@node fs directories
@section File system directories


@menu
* fs directories streams::      Directory inspection objects.
* fs directories entries::      Directory entry objects.
* fs directories inspection::   Inspecting file system directories.
* fs directories creation::     Creating file system directories.
* fs directories deletion::     Deleting file system directories.
* fs directories working::      Handling the current working directory.
* fs directories root::         Handling the root directory.
@end menu

@c page
@node fs directories streams
@subsection Directory inspection objects


To open, then read, then close a directory inspection object we do:

@example
mmux_libc_ptn_t         dirptn;
mmux_libc_dirstream_t   dirstream;

if (mmux_libc_make_file_system_pathname(&dirptn, "/path/to/directory.d")) @{
  /* error */
@}

if (mmux_libc_opendir(&dirstream, dirptn)) @{
  /* error */
@}

for (;;) @{
  mmux_libc_dirent_t *  direntry;

  if (mmux_libc_readdir(&direntry, dirstream)) @{
    /* error */
  @} else if (direntry) @{
    /* there is an entry available */
    mmux_asciizcp_t     name;
    mmux_uintmax_t      fileno;

    mmux_libc_d_name_ref   (&name,   direntry);
    mmux_libc_d_fileno_ref (&fileno, direntry);
    ...
  @} else @{
    /* no more entries are available */
    break;
  @}
@}

if (mmux_libc_closedir(dirstream)) @{
  /* error */
@}
@end example


@deftp {Opaque Struct Pointer} mmux_libc_dirstream_t
Opaque alias to the standard type @code{DIR *}.
@end deftp


@deftp {Opaque Struct Type} mmux_libc_dirstream_position_t
Opaque data structure used to represent the position in a directory stream retrieved with
@cfunc{mmux_libc_telldir}.
@end deftp

@c page
@node fs directories entries
@subsection Directory entry objects


@MmuxCStructOpaqueTypedef{dirent}

@deftypefun bool mmux_libc_d_name_ref (mmux_asciizcp_t * @var{RESULT_P}, mmux_libc_dirent_t const * @var{dirent_p})
Getter for the field @code{d_name} of @objtype{mmux_libc_dirent_t}.
@end deftypefun


@deftypefun bool mmux_libc_d_fileno_ref (mmux_uintmax_t * @var{result_p}, mmux_libc_dirent_t const * @var{dirent_p})
Getter for the field @code{d_fileno} of @objtype{mmux_libc_dirent_t}.
@end deftypefun


@MmuxStructDumper{dirent}


@c page
@node fs directories inspection
@subsection Inspecting file system directories


@deftypefun bool mmux_libc_opendir (mmux_libc_dirstream_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
@MmuxCInterfaceGlibc{opendir, Opening a Directory}.

@example
mmux_libc_ptn_t         dirptn;
mmux_libc_dirstream_t   dirstream;

if (mmux_libc_make_file_system_pathname(&dirptn, "/path/to/directory.d")) @{
  /* error */
@}

if (mmux_libc_opendir(&dirstream, dirptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_fdopendir (mmux_libc_dirstream_t * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
@MmuxCInterfaceGlibc{fdopendir, Opening a Directory}.  The descriptor @var{fd} will be closed if we
apply @cfunc{mmux_libc_closedir} to the resulting @objtype{mmux_libc_dirent_t} object; so we do not
need to close @var{fd} with @cfunc{mmux_libc_close}.

@example
mmux_libc_file_descriptor_t         dirfd;
mmux_libc_dirstream_t               dirstream;

/* Open the directory's file descriptor. */
@{
  mmux_libc_ptn_t   dirptn;
  mmux_sint_t       flags = MMUX_LIBC_O_DIRECTORY | MMUX_LIBC_O_RDONLY;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_make_file_system_pathname(&dirptn, "/path/to/directory.d")) @{
    /* error */
  @}

  if (mmux_libc_open(&dirfd, dirptn, flags, mode)) @{
    /* error */
  @}
@}

if (mmux_libc_fdopendir(&dirstream, dirfd)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_dirfd (mmux_libc_file_descriptor_t * @var{result_p}, mmux_libc_dirstream_t @var{dirstream})
@MmuxCInterfaceGlibc{dirfd, Opening a Directory}.  After retrieving the file descriptor, we can use
it with functions like @cfunc{mmux_libc_fstat} and @cfunc{mmux_libc_fchdir}.

@example
mmux_libc_ptn_t             dirptn;
mmux_libc_dirstream_t       dirstream;
mmux_libc_fd_t              dirfd;

if (mmux_libc_make_file_system_pathname(&dirptn, ".")) @{
  /* error */
@}

if (mmux_libc_opendir(&dirstream, dirptn)) @{
  /* error */
@}

if (mmux_libc_dirfd(&dirfd, dirstream)) @{
  /* error */
@}

/* Retrieve a "mmux_libc_stat_t" object. */
@{
  mmux_libc_stat_t  ST[1];

  if (mmux_libc_fstat(dirfd, ST)) @{
    /* error */
  @}

  ...
@}

if (mmux_libc_closedir(dirstream)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_closedir (mmux_libc_dirstream_t @var{DS})
@MmuxCInterfaceGlibc{closedir, Reading/Closing Directory}.
@end deftypefun


@deftypefun bool mmux_libc_readdir (mmux_libc_dirent_t ** @var{result_p}, mmux_libc_dirstream_t @var{DS})
@MmuxCInterfaceGlibc{readdir, Reading/Closing Directory}.

@example
mmux_libc_dirstream_t   dirstream = ...;
mmux_libc_dirent_t *    direntry;

if (mmux_libc_readdir(&direntry, dirstream)) @{
  /* error */
@} else if (direntry) @{
  /* there is an entry available */
  mmux_asciizcp_t     name;
  mmux_uintmax_t      fileno;

  mmux_libc_d_name_ref   (&name,   direntry);
  mmux_libc_d_fileno_ref (&fileno, direntry);
  ...
@} else @{
  /* no more entries are available */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_rewinddir (mmux_libc_dirstream_t dirstream)
@MmuxCInterfaceGlibc{rewinddir, Random Access Directory}.
@end deftypefun


@deftypefun bool mmux_libc_telldir (mmux_libc_dirstream_position_t * result_p, mmux_libc_dirstream_t dirstream)
@MmuxCInterfaceGlibc{telldir, Random Access Directory}.
@end deftypefun


@deftypefun bool mmux_libc_seekdir (mmux_libc_dirstream_t dirstream, mmux_libc_dirstream_position_t dirpos)
@MmuxCInterfaceGlibc{seekdir, Random Access Directory}.
@end deftypefun

@c page
@node fs directories creation
@subsection Creating file system directories


@deftypefun bool mmux_libc_mkdir (mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t mode)
@MmuxCInterface{mkdir}.

@example
mmux_libc_ptn_t         ptn;
mmux_mode_t             mode = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR | MMUX_LIBC_S_IXUSR;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/directory.d");
if (mmux_libc_mkdir(ptn, mode)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_mkdirat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode})
@MmuxCInterface{mkdirat}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          dirfd;
mmux_mode_t             mode = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR | MMUX_LIBC_S_IXUSR;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/directory.d");
mmux_libc_at_fdcwd(&dirfd);
if (mmux_libc_mkdir(ptn, mode)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs directories deletion
@subsection Deleting file system directories


@deftypefun bool mmux_libc_rmdir (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{rmdir}.

@example
mmux_libc_ptn_t         ptn;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/directory.d");
if (mmux_libc_rmdir(ptn)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs directories working
@subsection Handling the current working directory


@deftypefun bool mmux_libc_getcwd (mmux_asciizp_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterfaceGlibc{getcwd, Working Directory}.  When successful: @var{bufptr} is filled with the
@asciiz{} string representing the file system pathname of the current working directory, including
the terminating null character.

@example
mmux_usize_t        buflen = 4096;
mmux_char_t         bufptr[buflen];

if (mmux_libc_getcwd(bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_getcwd_malloc (mmux_asciizcpp_t * @var{result_p})
@MmuxCInterfaceGlibc{getcwd, Working Directory}.  When successful: a memory block has been
dynamically allocated and filled with the @asciiz{} string representing the file system pathname of
the current working directory, including the terminating null character; a pointer to such memory
block is stored in the variable referenced by @var{result_p}.

@example
mmux_asciizcp_t     bufptr;

if (mmux_libc_getcwd_malloc(&bufptr)) @{
  /* error */
@} else @{
  /* do something with "bufptr" */
  mmux_libc_free((mmux_pointer_t)bufptr);
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_getcwd_pathname (mmux_libc_file_system_pathname_t * @var{result_p})
Wrapper for @cfunc{mmux_libc_getcwd_malloc} that stores the memory block pointer in a
@objtype{mmux_libc_file_system_pathname_t} object.  The pathname object must later be released using
@cfunc{mmux_libc_file_system_pathname_free}.

@example
mmux_libc_file_system_pathname_t    ptn;

if (mmux_libc_getcwd_pathname(&ptn)) @{
  /* error */
@} else @{
  /* do something with "ptn" */
  mmux_libc_file_system_pathname_free(ptn);
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_chdir (mmux_libc_file_system_pathname_t @var{dirptn})
@MmuxCInterfaceGlibc{chdir, Working Directory}.

@example
mmux_libc_file_system_pathname_t    ptn;

mmux_libc_make_file_system_pathname(&ptn, "..");
if (mmux_libc_chdir(ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_fchdir (mmux_libc_file_descriptor_t fd)
@MmuxCInterfaceGlibc{fchdir, Working Directory}.

@example
mmux_libc_file_descriptor_t           dirfd;

@{
  mmux_libc_file_system_pathname_t    ptn;

  if (mmux_libc_make_file_system_pathname(&ptn, "..")) @{
    /* error */
  @}

  /* Open the directory. */
  @{
    mmux_sint_t         flags = MMUX_LIBC_O_PATH;
    mmux_mode_t         mode  = 0;

    if (mmux_libc_open(&dirfd, ptn, flags, mode)) @{
      /* error */
    @}
  @}
@}

/* Do it. */
@{
  if (mmux_libc_fchdir(dirfd)) @{
    /* error */
  @}
@}

/* Close the directory. */
@{
  if (mmux_libc_close(dirfd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs directories root
@subsection Handling the root directory


The following functions require the calling process to have special privileges.  They are included
in the @api{} of this package for completeness.


@deftypefun bool mmux_libc_chroot (mmux_libc_file_system_pathname_t @var{ptn})
@MmuxCInterface{chroot}.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_pivot_root (mmux_libc_file_system_pathname_t new_root_ptn, mmux_libc_file_system_pathname_t put_old_ptn)
@MmuxCInterface{pivot_root}.
@end deftypefn

@c page
@node fs links
@section Hard and symbolic links


@menu
* fs links hard::               File system hard links.
* fs links symbolic::           File system symbolic links.
* fs links follow::             Following file system symbolic links.
@end menu

@c page
@node fs links hard
@subsection File system hard links


@cindex File system, hard links
@cindex Hard links, file system


@deftypefun bool mmux_libc_link (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{link}.

@example
mmux_libc_ptn_t         old_ptn, new_ptn;

mmux_libc_make_file_system_pathname(&old_ptn, "/path/to/old-file.ext");
mmux_libc_make_file_system_pathname(&new_ptn, "/path/to/new-file.ext");
if (mmux_libc_link(old_ptn, new_ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_linkat (mmux_libc_file_descriptor_t @var{oldfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newfd}, mmux_libc_file_system_pathname_t @var{newname}, mmux_sint_t @var{flags})
@MmuxCInterface{linkat}

@example
mmux_libc_ptn_t         old_ptn, new_ptn;
mmux_libc_fd_t          fd;
mmux_sint_t             flags = MMUX_LIBC_AT_SYMLINK_FOLLOW;

mmux_libc_make_file_system_pathname(&old_ptn, "/path/to/old-file.ext");
mmux_libc_make_file_system_pathname(&new_ptn, "/path/to/new-file.ext");
mmux_libc_at_fdcwd(&fd);
if (mmux_libc_linkat(fd, src_ptn, fd, dst_ptn, flags)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs links symbolic
@subsection File system symbolic links


@cindex File system, symbolic links
@cindex Symbolic links, file system


@deftypefun bool mmux_libc_symlink (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{symlink}.

@example
mmux_libc_ptn_t         old_ptn, new_ptn;

mmux_libc_make_file_system_pathname(&old_ptn, "/path/to/old-file.ext");
mmux_libc_make_file_system_pathname(&new_ptn, "/path/to/new-file.ext");
if (mmux_libc_symlink(old_ptn, new_ptn)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs links follow
@subsection Following file system symbolic links


@cindex File system, real pathnames
@cindex Real pathnames, file system


@menu
* fs links follow pathnames::   Follow file system links by pathname.
* fs links follow fds::         Follow file system links by file descriptor.
@end menu

@c page
@node fs links follow pathnames
@subsubsection Follow file system links by pathname


@deftypefun bool mmux_libc_readlink (mmux_usize_t * @var{required_nbytes_p}, mmux_libc_file_system_pathname_t @var{linkname}, mmux_asciizp_t @var{buffer}, mmux_usize_t @var{provided_nbytes})
@MmuxCInterface{readlink}.  It is usually better to use @cfunc{mmux_libc_readlink_malloc}.

@example
mmux_libc_ptn_t 	org_ptn, rea_ptn;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");
@{
  mmux_usize_t          provided_nbytes_with_nul = 1024;
  char                  bufptr[provided_nbytes_with_nul];
  mmux_usize_t          nbytes_done_no_nul;

  mmux_libc_memzero(bufptr, provided_nbytes_with_nul);

  if (mmux_libc_readlink(&nbytes_done_no_nul, lnk_ptn, bufptr, provided_nbytes_with_nul-1)) @{
    /* error */
  @} else if (nbytes_done_no_nul == provided_nbytes_with_nul) @{
    /* not enough bytes in the supplied buffer */
  @}
  if (mmux_libc_make_file_system_pathname_malloc(&rea_ptn, bufptr)) @{
    /* error */
  @}
@}
@{
  ... /* do something with "rea_ptn" */
@}
mmux_libc_file_system_pathname_free(rea_ptn);
@end example
@end deftypefun


@deftypefun bool mmux_libc_readlink_malloc (mmux_libc_file_system_pathname_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Like @cfunc{mmux_libc_readlink} but when successful: allocate a memory block, using
@cfunc{mmux_libc_malloc}, and store the resulting pathname @asciiz{} string in it; we must release
the allocated memory using @cfunc{mmux_libc_free}.

@example
mmux_libc_ptn_t	org_ptn, rea_ptn;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");
if (mmux_libc_readlink_malloc(&rea_ptn, org_ptn)) @{
  /* error */
@}
@{
  ... /* do something with "rea_ptn" */
@}
mmux_libc_file_system_pathname_free(rea_ptn);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_readlinkat (mmux_usize_t * @var{required_nbytes_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{linkname}, mmux_asciizp_t @var{buffer}, mmux_usize_t @var{provided_nbytes})
@MmuxCInterface{readlinkat}.  It is usually better to use @cfunc{mmux_libc_readlinkat_malloc}.

@example
mmux_libc_ptn_t 	org_ptn, rea_ptn;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");
@{
  mmux_usize_t          provided_nbytes_with_nul = 1024;
  char                  bufptr[provided_nbytes_with_nul];
  mmux_usize_t          nbytes_done_no_nul;
  mmux_libc_fd_t        dirfd;

  mmux_libc_memzero(bufptr, provided_nbytes_with_nul);

  if (mmux_libc_readlinkat(&nbytes_done_no_nul, dirfd, lnk_ptn, bufptr, provided_nbytes_with_nul-1)) @{
    /* error */
  @} else if (nbytes_done_no_nul == provided_nbytes_with_nul) @{
    /* not enough bytes in the supplied buffer */
  @}
  if (mmux_libc_make_file_system_pathname_malloc(&rea_ptn, bufptr)) @{
    /* error */
  @}
@}
@{
  ... /* do something with "rea_ptn" */
@}
mmux_libc_file_system_pathname_free(rea_ptn);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_readlinkat_malloc (mmux_libc_file_system_pathname_t * @var{result_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{linkname})
Like @cfunc{mmux_libc_readlinkat} but when successful: allocate a memory block, using
@cfunc{mmux_libc_malloc}, and store the resulting pathname @asciiz{} string in it; we must release
the allocated memory using @cfunc{mmux_libc_free}.

@example
mmux_libc_ptn_t         org_ptn, rea_ptn;
mmux_libc_fd_t          dirfd;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");
mmux_libc_at_fdcwd(&dirfd);
if (mmux_libc_readlinkat_malloc(&rea_ptn, dirfd, org_ptn)) @{
  /* error */
@}
@{
  ... /* do something with "rea_ptn" */
@}
mmux_libc_file_system_pathname_free(rea_ptn);
@end example
@end deftypefun


@deftypefun bool mmux_libc_canonicalize_file_name (mmux_libc_file_system_pathname_t * @var{result_pathname_p}, mmux_libc_file_system_pathname_t @var{input_pathname})
@MmuxCInterface{canonicalize_file_name}.  When successful: a memory buffer is allocated, using
@cfunc{mmux_libc_malloc}, and the resulting pathname is stored in it, including the terminating nul;
a pointer to the buffer is stored in the location referenced by @var{result_pathname_p}.  It is
responsibility of the caller to release the buffer with a call to @cfunc{mmux_libc_free}.
@end deftypefun


@deftypefun bool mmux_libc_realpath (mmux_asciizp_t * @var{result_pathname_p}, mmux_libc_file_system_pathname_t @var{input_pathname})
@MmuxCInterface{realpath}.  When successful: a memory buffer is allocated, using
@cfunc{mmux_libc_malloc}, and the resulting pathname is stored in it, including the terminating nul;
a pointer to the buffer is stored in the location referenced by @var{result_pathname_p}.  It is
responsibility of the caller to release the buffer with a call to @cfunc{mmux_libc_free}.
@end deftypefun

@c page
@node fs links follow fds
@subsubsection Follow file system links by file descriptor


The following functions are wrappers for @cfunc{readlinkat}, @MmuxCFuncpage{readlinkat}.  They are
invoked in the special way supported by the latest Linux kernels: with the @asciiz{} string
representing the file system pathname set to the empty string.  This causes the file descriptor
argument to be meant to represent the link to follow through to the real file description.


@deftypefn {Linux Function} bool mmux_libc_readlinkfd (mmux_usize_t * @var{required_nbytes_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_asciizp_t @var{buffer}, mmux_usize_t @var{provided_nbytes})
Wrapper for @cfunc{readlinkat} called with empty file system pathname.  It is usually better to use
@cfunc{mmux_libc_readlinkfd_malloc}.

@example
mmux_libc_ptn_t         org_ptn, rea_ptn;
mmux_libc_fd_t          org_fd;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&org_fd, org_ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Read the link. */
@{
  mmux_usize_t          provided_nbytes_with_nul = 1024;
  char                  bufptr[provided_nbytes_with_nul];
  mmux_usize_t          nbytes_done_no_nul;

  mmux_libc_memzero(bufptr, provided_nbytes_with_nul);

  if (mmux_libc_readlinkfd(&nbytes_done_no_nul, org_fd, bufptr, provided_nbytes_with_nul-1)) @{
    /* error */
  @} else if (nbytes_done_no_nul == provided_nbytes_with_nul) @{
    /* not enough bytes in the supplied buffer */
  @}
  if (mmux_libc_make_file_system_pathname_malloc(&rea_ptn, bufptr)) @{
    /* error */
  @}
@}

/* Do something with "rea_ptn". */
@{
  ...
@}

/* Release the asynchronous resources. */
@{
  mmux_libc_file_system_pathname_free(rea_ptn);
  if (mmux_libc_close(org_fd)) @{
      /* error */
  @}
@}
@end example
@end deftypefn

@c ------------------------------------------------------------------------

@deftypefn {Linux Function} bool mmux_libc_readlinkfd_malloc (mmux_libc_file_system_pathname_t * @var{result_p}, mmux_libc_file_descriptor_t @var{fd})
Like @cfunc{mmux_libc_readlinkfd} but when successful: allocate a memory block, using
@cfunc{mmux_libc_malloc}, and store the resulting pathname @asciiz{} string in it; we must release
the allocated memory using @cfunc{mmux_libc_free}.

@example
mmux_libc_ptn_t         org_ptn, rea_ptn;
mmux_libc_fd_t          org_fd;

mmux_libc_make_file_system_pathname(&org_ptn, "/path/to/file.ext");

/* Open the link. */
@{
  mmux_sint_t       flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t       mode  = 0;

  if (mmux_libc_open(&org_fd, org_ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Read the link. */
@{
  if (mmux_libc_readlinkfd_malloc(&rea_ptn, org_fd)) @{
    /* error */
  @}
@}

/* Do something with "rea_ptn". */
@{
  ...
@}

/* Release the asynchronous resources. */
@{
  mmux_libc_file_system_pathname_free(rea_ptn);
  if (mmux_libc_close(org_fd)) @{
      /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fs deleting
@section Deleting links


@deftypefun bool mmux_libc_unlink (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{unlink}.

@example
mmux_libc_ptn_t         ptn;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_unlink(ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_unlinkat (mmux_libc_file_descriptor_t dirfd, mmux_libc_file_system_pathname_t pathname, mmux_sint_t flags)
@MmuxCInterface{unlinkat}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          dirfd;
mmux_sint_t             flags = 0;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
mmux_libc_at_fdcwd(&dirfd);
if (mmux_libc_unlinkat(dirfd, ptn, flags)) @{
  /* error */
@}
@end example

We can remove directories with this function:

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          dirfd;
mmux_sint_t             flags = MMUX_LIBC_AT_REMOVEDIR;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/dirname");
mmux_libc_at_fdcwd(&dirfd);
if (mmux_libc_unlinkat(dirfd, ptn, flags)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_remove (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{remove}.

@example
mmux_libc_ptn_t         ptn;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_remove(ptn)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs renaming
@section Renaming links


@deftypefun bool mmux_libc_rename (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{rename}.

@example
mmux_libc_ptn_t     src_ptn, dst_ptn;

mmux_libc_make_file_system_pathname(&src_ptn, "/path/to/file.ext");
mmux_libc_make_file_system_pathname(&dst_ptn, "/path/to/other-file.ext");

if (mmux_libc_rename(src_ptn, dst_ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_renameat (mmux_libc_file_descriptor_t @var{olddirfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newdirfd}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{renameat}.

@example
mmux_libc_ptn_t     src_ptn, dst_ptn;
mmux_libc_fd_t      dirfd;

mmux_libc_make_file_system_pathname(&src_ptn, "/path/to/file.ext");
mmux_libc_make_file_system_pathname(&dst_ptn, "/path/to/other-file.ext");
mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_renameat(dirfd, src_ptn, dirfd, dst_ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_renameat2 (mmux_libc_file_descriptor_t @var{olddirfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newdirfd}, mmux_libc_file_system_pathname_t @var{newname}, mmux_uint_t flags)
@MmuxCInterface{renameat2}.

@example
mmux_libc_ptn_t     src_ptn, dst_ptn;
mmux_libc_fd_t      dirfd;
mmux_uint_t         flags = MMUX_LIBC_RENAME_NOREPLACE;

mmux_libc_make_file_system_pathname(&src_ptn, "/path/to/file.ext");
mmux_libc_make_file_system_pathname(&dst_ptn, "/path/to/other-file.ext");
mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_renameat2(dirfd, src_ptn, dirfd, dst_ptn, flags)) @{
  /* error */
@}
@end example
@end deftypefn

@c page
@node fs ownership
@section File ownership


@deftypefun bool mmux_libc_chown (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterfaceGlibc{chown, File Owner}.

@example
mmux_libc_ptn_t       ptn;
mmux_libc_uid_t       uid;
mmux_libc_gid_t       gid;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Acquire example UID and GID. */
@{
  mmux_asciizcp_t             name;
  mmux_libc_passwd_t *        PW;

  if (mmux_libc_getlogin(&name)) @{
    /* error */
  @}

  if (mmux_libc_getpwnam(&PW, name)) @{
    /* error */
  @}

  mmux_libc_pw_uid_ref(&uid, PW);
  mmux_libc_pw_gid_ref(&gid, PW);
@}

/* Do it. */
@{
  if (mmux_libc_chown(ptn, uid, gid)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_fchown (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterfaceGlibc{fchown, File Owner}.

@example
mmux_libc_ptn_t       ptn;
mmux_libc_fd_t        fd;
mmux_libc_uid_t       uid;
mmux_libc_gid_t       gid;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Open the file. */
@{
  mmux_sint_t     flags    = MMUX_LIBC_O_RDWR;
  mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Acquire example UID and GID. */
@{
  mmux_asciizcp_t             name;
  mmux_libc_passwd_t *        PW;

  if (mmux_libc_getlogin(&name)) @{
    /* error */
  @}

  if (mmux_libc_getpwnam(&PW, name)) @{
    /* error */
  @}

  mmux_libc_pw_uid_ref(&uid, PW);
  mmux_libc_pw_gid_ref(&gid, PW);
@}

/* Do it. */
@{
  if (mmux_libc_fchown(fd, uid, gid)) @{
    /* error */
  @}
@}

/* Close the file. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_lchown (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterface{lchown}.  This function does not dereference symbolic links.
@end deftypefun


@deftypefun bool mmux_libc_fchownat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid}, mmux_sint_t flags);
@MmuxCInterface{fchownat}.

@example
mmux_libc_ptn_t       ptn;
mmux_libc_uid_t       uid;
mmux_libc_gid_t       gid;

if (mmux_libc_make_file_system_pathname(&ptn, src_pathname_asciiz)) @{
  /* error */
@}

/* Acquire example UID and GID. */
@{
  mmux_asciizcp_t             name;
  mmux_libc_passwd_t *        PW;

  if (mmux_libc_getlogin(&name)) @{
    /* error */
  @}

  if (mmux_libc_getpwnam(&PW, name)) @{
    /* error */
  @}

  mmux_libc_pw_uid_ref(&uid, PW);
  mmux_libc_pw_gid_ref(&gid, PW);
@}

/* Do it. */
@{
  mmux_libc_fd_t      dirfd;
  mmux_sint_t         flags = MMUX_LIBC_AT_SYMLINK_NOFOLLOW;

  mmux_libc_at_fdcwd(&dirfd);

  if (mmux_libc_fchownat(dirfd, ptn, uid, gid, flags)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_chownfd (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid}, mmux_sint_t @var{flags})
Like @cfunc{mmux_libc_fchownat} but always add @code{MMUX_LIBC_AT_EMPTY_PATH} to @var{flags}, so it
operates on @var{fd}.

@example
mmux_libc_ptn_t       ptn;
mmux_libc_fd_t        fd;
mmux_libc_uid_t       uid;
mmux_libc_gid_t       gid;

if (mmux_libc_make_file_system_pathname(&ptn, src_pathname_asciiz)) @{
  /* error */
@}

/* Open the file. */
@{
  mmux_sint_t     flags    = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Acquire example UID and GID. */
@{
  mmux_asciizcp_t             name;
  mmux_libc_passwd_t *        PW;

  if (mmux_libc_getlogin(&name)) @{
    /* error */
  @}

  if (mmux_libc_getpwnam(&PW, name)) @{
    /* error */
  @}

  mmux_libc_pw_uid_ref(&uid, PW);
  mmux_libc_pw_gid_ref(&gid, PW);
@}

/* Do it. */
@{
  mmux_sint_t         flags = MMUX_LIBC_AT_SYMLINK_NOFOLLOW;

  if (mmux_libc_chownfd(fd, uid, gid, flags)) @{
    /* error */
  @}
@}

/* Close the file. */
@{
  if (mmux_libc_close(fd)) @{
    /* error */
  @}
@}
@end example
@end deftypefn

@c page
@node fs permissions
@section File access permissions


@deftypefun bool mmux_libc_umask (mmux_mode_t * @var{old_mask_p}, mmux_mode_t @var{new_mask})
@MmuxCInterfaceGlibc{umask, Setting Permissions}.

@example
mmux_mode_t     old_mask, new_mask = 0755;

mmux_libc_umask(&old_mask, new_mask);
@end example
@end deftypefun


@deftypefun bool mmux_libc_getumask (mmux_mode_t * @var{current_mask_p})
Store the current mask in the location referenced by @var{current_mask_p}.  Do not change the
current mask.

@example
mmux_mode_t     cur_mask;

mmux_libc_getumask(&cur_mask);
@end example
@end deftypefun


@deftypefun bool mmux_libc_chmod (mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode})
@MmuxCInterfaceGlibc{chmod, Setting Permissions}.

@example
mmux_libc_ptn_t     ptn;
mmux_mode_t         mode = 0755;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

if (mmux_libc_chmod(ptn, mode)) @{
  /* error */
@}

/* Check it. */
@{
  mmux_libc_stat_t  ST[1];
  mmux_mode_t       st_mode;

  if (mmux_libc_stat(ptn, ST)) @{
    handle_error();
  @}

  mmux_libc_st_mode_ref(&st_mode, ST);

  if ((MMUX_LIBC_S_IRWXU                       == (MMUX_LIBC_S_IRWXU & st_mode)) &&
      ((MMUX_LIBC_S_IRGRP | MMUX_LIBC_S_IXGRP) == (MMUX_LIBC_S_IRWXG & st_mode)) &&
      ((MMUX_LIBC_S_IROTH | MMUX_LIBC_S_IXOTH) == (MMUX_LIBC_S_IRWXO & st_mode))) @{
    /* mode checks out */
  @}

  if (0755 == ((MMUX_LIBC_S_IRWXU | MMUX_LIBC_S_IRWXG | MMUX_LIBC_S_IRWXO) & st_mode)) @{
    /* mode checks out */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_fchmod (mmux_libc_file_descriptor_t @var{fd}, mmux_mode_t @var{mode})
@MmuxCInterfaceGlibc{fchmod, Setting Permissions}.

@example
mmux_libc_ptn_t       ptn;
mmux_libc_fd_t        fd;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Open the file. */
@{
  mmux_sint_t         flags = MMUX_LIBC_O_RDWR;
  mmux_mode_t         mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_mode_t         mode = 0755;

  if (mmux_libc_fchmod(fd, mode)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_fchmodat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode}, mmux_sint_t @var{flags})
@MmuxCInterface{fchmodat}.

@example
mmux_libc_ptn_t       ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Do it. */
@{
  mmux_libc_fd_t      dirfd;
  mmux_mode_t         mode  = 0755;
  mmux_sint_t         flags = MMUX_LIBC_AT_SYMLINK_NOFOLLOW;

  mmux_libc_at_fdcwd(&dirfd);

  if (mmux_libc_fchmodat(dirfd, ptn, mode, flags)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_access (bool * @var{access_is_permitted_p}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{how})
@MmuxCInterfaceGlibc{access, Testing File Access}.  When successful the access mode specified by
@var{how} could be permitted or denied:

@itemize
@item
if the requested access is permitted: the variable referenced by @var{access_is_permitted_p} is set
to @ctrue{};

@item
if the requested access is denied: the variable referenced by @var{access_is_permitted_p} is set to
@cfalse{}.
@end itemize

@example
mmux_libc_ptn_t       ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Check: it is a file, it is readable, it is writable, it is executable. */
@{
  mmux_sint_t         how = MMUX_LIBC_F_OK | MMUX_LIBC_R_OK | MMUX_LIBC_W_OK | MMUX_LIBC_X_OK;
  bool                access_is_permitted;

  if (mmux_libc_access(&access_is_permitted, ptn, how)) @{
    /* error */
  @} else if (access_is_permitted) @{
    /* access is permitted */
  @} else @{
    /* access is denied */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_faccessat (bool * @var{access_is_permitted_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{how}, mmux_sint_t @var{flags})
@MmuxCInterface{faccessat}.  When successful the access mode specified by
@var{how} could be permitted or denied:

@itemize
@item
if the requested access is permitted: the variable referenced by @var{access_is_permitted_p} is set
to @ctrue{};

@item
if the requested access is denied: the variable referenced by @var{access_is_permitted_p} is set to
@cfalse{}.
@end itemize

@example
mmux_libc_ptn_t       ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Check: it is a file, it is readable, it is writable, it is executable. */
@{
  mmux_libc_fd_t  dirfd;
  mmux_sint_t     how = MMUX_LIBC_F_OK | MMUX_LIBC_R_OK | MMUX_LIBC_W_OK | MMUX_LIBC_X_OK;
  mmux_sint_t     flags = MMUX_LIBC_AT_SYMLINK_NOFOLLOW;
  bool            access_is_permitted;

  if (mmux_libc_faccessat(&access_is_permitted, dirfd, ptn, how, flags)) @{
    /* error */
  @} else if (access_is_permitted) @{
    /* access is permitted */
  @} else @{
    /* access is denied */
  @}
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_faccessat2 (bool * @var{access_is_permitted_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{how}, mmux_sint_t @var{flags})
@MmuxCInterface{faccessat2}.  When successful the access mode specified by @var{how} could be
permitted or denied:

@itemize
@item
if the requested access is permitted: the variable referenced by @var{access_is_permitted_p} is set
to @ctrue{};

@item
if the requested access is denied: the variable referenced by @var{access_is_permitted_p} is set to
@cfalse{}.
@end itemize

@example
mmux_libc_ptn_t       ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Check: it is a file, it is readable, it is writable, it is executable. */
@{
  mmux_libc_fd_t  dirfd;
  mmux_sint_t     how = MMUX_LIBC_F_OK | MMUX_LIBC_R_OK | MMUX_LIBC_W_OK | MMUX_LIBC_X_OK;
  mmux_sint_t     flags = MMUX_LIBC_AT_SYMLINK_NOFOLLOW;
  bool            access_is_permitted;

  if (mmux_libc_faccessat2(&access_is_permitted, dirfd, ptn, how, flags)) @{
    /* error */
  @} else if (access_is_permitted) @{
    /* access is permitted */
  @} else @{
    /* access is denied */
  @}
@}
@end example
@end deftypefn

@c page
@node fs attributes
@section File attributes


@menu
* fs attributes struct::        The @objtype{mmux_libc_stat_t} data structure.
* fs attributes stat::          The @cfunc{stat} functions.
* fs attributes mode::          Inspecting the mode field of @objtype{mmux_libc_stat_t}.
* fs attributes predicates::    File system pathname predicates.
* fs attributes fields::        Fields inspection functions.
@end menu

@c page
@node fs attributes struct
@subsection The @objtype{mmux_libc_stat_t} data structure



The standard @cfunc{stat} function and its variants inspect the file system to retrieve most of the
informations associated to a directory entry; the informations are stored in data structures of type
@objtype{mmux_libc_stat_t}.  The core function is @cfunc{mmux_libc_stat}, which we can use as
follows:

@example
mmux_libc_ptn_t     ptn;
mmux_libc_stat_t    ST[1];

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

if (mmux_libc_stat(ptn, ST)) @{
  /* error */
@} else @{
  mmux_libc_fd_t    fd;

  mmux_libc_stder(&fd);
  if (mmux_libc_stat_dump(fd, ST, NULL)) @{
    /* error */
  @}
@}
@end example

@noindent
this code prints something like:

@example
struct stat = 0x7ffd58c7b320
struct stat->st_mode = 33152 (regular file)
struct stat->st_ino = 4069062
struct stat->st_dev = 66316
struct stat->st_nlink = 1
struct stat->st_ino = 4069062
struct stat->st_uid = 1000
struct stat->st_gid = 1000
struct stat->st_size = 41
struct stat->st_atime_sec = 1752688262 (2025-07-16T17:51:02+0000)
struct stat->st_atime_nsec = 74991584
struct stat->st_mtime_sec = 1752688262 (2025-07-16T17:51:02+0000)
struct stat->st_mtime_nsec = 74991584
struct stat->st_ctime_sec = 1752688262 (2025-07-16T17:51:02+0000)
struct stat->st_ctime_nsec = 74991584
struct stat->st_blocks = 8
struct stat->st_blksize = 4096
@end example


@MmuxCStructOpaqueTypedef{stat}
@MmuxSetterGetter{stat, st_mode,        mmux_mode_t}
@MmuxSetterGetter{stat,	st_ino,		mmux_ino_t}
@MmuxSetterGetter{stat,	st_dev,		mmux_dev_t}
@MmuxSetterGetter{stat,	st_nlink,	mmux_nlink_t}
@MmuxSetterGetter{stat,	st_uid,		mmux_libc_uid_t}
@MmuxSetterGetter{stat,	st_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{stat,	st_size,	mmux_off_t}
@MmuxSetterGetter{stat,	st_atime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_atime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_mtime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_mtime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_ctime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_ctime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_blocks,	mmux_blkcnt_t}
@MmuxSetterGetter{stat,	st_blksize,	mmux_uint_t}
@MmuxStructDumper{stat}


@deftypefun bool mmux_libc_S_TYPEISMQ (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPESIMQ}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISSEM (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPEISSEM}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISSHM (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPEISSHM}.
@end deftypefun

@c page
@node fs attributes stat
@subsection The @cfunc{stat} functions


@deftypefun bool mmux_libc_stat (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{stat}.

@example
mmux_libc_ptn_t     ptn;
mmux_libc_stat_t    ST[1];

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");

if (mmux_libc_stat(ptn, ST)) @{
  /* error */
@} else @{
  mmux_libc_fd_t    fd;

  mmux_libc_stder(&fd);
  if (mmux_libc_stat_dump(fd, ST, NULL)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_fstat (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{fstat}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Open the file. */
@{
  mmux_sint_t         flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t         mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_stat_t    ST[1];

  if (mmux_libc_fstat(fd, ST)) @{
    /* error */
  @} else @{
    mmux_libc_fd_t    er;

    mmux_libc_stder(&er);
    if (mmux_libc_stat_dump(er, ST, NULL)) @{
      /* error */
    @}
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_lstat (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{lstat}.

@example
mmux_libc_ptn_t       ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/symlink.ext")) @{
  /* error */
@}

/* Do it. */
@{
  mmux_libc_stat_t    ST[1];

  if (mmux_libc_lstat(dst_ptn, ST)) @{
    /* error */
  @} else @{
    mmux_libc_fd_t    er;

    mmux_libc_stder(&er);
    if (mmux_libc_stat_dump(er, ST, NULL)) @{
      /* error */
    @}
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_fstatat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p}, mmux_sint_t flags)
@MmuxCInterface{fstatat}.

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Open the file. */
@{
  mmux_sint_t         flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t         mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_stat_t    ST[1];
  mmux_sint_t         flags = MMUX_LIBC_AT_SYMLINK_NOFOLLOW;
  mmux_libc_fd_t      dirfd;

  mmux_libc_at_fdcwd(&dirfd);

  if (mmux_libc_fstatat(dirfd, ptn, ST, flags)) @{
    /* error */
  @}

  @{
    mmux_libc_fd_t    er;

    mmux_libc_stder(&er);
    if (mmux_libc_stat_dump(er, ST, NULL)) @{
      /* error */
    @}
  @}
@}
@end example
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_statfd (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p}, mmux_sint_t @var{flags})
@MmuxCInterface{fstatat}.  This function invokes @cfunc{fstatat} with an empty file system pathname
and adding @samp{MMUX_LIBC_AT_EMPTY_PATH} to the @var{flags} argument; this causes the function to
operate on the file descriptor @var{fd}.

@example
mmux_libc_ptn_t       ptn;
mmux_libc_fd_t        fd;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Open the file. */
@{
  mmux_sint_t         flags = MMUX_LIBC_O_PATH | MMUX_LIBC_O_NOFOLLOW;
  mmux_mode_t         mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_libc_stat_t    ST[1];
  mmux_sint_t         flags = MMUX_LIBC_AT_SYMLINK_NOFOLLOW;

  if (mmux_libc_statfd(fd, ST, flags)) @{
    /* error */
  @}

  @{
    mmux_libc_fd_t    er;

    mmux_libc_stder(&er);
    if (mmux_libc_stat_dump(er, ST, NULL)) @{
      /* error */
    @}
  @}
@}
@end example
@end deftypefn

@c page
@node fs attributes mode
@subsection Inspecting the mode field of @objtype{mmux_libc_stat_t}


@deftypefun bool mmux_libc_S_ISDIR (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISDIR}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISCHR (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISCHR}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISBLK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISBLK}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISREG (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISREG}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISFIFO (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISFIFO}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISLNK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISLNK}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISSOCK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISSOCK}.
@end deftypefun

@c page
@node fs attributes predicates
@subsection File system pathname predicates


For all the following functions: the test is performed using @cfunc{mmux_libc_lstat}, so the
pathname itself is inspected without following symbolic links.


@deftypefun bool mmux_libc_file_system_pathname_exists (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_exists(&the_pathname_exists, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_regular (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a regular file; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_regular;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_regular(&the_pathname_exists_and_it_is_regular, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_symlink (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a symbolic link; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_symlink;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_symlink(&the_pathname_exists_and_it_is_symlink, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_directory (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a directory; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_directory;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_directory(&the_pathname_exists_and_it_is_directory, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_character_special (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a character special device; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_character_special;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_character_special(&the_pathname_exists_and_it_is_character_special, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_block_special (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a block special device; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_block_special;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_block_special(&the_pathname_exists_and_it_is_block_special, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_fifo (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a FIFO; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_fifo;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_fifo(&the_pathname_exists_and_it_is_fifo, ptn)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_is_socket (bool * @var{result_p}, mmux_libc_file_system_pathname_t @var{ptn})
Store @ctrue{} in the variable referenced by @var{result_p} if the given pathname exists as a
directory entry and it is a socket; otherwise store @cfalse{}.

@example
mmux_libc_ptn_t         ptn;
bool                    the_pathname_exists_and_it_is_socket;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
if (mmux_libc_file_system_pathname_is_socket(&the_pathname_exists_and_it_is_socket, ptn)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs attributes fields
@subsection Attribute inspection functions


The functions documented in this section retrieve the value of some fields from
@objtype{mmux_libc_stat_t} objects embedding the call to the standard @cfunc{stat} function and its
variants; true control about the resulting values is possible only by explicitly selecting which
@cfunc{stat} variant to call and which arguments to use in the function invocation.  But the
following functions are simpler and sometimes they are enough.


@deftypefun bool mmux_libc_file_system_pathname_file_size_ref (mmux_usize_t * @var{result_p}, mmux_libc_fd_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{ptn})
Invoke @cfunc{mmux_libc_fstatat} (with flags set to zero) and retrieve the @code{st_size} field
value of the resulting @objtype{mmux_libc_stat_t}.  Store such field value in the variable
referenced by @var{result_p}, casting the @objtype{mmux_off_t} value to @objtype{mmux_usize_t}.

@example
mmux_libc_file_system_pathname_t        ptn;
mmux_libc_file_descriptor_t             dirfd;
mmux_usize_t                            size;

mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext");
mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_file_system_pathname_file_size_ref(&size, dirfd, ptn)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fs truncating
@section Truncating files


@deftypefun bool mmux_libc_truncate (mmux_libc_file_system_pathname_t pathname, mmux_off_t len)
@MmuxCInterface{truncate}.

@example
mmux_libc_ptn_t       ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Do it. */
@{
  mmux_off_t          len = 10;

  if (mmux_libc_truncate(ptn, len)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_ftruncate (mmux_libc_file_descriptor_t fd, mmux_off_t len)
@MmuxCInterface{ftruncate}.

@example
mmux_libc_ptn_t  ptn;
mmux_libc_fd_t   fd;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Open the file. */
@{
  mmux_sint_t         flags = MMUX_LIBC_O_RDWR;
  mmux_mode_t         mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}


/* Do it. */
@{
  mmux_off_t          len = 10;

  if (mmux_libc_ftruncate(fd, len)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node fs times
@section File system times


@menu
* fs times utimbuf::            Data structures of type @objtype{mmux_libc_utimbuf_t}.
* fs times setting::            Setting the file system times associated to files.
@end menu

@c page
@node fs times utimbuf
@subsection Data structures of type @objtype{mmux_libc_utimbuf_t}


If we want to toy with a @objtype{mmux_libc_utimbuf_t} objects, we do:

@example
mmux_libc_utimbuf_t   UTB[1];
mmux_time_t           T1, T2;

mmux_libc_current_time(&T1);
mmux_libc_current_time(&T2);

mmux_libc_actime_set  (UTB, T1);
mmux_libc_modtime_set (UTB, T2);

@{
  mmux_libc_fd_t      fd;

  mmux_libc_stdou(&fd);
  if (mmux_libc_utimbuf_dump(fd, UTB, NULL)) @{
    /* error */
  @}
@}
@end example


@MmuxCStructOpaqueTypedef{utimbuf}
@MmuxSetterGetter{utimbuf, actime,  mmux_time_t}
@MmuxSetterGetter{utimbuf, modtime, mmux_time_t}
@MmuxStructDumper{utimbuf}

@c page
@node fs times setting
@subsection Setting the file system times associated to files


@deftypefun bool mmux_libc_utime (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_utimbuf_t @var{utimbuf})
@MmuxCInterface{utime}.

@example
mmux_libc_ptn_t       ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Do it. */
@{
  mmux_libc_utimbuf_t UTB;
  mmux_time_t         T1, T2;

  mmux_libc_current_time(&T1);
  mmux_libc_current_time(&T2);

  mmux_libc_actime_set  (&UTB, T1);
  mmux_libc_modtime_set (&UTB, T2);

  if (mmux_libc_utime(ptn, UTB)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_utimes (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{utimes}.

@example
mmux_libc_ptn_t       ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Do it. */
@{
  mmux_time_t                 T1, T2;
  mmux_slong_t                microsecs1, microsecs2;
  mmux_libc_timeval_t         access_timeval, modification_timeval;

  mmux_libc_current_time(&T1);
  mmux_libc_current_time(&T2);

  microsecs1 = 123;
  microsecs2 = 456;

  mmux_libc_timeval_set(&access_timeval,       T1, microsecs1);
  mmux_libc_timeval_set(&modification_timeval, T2, microsecs2);

  if (mmux_libc_utimes(ptn, access_timeval, modification_timeval)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@deftypefun bool mmux_libc_lutimes (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{lutimes}.

@example
mmux_libc_ptn_t       ptn;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/symlink.ext")) @{
  /* error */
@}

/* Do it. */
@{
  mmux_time_t                 T1, T2;
  mmux_slong_t                microsecs1, microsecs2;
  mmux_libc_timeval_t         access_timeval, modification_timeval;

  mmux_libc_current_time(&T1);
  mmux_libc_current_time(&T2);

  microsecs1 = 123;
  microsecs2 = 456;

  mmux_libc_timeval_set(&access_timeval,       T1, microsecs1);
  mmux_libc_timeval_set(&modification_timeval, T2, microsecs2);

  if (mmux_libc_lutimes(ptn, access_timeval, modification_timeval)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_futimes (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{futimes}.

@example
mmux_libc_ptn_t       ptn;
mmux_libc_fd_t        fd;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Open the file. */
@{
  mmux_sint_t         flags = MMUX_LIBC_O_RDONLY;
  mmux_mode_t         mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_time_t                 T1, T2;
  mmux_slong_t                microsecs1, microsecs2;
  mmux_libc_timeval_t         access_timeval, modification_timeval;

  mmux_libc_current_time(&T1);
  mmux_libc_current_time(&T2);

  microsecs1 = 123;
  microsecs2 = 456;

  mmux_libc_timeval_set(&access_timeval,       T1, microsecs1);
  mmux_libc_timeval_set(&modification_timeval, T2, microsecs2);

  if (mmux_libc_futimes(fd, access_timeval, modification_timeval)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_futimens (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timespec_t @var{access_timespec}, mmux_libc_timespec_t @var{modification_timespec})
@MmuxCInterface{futimens}.

@example
mmux_libc_ptn_t       ptn;
mmux_libc_fd_t        fd;

if (mmux_libc_make_file_system_pathname(&ptn, "/path/to/file.ext")) @{
  /* error */
@}

/* Open the file. */
@{
  mmux_sint_t         flags = MMUX_LIBC_O_RDONLY;
  mmux_mode_t         mode  = 0;

  if (mmux_libc_open(&fd, ptn, flags, mode)) @{
    /* error */
  @}
@}

/* Do it. */
@{
  mmux_time_t                 T1, T2;
  mmux_slong_t                nanosecs1, nanosecs2;
  mmux_libc_timespec_t        access_timespec, modification_timespec;

  mmux_libc_current_time(&T1);
  mmux_libc_current_time(&T2);

  nanosecs1 = 123;
  nanosecs2 = 456;

  mmux_libc_timespec_set(&access_timespec,       T1, nanosecs1);
  mmux_libc_timespec_set(&modification_timespec, T2, nanosecs2);

  if (mmux_libc_futimes(fd, access_timespec, modification_timespec)) @{
    /* error */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_utimensat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_timespec_t @var{access_timespec}, mmux_libc_timespec_t @var{modification_timespec}, mmux_sint_t @var{flags})
@MmuxCInterface{utimensat}.

@example
mmux_libc_ptn_t       ptn;

if (mmux_libc_make_file_system_pathname(&ptn, src_pathname_asciiz)) @{
  /* error */
@}

/* Do it. */
@{
  mmux_libc_fd_t              dirfd;
  mmux_time_t                 T1, T2;
  mmux_slong_t                nanosecs1, nanosecs2;
  mmux_libc_timespec_t        access_timespec, modification_timespec;
  mmux_sint_t                 flags = MMUX_LIBC_AT_SYMLINK_NOFOLLOW;

  mmux_libc_at_fdcwd(&dirfd);

  mmux_libc_current_time(&T1);
  mmux_libc_current_time(&T2);

  nanosecs1 = 123;
  nanosecs2 = 456;

  mmux_libc_timespec_set(&access_timespec,       T1, nanosecs1);
  mmux_libc_timespec_set(&modification_timespec, T2, nanosecs2);

  if (mmux_libc_utimensat(dirfd, ptn, access_timespec, modification_timespec, flags)) @{
    /* error */
  @}
@}
@end example
@end deftypefun

@c page
@node sockets
@chapter Networking sockets


@menu
* sockets inames::              Socket interface names.
* sockets in_addr::             Address format @objtype{mmux_libc_in_addr_t}.
* sockets insix_addr::          Address format @objtype{mmux_libc_insix_addr_t}.
* sockets sockaddr_un::         Address format @objtype{mmux_libc_sockaddr_un_t}.
* sockets sockaddr_in::         Address format @objtype{mmux_libc_sockaddr_in_t}.
* sockets sockaddr_insix::      Address format @objtype{mmux_libc_sockaddr_insix_t}.
* sockets sockaddr::            Address format @objtype{mmux_libc_sockaddr_t}.
* sockets addrinfo::            Address informations.
* sockets hostsdb::             Hosts database.
* sockets servicesdb::          Services database.
* sockets protocolsdb::         Protocols database.
* sockets networksdb::          Networks database.
* sockets byteorder::           Converting byte order in socket addresses.
* sockets convaddr::            Converting socket addresses between formats.
* sockets getaddrinfo::         Getting address informations.
* sockets getnameinfo::         Getting address name informations.
* sockets creating::            Sockets: creating, pairs, shutting down, inspecting.
* sockets stream::              Sending and receiving data through a stream socket.
* sockets server::              Stream socket servers.
* sockets client::              Stream socket clients.
* sockets dgram::               Sending and receiving data through a datagram socket.
* sockets options::             Socket options.
@end menu

@c page
@node sockets inames
@section Socket interface names


@MmuxCStructOpaqueTypedef{if_nameindex}
@MmuxCStructPointerOpaqueTypedef{if_nameindex}
@MmuxSetterGetter{if_nameindex, if_index, mmux_uint_t}
@MmuxSetterGetter{if_nameindex, if_name,  mmux_asciizcp_t}
@MmuxStructDumper{if_nameindex}


@deftypefun bool mmux_libc_if_nametoindex (mmux_uint_t * @var{index_p}, mmux_asciizcp_t @var{network_interface_name})
@MmuxCInterface{if_nametoindex}.

@example
mmux_asciizcp_t         network_interface_name = "eth0";
mmux_uint_t             network_interface_index;

if (mmux_libc_if_nametoindex(&network_interface_index, network_interface_name)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_indextoname (mmux_asciizp_t @var{result_network_interface_name}, mmux_uint_t @var{network_interface_index})
@MmuxCInterface{if_indextoname}.

@example
mmux_uint_t     network_interface_index = 2;
char            network_interface_name[MMUX_LIBC_IFNAMSIZ];

if (mmux_libc_if_indextoname(network_interface_name, network_interface_index) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_nameindex (mmux_libc_if_nameindex_t const * * @var{result_nameindex_array_p})
@MmuxCInterface{if_nameindex}.

@example
mmux_libc_if_nameindex_t const *        nameindex_array;

if (mmux_libc_if_nameindex(&nameindex_array)) @{
  /* error */
@}

for (int i=0; true; ++i) @{
  mmux_uint_t           if_index;
  mmux_asciizcp_t       if_name;

  mmux_libc_if_index_ref(&if_index, A + i);
  mmux_libc_if_name_ref (&if_name,  A + i);

  if (if_index) @{
    /* do something with "if_index" and "if_name" */
  @} else @{
    break;
  @}
@}

mmux_libc_if_freenameindex(nameindex_array);
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_freenameindex (mmux_libc_if_nameindex_t const * @var{nameindex_array})
@MmuxCInterface{if_freenameindex}.
@end deftypefun

@c page
@node sockets in_addr
@section Address format @objtype{mmux_libc_in_addr_t}


Data structures of type @objtype{mmux_libc_in_addr_t} represent IPv4 addresses in numerical form, as
32-bit values stored in network byte order.


@MmuxCStructOpaqueTypedef{in_addr}
@MmuxCStructPointerOpaqueTypedef{in_addr}
@MmuxSetterGetter{in_addr, s_addr, mmux_uint32_t}
@MmuxStructDumper{in_addr}


@deftypefun bool mmux_libc_make_in_addr (mmux_libc_in_addr_t * in_addr_p, mmux_uint32_t network_byteorder_value)
Initialise the data structure referenced by @var{in_addr_p} to the address
@var{network_byteorder_value}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_none (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_NONE}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_any (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_ANY}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_broadcast (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_BROADCAST}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_loopback (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_LOOPBACK}.
@end deftypefun

@c page
@node sockets insix_addr
@section Address format @objtype{mmux_libc_insix_addr_t}


Data structures of type @objtype{mmux_libc_insix_addr_t} represent IPv6 addresses in binary format.


@deftp {Opaque Struct Typedef} mmux_libc_insix_addr_t
An opaque alias for @code{struct in6_addr}.
@end deftp

@MmuxCStructPointerOpaqueTypedef{insix_addr}
@MmuxStructDumper{insix_addr}


@deftypefun bool mmux_libc_make_insix_addr_loopback (mmux_libc_insix_addr_t * @var{insix_addr_p})
Initialise the data structure referenced by @var{insix_addr_p} to the predefined standard
@code{in6addr_loopback}.
@end deftypefun


@deftypefun bool mmux_libc_make_insix_addr_any (mmux_libc_insix_addr_t * @var{insix_addr_p})
Initialise the data structure referenced by @var{insix_addr_p} to the predefined standard
@code{in6addr_any}.
@end deftypefun

@c page
@node sockets sockaddr_un
@section Address format @objtype{mmux_libc_sockaddr_un_t}


@MmuxCStructOpaqueTypedef{sockaddr_un}
@MmuxCStructPointerOpaqueTypedef{sockaddr_un}
@MmuxSetterGetter{sockaddr_un, sun_family, mmux_sshort_t}
@MmuxSetterGetter{sockaddr_un, sun_path,   mmux_libc_file_system_pathname_t}
@MmuxStructDumper{sockaddr_un}


The file system pathname associated to an address of format @objtype{mmux_libc_sockaddr_un_t} is
embedded in the data structure itself; it has maximum length of fixed size, hard--coded in the data
structure definition.  The pathname must be an @asciiz{} string and the terminating nul must be
included in the embedded @asciiz{} string.

If we want to allocate a block of memory wide enough to contain a pathname of maximum length we have
to take the @cfunc{sizeof} of the data structure type.  If we want to compute the address size
needed as arguments by some socket functions: we have to use the following function.


@deftypefun mmux_usize_t mmux_libc_SUN_LEN (mmux_libc_sockaddr_un_t const * @var{sockaddr_un_p})
Return the address size, measured in bytes, of the address data structure referenced by
@var{sockaddr_un_p}.

@itemize
@item
The returned size does @strong{not} include the terminating nul of the included file pathname.

@item
The returned size is the correct value to hand to functions requiring the address size, like
@cfunc{mmux_libc_bind}.
@end itemize
@end deftypefun

@c page
@node sockets sockaddr_in
@section Address format @objtype{mmux_libc_sockaddr_in_t}


@MmuxCStructOpaqueTypedef{sockaddr_in}
@MmuxCStructPointerOpaqueTypedef{sockaddr_in}
@MmuxSetterGetter{sockaddr_in, sin_family, mmux_sshort_t}
@MmuxSetterGetter{sockaddr_in, sin_addr,   mmux_libc_in_addr_t}
@MmuxSetterGetter{sockaddr_in, sin_port,   mmux_host_byteorder_ushort_t}
@MmuxStructDumper{sockaddr_in}


@deftypefun bool mmux_libc_sin_addr_p_ref (mmux_libc_in_addr_t ** sin_addr_pp, mmux_libc_sockaddr_in_t * sockaddr_p)
Store in the location referenced by @var{sin_addr_pp} a pointer to the field @code{sin_addr} of the
data structure referenced by @var{sockaddr_p}.
@end deftypefun

@c page
@node sockets sockaddr_insix
@section Address format @objtype{mmux_libc_sockaddr_insix_t}


To ease typing on keyboards, @value{PACKAGE} renames: the name of the data structure @code{struct
sockaddr_in6} to @objtype{mmux_libc_sockaddr_insix_t}; the fields @code{sin6_} of @code{struct
sockaddr_in6} to @code{sinsix_}.


@deftp {Opaque Struct Typedef} mmux_libc_sockaddr_insix_t
An opaque alias for @code{struct sockaddr_in6}.
@end deftp


@MmuxCStructPointerOpaqueTypedef{sockaddr_insix}
@MmuxSetterGetter{sockaddr_insix, sinsix_family,   mmux_sshort_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_addr,     mmux_libc_insix_addr_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_flowinfo, mmux_uint32_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_scope_id, mmux_uint32_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_port,     mmux_host_byteorder_uint16_t}
@MmuxStructDumper{sockaddr_insix}


@deftypefun bool mmux_libc_sinsix_addr_p_ref (mmux_libc_insix_addr_t ** @var{sin_addr_pp}, mmux_libc_sockaddr_in_t * @var{sockaddr_p})
Store in the location referenced by @var{sinsix_addr_pp} a pointer to the field @code{sinsix_addr}
of the data structure referenced by @var{sockaddr_p}.
@end deftypefun

@c page
@node sockets sockaddr
@section Address format @objtype{mmux_libc_sockaddr_t}


@deftp {Opaque Struct Typedef} mmux_libc_sockaddr_t
An opaque alias for a non--standard data structure type: we can handle this type as being big enough
to contain any of the data structure types @code{struct sockaddr_*}.  @value{PACKAGE} uses this data
type as alias for @MmuxCStruct{sockaddr}.
@end deftp

@MmuxCStructPointerOpaqueTypedef{sockaddr}
@MmuxSetterGetter{sockaddr, sa_family,   mmux_sshort_t}
@MmuxStructDumper{sockaddr}

@c page
@node sockets addrinfo
@section Address informations


@MmuxCStructOpaqueTypedef{addrinfo}
@MmuxCStructPointerOpaqueTypedef{addrinfo}
@MmuxSetterGetter{addrinfo, ai_flags,           mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_family,          mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_socktype,        mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_protocol,        mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_addrlen,         mmux_socklen_t}
@MmuxSetterGetter{addrinfo, ai_addr,            mmux_libc_sockaddr_t *}
@MmuxSetterGetter{addrinfo, ai_canonname,       mmux_asciizp_t}
@MmuxSetterGetter{addrinfo, ai_next,            mmux_libc_addrinfo_t *}
@MmuxStructDumper{addrinfo}

@c page
@node sockets hostsdb
@section Hosts database


@MmuxCStructOpaqueTypedef{hostent}
@MmuxCStructPointerOpaqueTypedef{hostent}
@MmuxSetterGetter{hostent, h_name,              mmux_asciizp_t}
@MmuxSetterGetter{hostent, h_aliases,           mmux_asciizpp_t}
@MmuxSetterGetter{hostent, h_addrtype,          mmux_sint_t}
@MmuxSetterGetter{hostent, h_length,            mmux_sint_t}
@MmuxSetterGetter{hostent, h_addr_list,         mmux_asciizpp_t}
@MmuxSetterGetter{hostent, h_addr,              mmux_asciizp_t}
@MmuxStructDumper{hostent}


@deftypefun bool mmux_libc_sethostent (bool @var{stayopen})
@MmuxCInterface{sethostent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endhostent (void)
@MmuxCInterface{endhostent}.
@end deftypefun


@deftypefun bool mmux_libc_gethostent (mmux_libc_hostent_t const * * @var{result_hostent_pp})
@MmuxCInterface{gethostent}.
@end deftypefun

@c page
@node sockets servicesdb
@section Services database


@MmuxCStructOpaqueTypedef{servent}
@MmuxCStructPointerOpaqueTypedef{servent}
@MmuxSetterGetter{servent, s_name,		mmux_asciizp_t}
@MmuxSetterGetter{servent, s_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{servent, s_port,		mmux_sint_t}
@MmuxSetterGetter{servent, s_proto,		mmux_asciizp_t}
@MmuxStructDumper{servent}


@deftypefun bool mmux_libc_setservent (bool @var{stayopen})
@MmuxCInterface{setservent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endservent (void)
@MmuxCInterface{endservent}.
@end deftypefun


@deftypefun bool mmux_libc_getservent (mmux_libc_servent_t const * * @var{result_servent_pp})
@MmuxCInterface{getservent}.
@end deftypefun


@deftypefun bool mmux_libc_getservbyname(mmux_libc_servent_t const * * @var{result_servent_pp}, mmux_asciizcp_t @var{service_name_p}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getservbyname}.  If an error occurs: @var{result_servent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_servent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 service_name_p  = "smtp";
mmux_asciizcp_t                 protocol_name_p = "tcp";
mmux_libc_servent_t const *     servent_p;

if (mmux_libc_getservbyname(&servent_p, service_name_p, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getservbyport (mmux_libc_servent_t const * * @var{result_servent_pp}, mmux_sint_t @var{host_byteorder_port}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getservbyport}.  If an error occurs: @var{result_servent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_servent_pp} is never set to
@cnull{}.

@example
mmux_sint_t                     host_byteorder_port = 25;
mmux_asciizcp_t                 protocol_name_p     = "tcp";
mmux_libc_servent_t const *     servent_p;

if (mmux_libc_getservbyport(&servent_p, host_byteorder_port, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node sockets protocolsdb
@section Protocols database


@MmuxCStructOpaqueTypedef{protoent}
@MmuxCStructPointerOpaqueTypedef{protoent}
@MmuxSetterGetter{protoent, p_name,		mmux_asciizp_t}
@MmuxSetterGetter{protoent, p_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{protoent, p_proto,		mmux_sint_t}
@MmuxStructDumper{protoent}


@deftypefun bool mmux_libc_setprotoent (bool @var{stayopen})
@MmuxCInterface{setprotoent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endprotoent (void)
@MmuxCInterface{endprotoent}.
@end deftypefun


@deftypefun bool mmux_libc_getprotoent (mmux_libc_protoent_t const * * @var{result_protoent_pp})
@MmuxCInterface{getprotoent}.
@end deftypefun


@deftypefun bool mmux_libc_getprotobyname (mmux_libc_protoent_t const * * @var{result_protoent_pp}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getprotobyname}.  If an error occurs: @var{result_protoent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_protoent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 protocol_name_p = "tcp";
mmux_libc_protoent_t const *    protoent_p;

if (mmux_libc_getprotobyname(&protoent_p, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getprotobynumber (mmux_libc_protoent_t const * * @var{result_protoent_pp}, mmux_sint_t @var{proto})
@MmuxCInterface{getprotobynumber}.  If an error occurs: @var{result_protoent_pp} is left untouched
and the return value is @ctrue{}.  The location referenced by @var{result_protoent_pp} is never set
to @cnull{}.

@example
mmux_libc_protoent_t const *    protoent_p;

if (mmux_libc_getprotobyname(&protoent_p, MMUX_LIBC_IPPROTO_TCP)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node sockets networksdb
@section Networks database


@MmuxCStructOpaqueTypedef{netent}
@MmuxCStructPointerOpaqueTypedef{netent}
@MmuxSetterGetter{netent, n_name,		mmux_asciizp_t}
@MmuxSetterGetter{netent, n_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{netent, n_addrtype,		mmux_sint_t}
@MmuxSetterGetter{netent, n_net,		mmux_ulong_t}
@MmuxStructDumper{netent}


@deftypefun bool mmux_libc_setnetent (bool @var{stayopen})
@MmuxCInterface{setnetent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endnetent (void)
@MmuxCInterface{endnetent}.
@end deftypefun


@deftypefun bool mmux_libc_getnetent (mmux_libc_netent_t const * * @var{result_netent_pp})
@MmuxCInterface{getnetent}.
@end deftypefun


@deftypefun bool mmux_libc_getnetbyname (mmux_libc_netent_t const * * @var{result_netent_pp}, mmux_asciizcp_t @var{network_name_p})
@MmuxCInterface{getnetbyname}.  If an error occurs: @var{result_netent_pp} is left untouched and the
return value is @ctrue{}.  The location referenced by @var{result_netent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 network_name_p = "loopback";
mmux_libc_netent_t const *      netent_p;

if (mmux_libc_getnetbyname(&netent_p, network_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getnetbyaddr (mmux_libc_netent_t const * * @var{result_netent_pp}, mmux_uint32_t @var{n_net}, mmux_sint_t @var{af_type})
@MmuxCInterface{getnetbyaddr}.  If an error occurs: @var{result_netent_pp} is left untouched and the
return value is @ctrue{}.  The location referenced by @var{result_netent_pp} is never set to
@cnull{}.

The argument @var{n_net} is homogeneous to the values of the field @samp{n_net} of
@MmuxCStruct{netent}: the network address in host byteorder.

@example
mmux_asciizcp_t                 dotted_quad = "127.0.0.0";
mmux_libc_in_addr_t             address;
mmux_uint32_t                   netw_byteorder_n_net;
mmux_uint32_t                   host_byteorder_n_net;
mmux_libc_netent_t const *      netent_p;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET, dotted_quad)) @{
  /* error */
@}
mmux_libc_s_addr_ref(&netw_byteorder_n_net, &address);
mmux_libc_ntohl(&host_byteorder_n_net, netw_byteorder_n_net);
if (mmux_libc_getnetbyaddr(&netent_p, host_byteorder_n_net, MMUX_LIBC_AF_INET)) @{
  /* error */
@}
/* do something with "netent_p" */
@end example
@end deftypefun

@c page
@node sockets byteorder
@section Converting byte order in socket addresses


@deftypefun bool mmux_libc_htons (mmux_uint16_t * network_byteorder_value_p, mmux_uint16_t host_byteorder_value)
@MmuxCInterface{htons}.  Host--to--network short--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_ntohs (mmux_uint16_t * host_byteorder_value_p, mmux_uint16_t network_byteorder_value)
@MmuxCInterface{ntohs}.  Network--to--host short--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_htonl (mmux_uint32_t * network_byteorder_value_p, mmux_uint32_t host_byteorder_value)
@MmuxCInterface{htonl}.  Host--to--network long--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_ntohl (mmux_uint32_t * host_byteorder_value_p, mmux_uint32_t network_byteorder_value)
@MmuxCInterface{ntohl}.  Network--to--host long--number byte order conversion.
@end deftypefun

@c page
@node sockets convaddr
@section Converting socket addresses between formats


@deftypefun bool mmux_libc_inet_pton (mmux_pointer_t @var{ouput_addr_p}, mmux_sint_t @var{input_af_family}, mmux_asciizcp_t @var{input_presentation_p})
@MmuxCInterface{inet_pton}.

Convert the @asciiz{} Internet address presentation referenced by @var{input_presentation_p} into a
binary data structure; the presentation is expected to represent an address in the format specified
by @var{input_af_family}, for example @samp{MMUX_LIBC_AF_INET} or @samp{MMUX_LIBC_AF_INET6}.

When successful, the resulting data structure is stored in the buffer referenced by
@var{ouput_addr_p}; when @var{input_af_family} equals:

@table @samp
@item MMUX_LIBC_AF_INET
The referenced buffer must be a data structure of type @objtype{mmux_libc_in_addr_t}.

@item MMUX_LIBC_AF_INET6
The referenced buffer must be a data structure of type @objtype{mmux_libc_insix_addr_t}.
@end table

Example:

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET, dotted_quad)) @{
  /* error */
@}
@end example

Example:

@example
mmux_asciizcp_t         presentation = "1:2:3:4:5:6:7:8";
mmux_libc_insix_addr_t  address;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET6, presentation)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_ntop (mmux_asciizp_t @var{ouput_presentation_p}, mmux_usize_t @var{ouput_presentation_provided_nchars}, mmux_sint_t @var{input_af_family}, mmux_pointer_t @var{input_addr_p})
@MmuxCInterface{inet_ntop}.

Convert the Internet address data structure referenced by @var{input_addr_p} in its @asciiz{}
presentation and copy it into the buffer referenced by @var{ouput_presentation_p}; the data
structure is expected to represent an address in the format specified by @var{input_af_family}, for
example @samp{MMUX_LIBC_AF_INET} or @samp{MMUX_LIBC_AF_INET6}; when @var{input_af_family} equals:

@table @samp
@item MMUX_LIBC_AF_INET
The referenced data structure must be of type @objtype{mmux_libc_in_addr_t}.

@item MMUX_LIBC_AF_INET6
The referenced data structure must be of type @objtype{mmux_libc_insix_addr_t}.
@end table

If the length of the @asciiz{} presentation, including its terminating nul, is less than or equal to
@var{ouput_presentation_provided_nchars}: the whole string, including its terminating nul, is
written in the output buffer; then the return value if @cfalse{}.  Otherwise nothing is written and
the return value is @ctrue{}.

Example:

@example
mmux_libc_in_addr_t     address;

if (mmux_libc_make_in_addr_broadcast(&address)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntop(str, IS_THIS_ENOUGH_QUESTION_MARK, MMUX_LIBC_AF_INET, &address)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example

Example:

@example
mmux_libc_insix_addr_t     address;

if (mmux_libc_make_insix_addr_loopback(&address)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntop(str, IS_THIS_ENOUGH_QUESTION_MARK, MMUX_LIBC_AF_INET6, &address)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_inet_aton (mmux_libc_in_addr_ptr_t @var{ouput_addr_p}, mmux_asciizcp_t @var{input_presentation_p})
@MmuxCInterface{inet_aton}.

Convert the dotted--quad @asciiz{} representation of an IPv4 address referenced by
@var{input_presentation_p} into a data structure of type @objtype{mmux_libc_in_addr_t}; store the
result in the data structure referenced by @var{ouput_addr_p}.

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_aton(&address, dotted_quad)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_ntoa (mmux_asciizp_t @var{ouput_presentation_p}, mmux_usize_t @var{ouput_presentation_provided_nchars}, mmux_libc_in_addr_t * @var{input_addr_p})
@MmuxCInterface{inet_ntoa}.

Convert the IPv4 address referenced by @var{input_addr_p} in its dotted--quad @asciiz{} presentation
and copy it into the buffer referenced by @var{ouput_presentation_p}.

If the length of the @asciiz{} presentation, including its terminating nul, is less than or equal to
@var{ouput_presentation_provided_nchars}: the whole string, including its terminating nul, is
written in the output buffer; then the return value if @cfalse{}.  Otherwise nothing is written and
the return value is @ctrue{}.

@example
mmux_libc_in_addr_t     in_addr;

if (mmux_libc_make_in_addr_broadcast(&in_addr)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntoa(str, IS_THIS_ENOUGH_QUESTION_MARK, &in_addr)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_addr (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_asciizcp_t @var{presentation_in_addr_p})
@MmuxCInterface{inet_addr}.

If an error occurs: the location referenced by @var{result_in_addr_p} is left untouched; the return
value if @ctrue{}.

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_addr(&address, dotted_quad)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_network (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_asciizcp_t @var{presentation_in_addr_p})
@MmuxCInterface{inet_addr}.

If an error occurs: the location referenced by @var{result_in_addr_p} is left untouched; the return
value if @ctrue{}.
@end deftypefun


@deftypefun bool mmux_libc_inet_makeaddr (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_libc_in_addr_ptr_t @var{net_in_addr_p}, mmux_libc_in_addr_ptr_t @var{local_in_addr_p})
@MmuxCInterface{inet_makeaddr}.
@end deftypefun


@deftypefun bool mmux_libc_inet_lnaof (mmux_libc_in_addr_ptr_t @var{local_in_addr_p}, mmux_libc_in_addr_ptr_t @var{in_addr_p})
@MmuxCInterface{inet_lnaof}.
@end deftypefun


@deftypefun bool mmux_libc_inet_netof (mmux_libc_in_addr_ptr_t @var{net_in_addr_p}, mmux_libc_in_addr_ptr_t @var{in_addr_p})
@MmuxCInterface{inet_netof}.
@end deftypefun

@c page
@node sockets getaddrinfo
@section Getting address informations


Usage example:

@example
mmux_asciizcp_t                 node    = "localhost";
mmux_asciizcp_t                 service = "smtp";
mmux_libc_addrinfo_t            hints;

mmux_libc_addrinfo_ptr_t        addrinfo_linked_list_p;
mmux_sint_t                     error_code;

mmux_libc_ai_flags_set    (&hints, MMUX_LIBC_AI_V4MAPPED | MMUX_LIBC_AI_ADDRCONFIG | MMUX_LIBC_AI_CANONNAME);
mmux_libc_ai_family_set   (&hints, MMUX_LIBC_AF_UNSPEC);
mmux_libc_ai_socktype_set (&hints, MMUX_LIBC_SOCK_STREAM);
mmux_libc_ai_protocol_set (&hints, MMUX_LIBC_IPPROTO_TCP);

if (mmux_libc_getaddrinfo(&addrinfo_linked_list, &error_code, node, service, &hints)) @{
  mmux_asciizcp_t      error_message;

  mmux_libc_gai_strerror(&error_message, error_code);
  /* handle the error */
@} else @{
  /* do something with "addrinfo_linked_list_p" */

  mmux_libc_freeaddrinfo(addrinfo_linked_list_p);
@}
@end example


@deftypefun bool mmux_libc_getaddrinfo (mmux_libc_addrinfo_ptr_t * @var{result_addrinfo_linked_list_pp}, mmux_sint_t * @var{result_error_code_p}, mmux_asciizcp_t @var{node}, mmux_asciizcp_t @var{service}, mmux_libc_addrinfo_ptr_t @var{hints_p})
@MmuxCInterface{getaddrinfo}.
@end deftypefun


@deftypefun bool mmux_libc_freeaddrinfo (mmux_libc_addrinfo_ptr_t @var{addrinfo_linked_list_p})
@MmuxCInterface{freeaddrinfo}.
@end deftypefun


@deftypefun bool mmux_libc_gai_strerror (mmux_asciizcp_t * @var{result_error_message_p}, mmux_sint_t @var{errnum})
@MmuxCInterface{gai_strerror}.
@end deftypefun

@c page
@node sockets getnameinfo
@section Getting address name informations


Usage example:

@example
mmux_libc_sockaddr_in_t input_sockaddr;
mmux_sint_t             error_code;
mmux_sint_t             flags = 0;

#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	512
char                    hostname[IS_THIS_ENOUGH_QUESTION_MARK];
char                    servname[IS_THIS_ENOUGH_QUESTION_MARK];

gimme_an_address(&input_sockaddr);

if (mmux_libc_getnameinfo (hostname, IS_THIS_ENOUGH_QUESTION_MARK,
                           servname, IS_THIS_ENOUGH_QUESTION_MARK,
                           &error_code,
                           &input_sockaddr, sizeof(mmux_libc_sockaddr_in_t), flags)) @{
  mmux_asciizcp_t      error_message;

  mmux_libc_gai_strerror(&error_message, error_code);
  /* handle the error */
@} else @{
  /* do something with "hostname" and "servname" */
@}
@end example


@deftypefun bool mmux_libc_getnameinfo (mmux_asciizcp_t @var{result_hostname_p}, mmux_socklen_t @var{provided_hostname_len}, mmux_asciizcp_t @var{result_servname_p}, mmux_socklen_t @var{provided_servname_len}, mmux_sint_t * @var{result_error_code_p}, mmux_libc_sockaddr_ptr_t @var{input_sockaddr_p}, mmux_socklen_t @var{input_sockaddr_size}, mmux_sint_t @var{flags})
@MmuxCInterface{getnameinfo}.
@end deftypefun

@c page
@node sockets creating
@section Sockets: creating, pairs, shutting down, inspecting


@deftp {Opaque Typedef} mmux_libc_network_socket_t
An alias for @objtype{mmux_libc_file_descriptor_t} representing a networking socket.
@end deftp


@deftypefun bool mmux_libc_make_network_socket (mmux_libc_network_socket_t * @var{result_p}, mmux_sint_t @var{sock_num})
Initialise the value referenced by @var{result_p} with the given integer.
@end deftypefun


@deftypefun bool mmux_libc_socket (mmux_libc_network_socket_t * @var{result_sock_p}, mmux_sint_t @var{pf_namespace}, mmux_sint_t @var{sock_style}, mmux_sint_t @var{ipproto})
@MmuxCInterface{socket}.

@example
mmux_libc_network_socket_t      sock;

if (mmux_libc_socket(&sock, MMUX_LIBC_PF_INET, MMUX_LIBC_SOCK_STREAM, MMUX_LIBC_IPPROTO_TCP)) @{
  /* error */
@}

mmux_libc_shutdown(sock, MMUX_LIBC_SHUT_RDWR);
@end example
@end deftypefun


@deftypefun bool mmux_libc_shutdown (mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{shut_how})
@MmuxCInterface{shutdown}.
@end deftypefun


@deftypefun bool mmux_libc_socketpair (mmux_libc_network_socket_t * @var{result_sock1_p}, mmux_libc_network_socket_t * @var{result_sock2_p}, mmux_sint_t @var{pf_namespace}, mmux_sint_t @var{sock_style}, mmux_sint_t @var{ipproto})
@MmuxCInterface{socketpair}.

@example
mmux_libc_network_socket_t      sock1, sock2;

if (mmux_libc_socketpair(&sock1, &sock2, MMUX_LIBC_PF_LOCAL, MMUX_LIBC_SOCK_STREAM, MMUX_LIBC_IPPROTO_IP)) @{
  /* error */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_getpeername (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t * @var{provided_sockaddr_size})
@MmuxCInterface{getpeername}.

@example
mmux_libc_network_socket_t      sock;
mmux_libc_sockaddr_t            sockaddr;
mmux_socklen_t                  sockaddr_size = sizeof(mmux_libc_sockaddr_t);

gimme_a_stream_sock(&sock);

if (mmux_libc_getpeername(sock, &sockaddr, &sockaddr_size)) @{
  /* error */
@}

/* do something with "sockaddr", whose real size is "sockaddr_size" */
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_getsockname (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t * @var{provided_sockaddr_size})
@MmuxCInterface{getsockname}.

@example
mmux_libc_network_socket_t      sock;
mmux_libc_sockaddr_t            sockaddr;
mmux_socklen_t                  sockaddr_size = sizeof(mmux_libc_sockaddr_t);

gimme_a_stream_sock(&sock);

if (mmux_libc_getsockname(sock, &sockaddr, &sockaddr_size)) @{
  /* error */
@}

/* do something with "sockaddr", whose real size is "sockaddr_size" */
@end example
@end deftypefun

@c page
@node sockets stream
@section Sending and receiving data through a stream socket


@deftypefun bool mmux_libc_send (mmux_usize_t * @var{result_number_of_bytes_sent_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{send}.
@end deftypefun


@deftypefun bool mmux_libc_recv (mmux_usize_t * @var{result_number_of_bytes_received_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{recv}.
@end deftypefun

@c page
@node sockets server
@section Stream socket servers


@deftypefun bool mmux_libc_bind (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t @var{sockaddr_size})
@MmuxCInterface{bind}.
@end deftypefun


@deftypefun bool mmux_libc_listen (mmux_libc_network_socket_t @var{sock}, mmux_uint_t @var{pending_connections_queue_length}a)
@MmuxCInterface{listen}.
@end deftypefun


@deftypefun bool mmux_libc_accept (mmux_libc_network_socket_t * @var{result_connected_sock_p}, mmux_libc_sockaddr_ptr_t @var{result_client_sockaddr_p}, mmux_socklen_t * @var{result_client_sockaddr_size_p}, mmux_libc_network_socket_t @var{server_sock})
@MmuxCInterface{accept}.

@itemize
@item
Upon calling: the location referenced by @var{result_client_sockaddr_size_p} must be set to the
number of bytes allocated for the address referenced by @var{result_client_sockaddr_p}.

@item
Upon successfully returning: the location referenced by @var{result_client_sockaddr_size_p} is reset
to the actual size of the client address.
@end itemize
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_accept4 (mmux_libc_network_socket_t * @var{result_connected_sock_p}, mmux_libc_sockaddr_ptr_t @var{result_client_sockaddr_p}, mmux_socklen_t * @var{result_client_sockaddr_size_p}, mmux_libc_network_socket_t @var{server_sock}, mmux_sint_t @var{flags})
@MmuxCInterface{accept4}.

@itemize
@item
Upon calling: the location referenced by @var{result_client_sockaddr_size_p} must be set to the
number of bytes allocated for the address referenced by @var{result_client_sockaddr_p}.

@item
Upon successfully returning: the location referenced by @var{result_client_sockaddr_size_p} is reset
to the actual size of the client address.
@end itemize
@end deftypefn

@c page
@node sockets client
@section Stream socket clients


@deftypefun bool mmux_libc_connect (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t @var{sockaddr_size})
@MmuxCInterface{connect}.
@end deftypefun

@c page
@node sockets dgram
@section Sending and receiving data through a datagram socket


@deftypefun bool mmux_libc_sendto (mmux_usize_t * @var{result_number_of_bytes_sent_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags}, mmux_libc_sockaddr_ptr_t @var{destination_sockaddr_p}, mmux_socklen_t @var{destination_sockaddr_size})
@MmuxCInterface{sendto}.
@end deftypefun


@deftypefun bool mmux_libc_recvfrom (mmux_usize_t * @var{result_number_of_bytes_received_p}, mmux_libc_sockaddr_ptr_t @var{result_sender_sockaddr_p}, mmux_socklen_t * @var{result_sender_sockaddr_size_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{recvfrom}.

The arguments @var{result_sender_sockaddr_p} and @var{result_sender_sockaddr_size_p} can be
@cnull{} if we are not interested in retrieving the sender address; if they are not @cnull{}:

@itemize
@item
Upon entering the call: the location referenced by @var{result_sender_sockaddr_size_p} must be set
to the number of bytes allocated to contain the sender address.

@item
Upon successfully returning from the call: the location referenced by
@var{result_sender_sockaddr_size_p} is reset to the actual number of bytes required to contain the
sender address.
@end itemize
@end deftypefun

@c page
@node sockets options
@section Socket options


@MmuxCStructOpaqueTypedef{linger}
@MmuxCStructPointerOpaqueTypedef{linger}
@MmuxSetterGetter{linger, l_onoff,		mmux_sint_t}
@MmuxSetterGetter{linger, l_linger,		mmux_sint_t}
@MmuxStructDumper{linger}


@deftypefun bool mmux_libc_getsockopt (mmux_pointer_t @var{result_optval_p}, mmux_socklen_t * @var{result_optlen_p}, mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{level}, mmux_sint_t @var{optname})
@MmuxCInterface{getsockopt}.
@end deftypefun


@deftypefun bool mmux_libc_setsockopt (mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{level}, mmux_sint_t @var{optname}, mmux_pointer_t @var{optval_p}, mmux_socklen_t @var{optlen})
@MmuxCInterface{setsockopt}.
@end deftypefun

@c page
@node interface specifications
@chapter Interface specifications


It happens that we implement an @api{} which undergoes progressive development and we want a library
to export multiple revisions of the same @api{}; it is useful to define a data structure
representing an interface version specification.

Under @value{PACKAGE}, interface specifications follow version numbering as established by the
@gnu{} Autotools for shared libraries; for an explanation of interface numbers as managed by @gnu{}
Libtool @xref{Libtool versioning, interface, Libtool's versioning system, libtool, Shared library
support for @gnu{}}.

@menu
* interface specifications projects::   Introduction to declare interface versioning for projects.
* interface specifications types::      Data types to declare interface specifications.
* interface specifications api::        Operations on interface specifications.
@end menu

@c page
@node interface specifications projects
@section Introduction to declare interface versioning for projects.


Let's say we develop a project implementing a C language library, whose public @api{} contains a
module exporting the following functions and data types:

@example
typedef struct alpha_t @{ ... @} alpha_t;
typedef struct beta_t  @{ ... @} beta_t;

extern void red   (alpha_t * A, beta_t * B);
extern void green (alpha_t * A);
extern void blue  (beta_t  * B);
@end example

@noindent
and we publish a release of this project.  If this is the first public release we should assign to
this @api{} an interface version specification with the format @samp{CURRENT:REVISION:AGE} and value
@samp{0:0:0}.  Using the facilities of @value{PACKAGE}, we could define a data structure:

@example
mmux_libc_interface_specification_t const spiffy_interface_specification = @{
  .is_name      = "My Spiffy Project",
  .is_current   = 0,
  .is_revision  = 0,
  .is_age       = 0,
@};
@end example

@noindent
and add it to the public @api{}:

@example
extern mmux_libc_interface_specification_t const spiffy_interface_specification;
@end example

@noindent
so that the process in execution can itself, at run--time, determine the available features.

Now let's say we fix some errors in the code and/or change the internal implementation for
optimisation purposes or something else; then we publish another release; we notice that:

@itemize
@item
nothing has changed in the type declarations and the function prototypes;

@item
all the functions perform the same operations as before;

@item
nothing has changed in the relations between input arguments, output results and side effects; or,
maybe, some results and side effects have changed because of error fixes, but the intended meaning
of results and side effects is the same;
@end itemize

@noindent
we should increment the @samp{REVISION} component, so that the interface version specification
becomes @samp{0:1:0}.  The client code the library is linked with can determine if the fixes are
available by inspecting the @samp{REVISION} component:

@itemize
@item
if it is @samp{0}, the library's implementation does not contain the latest fixes; it means the
package installed on the system has not been upgraded to the latest revision;

@item
if it is @samp{1}, the package has been upgraded.
@end itemize

@c ------------------------------------------------------------------------

@subsection Project's development continues

We add a new function:

@example
extern void transparency (alpha_t * A);
@end example

@noindent
now the @api{} has changed, but the old @api{} is still available; we should:

@enumerate
@item
increment the @samp{CURRENT} component to @samp{1}, to signal that the @api{} has changed;

@item
reset the @samp{REVISION} component to @samp{0}, to signal that the available @api{} is the first
released for @samp{CURRENT} version number @samp{1};

@item
set the @samp{AGE} component to @samp{1}, to signal that the new @api{} having @samp{CURRENT}
version number @samp{1} is compatible with the old @api{} having @samp{CURRENT} version number
@samp{1 - AGE = 1 - 1 = 0}.
@end enumerate

@c ------------------------------------------------------------------------

@subsection Project's development continues again

We add a new function:

@example
extern void glossy (beta_t * B);
@end example

@noindent
the @api{} has changed again, but the old @api{}s are still available; we should:

@enumerate
@item
increment the @samp{CURRENT} component to @samp{2}, to signal that the @api{} has changed;

@item
reset the @samp{REVISION} component to @samp{0}, to signal that the available @api{} is the first
released for @samp{CURRENT} version number @samp{2};

@item
set the @samp{AGE} component to @samp{2}, to signal that the new @api{} having @samp{CURRENT}
version number @samp{2} is compatible with the old @api{}s having @samp{CURRENT} version number in
the inclusive range @samp{2 - AGE = 2 - 2 = 0} and @samp{2}; we can link with this new library
client code that expects the @api{} to be compatible with all the version numbers @samp{0},
@samp{1}, @samp{2}.
@end enumerate

@c ------------------------------------------------------------------------

@subsection Project's development continues again again

We remove the old function:

@example
extern void blue (beta_t * B);
@end example

@noindent
because it has become obsolete; the @api{} has changed again, and the old @api{}s are not available
anymore; we should:

@enumerate
@item
increment the @samp{CURRENT} component to @samp{3}, to signal that the @api{} has changed;

@item
reset the @samp{REVISION} component to @samp{0}, to signal that the available @api{} is the first
released for @samp{CURRENT} version number @samp{3};

@item
reset the @samp{AGE} component to @samp{0}, to signal that the old @api{}s are no more available,
only the @api{} having @samp{CURRENT} version number @samp{3} is available.
@end enumerate

@c page
@node interface specifications types
@section Data types to declare interface specifications


@deftp {Struct Typedef} mmux_libc_interface_specification_t
Data structure representing an interface specification.

@table @code
@item mmux_asciizcp_t is_name
Pointer to a, possibly statically--allocated, @asciiz{} string representing the name of this
interface; there are no constraints on the string's format.

@item mmux_standard_uint_t is_current
Interface's current version number.  The starting value should be @samp{0}.

@item mmux_standard_uint_t is_revision
Interface's revision number.  The starting value should be @samp{0}.

@item mmux_standard_uint_t is_age
Interface's age number.  The starting value should be @samp{0}.
@end table
@end deftp

@c page
@node interface specifications api
@section Operations on interface specifications


@deftypefun bool mmux_libc_interface_specification_is_compatible (bool * @var{result_p}, mmux_libc_interface_specification_t const * @var{IS}, mmux_uint_t @var{requested_version})
If @var{requested_version} is compatible with the interface specification referenced by @var{IS}:
store @ctrue{} in the variable referenced by @var{result_p}; otherwise store @cfalse{}.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
the package @mmux{} CC Types is available online:

@center @url{https://github.com/marcomaggi/mmux-cc-types/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

