\input texinfo.tex
@c %**start of header
@setfilename mmux-cc-libc.info
@settitle MMUX CC Types
@c %**end of header

@c @include version.texi
@include mmux-version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX CC Libc

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX CC Libc

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-cc-libc

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024, 2025

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_CC_LIBC
@set PackagePkgconfigModule             mmux-cc-libc
@set PackageLibsVar                     @env{MMUX_CC_LIBC_LIBS}
@set PackageCflagsVar                   @env{MMUX_CC_LIBC_CFLAGS}
@c This is the stem of the library in "libmmux-cc-libc.so".
@set PackageLibstem                     mmux-cc-libc
@set PackageApiPrefixLower              mmux_
@set PackageApiPrefixUpper              MMUX_

@set PackageHeader                      mmux-cc-libc.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@macro mmuxcctypesref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,mmux-cc-types}
@end macro

@macro MmuxCFuncpage{FUNCNAME}
@ref{\FUNCNAME\,\FUNCNAME\,\FUNCNAME\,*manpages*}
@end macro

@macro MmuxCStruct{NAME}
@code{struct \NAME\}
@end macro

@macro MmuxCInterfaceTwo{FUNCNAME,MANPAGE}
Interface to the function @cfunc{\FUNCNAME\}, @MmuxCFuncpage{\MANPAGE\}
@end macro

@macro MmuxCInterface{FUNCNAME}
@MmuxCInterfaceTwo{\FUNCNAME\,\FUNCNAME\}
@end macro

@macro MmuxCMacroInterfaceTwo{FUNCNAME,MANPAGE}
Interface to the preprocessor macro @cfunc{\FUNCNAME\}, @MmuxCFuncpage{\MANPAGE\}
@end macro

@macro MmuxCMacroInterface{FUNCNAME}
@MmuxCMacroInterfaceTwo{\FUNCNAME\,\FUNCNAME\}
@end macro

@c ------------------------------------------------------------------------

@macro MmuxCStructOpaqueTypedef{STRUCTNAME}
@deftp {Opaque Struct Typedef} mmux_libc_\STRUCTNAME\_t
An opaque alias for @MmuxCStruct{\STRUCTNAME\}.
@end deftp

@end macro

@macro MmuxCStructPointerOpaqueTypedef{STRUCTNAME}
@deftp {Opaque Struct Pointer Typedef} mmux_libc_\STRUCTNAME\_ptr_t
An opaque alias for @code{mmux_libc_\STRUCTNAME\_t *}.
@end deftp

@end macro

@macro MmuxSetterGetter{STRUCTNAME, FIELDNAME, FIELDTYPE}
@deftypefun bool mmux_libc_\FIELDNAME\_set (mmux_libc_\STRUCTNAME\_t * @var{\STRUCTNAME\_p}, \FIELDTYPE\ @var{\FIELDNAME\})
@deftypefunx bool mmux_libc_\FIELDNAME\_ref (\FIELDTYPE\ * @var{result_p}, mmux_libc_\STRUCTNAME\_t const * @var{\STRUCTNAME\_p})
Setter and getter for the field @code{\FIELDNAME\} of @objtype{mmux_libc_\STRUCTNAME\_t}.
@end deftypefun

@end macro

@macro MmuxStructDumper{STRUCTNAME}
@deftypefun bool mmux_libc_\STRUCTNAME\_dump (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_\STRUCTNAME\_t const * @var{struct_p}, mmux_asciizcp_t @var{struct_name})
Write to @var{fd} a description of the fields of the @MmuxCStruct{\STRUCTNAME\} referenced by
@var{struct_p}.  @var{struct_name} must be a pointer to an @asciiz{} string representing the name of
the data structure used in the description; when @cnull{}: it defaults to @samp{struct
\STRUCTNAME\}.
@end deftypefun

@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C11 language
library implementing a wrapper to the @gnu{} C Library that makes it easier to interface it to
high--level platforms.

The package targets @posix{} platforms.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{MmuxPkgSemanticVersion}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-cc-libc: (mmux-cc-libc).       C11 language library wrapper for the @gnu{} C Library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* constants::                   Constants.
* version::                     Version functions.
* initialisation::              Library initialisation.
* errors::                      Errors management.
* memory::                      Memory management.
* strings::                     String operations.
* characters::                  Character operations.
* time::                        Times and dates.
* system::                      System configuration.
* persona::                     Persona operations.
* processes::                   Processes.
* signals::                     Interprocess signals handling.
* fds::                         File descriptors.
* fs::                          File system.
* sockets::                     Networking sockets.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C11 language
library meant to be used in foreign functions interfaces for higher--level languages.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs multiple header files, of which @value{PackageHeaderFile} is the main one,
exporting the whole library @api{}.  All the function names in the @api{} are prefixed with
@code{@value{PackageApiPrefixLower}}; all the preprocessor symbol names are prefixed with
@code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

The library is installed under @code{$libdir}; for example:

@example
/usr/local/lib64/lib@value{PackageLibstem}.so
@end example

@noindent
C language header files are installed under @code{$includedir}, for example:

@example
/usr/local/include/@value{PackageHeaderFile}
@end example

@menu
* overview stems::              Specifying C language types with their stem.
* overview errors::             Error handling.
* overview results::            Results handling.
* overview linking::            Linking code with the shared library.
@end menu

@c page
@node overview stems
@section Specifying C language types with their stem


@value{PACKAGE} uses the type definitions of the external package @emph{@mmux{} CC Types},
@mmuxcctypesref{overview stems, Specifying C language types with their stem}.

@c page
@node overview errors
@section Error handling


Unless otherwise specified, the functions that can fail return a @objtype{bool} value: @cfalse{}
when successful; @ctrue{} when an error occurs.

If a function may not be implemented by the system or the C library: the corresponding
@value{PACKAGE} function is always implemented; its return value is a @objtype{bool} and it is
always @cfalse{}; it sets @code{errno} to @samp{MMUX_LIBC_ENOSYS}.

@c page
@node overview results
@section Results handling


Unless otherwise specified, if the first argument of a function is a pointer named @var{result_p},
@var{output_p}, @var{ouput_p}, or similar: the function will store in the referenced location the
result of the call.

For example, we can write:

@example
mmux_slong_t    result;

if (mmux_libc_sysconf(&result, MMUX_LIBC__SC_PAGESIZE)) @{
  /* error */
@}
/* the result is in "result" */
@end example

@c page

@include overview-linking.texi

@c page
@node constants
@chapter Constants


@macro MmuxDefineConstant{NAME}
@defvr {Constant} MMUX_LIBC_\NAME\
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_\NAME\
The symbol @samp{MMUX_LIBC_\NAME\} evaluates to the C language constant @code{\NAME\}; it can be
either a preprocessor symbol or an enumerated symbol; it can be defined or not depending on the
features of the underlying platform.

The symbol @samp{MMUX_HAVE_LIBC_\NAME\} is defined and it evaluates to @samp{1} if the symbol
@samp{MMUX_LIBC_\NAME\} is available.
@end defvr

@end macro

@MmuxDefineConstant{AT_EMPTY_PATH}
@MmuxDefineConstant{AT_FDCWD}
@MmuxDefineConstant{AT_NOAUTOMOUNT}
@MmuxDefineConstant{AT_REMOVEDIR}
@MmuxDefineConstant{AT_SYMLINK_FOLLOW}
@MmuxDefineConstant{EOF}
@MmuxDefineConstant{F_DUPFD}
@MmuxDefineConstant{F_GETFD}
@MmuxDefineConstant{F_GETFL}
@MmuxDefineConstant{F_GETLK}
@MmuxDefineConstant{F_GETOWN}
@MmuxDefineConstant{F_OFD_SETLK}
@MmuxDefineConstant{F_OFD_SETLKW}
@MmuxDefineConstant{F_OFD_GETLK}
@MmuxDefineConstant{F_OK}
@MmuxDefineConstant{F_RDLCK}
@MmuxDefineConstant{F_SETFD}
@MmuxDefineConstant{F_SETFL}
@MmuxDefineConstant{F_SETLK}
@MmuxDefineConstant{F_SETLKW}
@MmuxDefineConstant{F_SETOWN}
@MmuxDefineConstant{F_UNLCK}
@MmuxDefineConstant{F_WRLCK}
@MmuxDefineConstant{MAXSYMLINKS}
@MmuxDefineConstant{O_ACCMODE}
@MmuxDefineConstant{O_APPEND}
@MmuxDefineConstant{O_ASYNC}
@MmuxDefineConstant{O_CLOEXEC}
@MmuxDefineConstant{O_CREAT}
@MmuxDefineConstant{O_DIRECT}
@MmuxDefineConstant{O_DIRECTORY}
@MmuxDefineConstant{O_EXCL}
@MmuxDefineConstant{O_EXEC}
@MmuxDefineConstant{O_EXLOCK}
@MmuxDefineConstant{O_FSYNC}
@MmuxDefineConstant{O_IGNORE_CTTY}
@MmuxDefineConstant{O_LARGEFILE}
@MmuxDefineConstant{O_NDELAY}
@MmuxDefineConstant{O_NOATIME}
@MmuxDefineConstant{O_NOCTTY}
@MmuxDefineConstant{O_NOFOLLOW}
@MmuxDefineConstant{O_NOLINK}
@MmuxDefineConstant{O_NONBLOCK}
@MmuxDefineConstant{O_NOTRANS}
@MmuxDefineConstant{O_RDONLY}
@MmuxDefineConstant{O_RDWR}
@MmuxDefineConstant{O_READ}
@MmuxDefineConstant{O_SHLOCK}
@MmuxDefineConstant{O_SYNC}
@MmuxDefineConstant{O_TRUNC}
@MmuxDefineConstant{O_WRITE}
@MmuxDefineConstant{O_WRONLY}
@MmuxDefineConstant{R_OK}
@MmuxDefineConstant{RENAME_EXCHANGE}
@MmuxDefineConstant{RENAME_NOREPLACE}
@MmuxDefineConstant{RENAME_WITHEOUT}
@MmuxDefineConstant{RESOLVE_BENEATH}
@MmuxDefineConstant{RESOLVE_IN_ROOT}
@MmuxDefineConstant{RESOLVE_NO_MAGICLINKS}
@MmuxDefineConstant{RESOLVE_NO_SYMLINKS}
@MmuxDefineConstant{RESOLVE_NO_XDEV}
@MmuxDefineConstant{RESOLVE_CACHED}
@MmuxDefineConstant{SEEK_CUR}
@MmuxDefineConstant{SEEK_DATA}
@MmuxDefineConstant{SEEK_END}
@MmuxDefineConstant{SEEK_HOLE}
@MmuxDefineConstant{SEEK_SET}
@MmuxDefineConstant{S_IRGRP}
@MmuxDefineConstant{S_IROTH}
@MmuxDefineConstant{S_IRUSR}
@MmuxDefineConstant{S_IRWXG}
@MmuxDefineConstant{S_IRWXO}
@MmuxDefineConstant{S_IRWXU}
@MmuxDefineConstant{S_ISGID}
@MmuxDefineConstant{S_ISUID}
@MmuxDefineConstant{S_ISVTX}
@MmuxDefineConstant{S_IWGRP}
@MmuxDefineConstant{S_IWOTH}
@MmuxDefineConstant{S_IWUSR}
@MmuxDefineConstant{S_IXGRP}
@MmuxDefineConstant{S_IXOTH}
@MmuxDefineConstant{S_IXUSR}
@MmuxDefineConstant{MFD_CLOEXEC}
@MmuxDefineConstant{MFD_ALLOW_SEALING}
@MmuxDefineConstant{MFD_HUGETLB}
@MmuxDefineConstant{W_OK}
@MmuxDefineConstant{X_OK}
@MmuxDefineConstant{AF_ALG}
@MmuxDefineConstant{AF_APPLETALK}
@MmuxDefineConstant{AF_AX25}
@MmuxDefineConstant{AF_BLUETOOTH}
@MmuxDefineConstant{AF_CAN}
@MmuxDefineConstant{AF_DECnet}
@MmuxDefineConstant{AF_IB}
@MmuxDefineConstant{AF_INET6}
@MmuxDefineConstant{AF_INET}
@MmuxDefineConstant{AF_IPX}
@MmuxDefineConstant{AF_KCM}
@MmuxDefineConstant{AF_KEY}
@MmuxDefineConstant{AF_LLC}
@MmuxDefineConstant{AF_LOCAL}
@MmuxDefineConstant{AF_MPLS}
@MmuxDefineConstant{AF_NETLINK}
@MmuxDefineConstant{AF_PACKET}
@MmuxDefineConstant{AF_PPPOX}
@MmuxDefineConstant{AF_RDS}
@MmuxDefineConstant{AF_TIPC}
@MmuxDefineConstant{AF_UNIX}
@MmuxDefineConstant{AF_UNSPEC}
@MmuxDefineConstant{AF_VSOCK}
@MmuxDefineConstant{AF_X25}
@MmuxDefineConstant{AF_XDP}
@MmuxDefineConstant{IFNAMSIZ}
@MmuxDefineConstant{PF_FILE}
@MmuxDefineConstant{PF_INET6}
@MmuxDefineConstant{PF_INET}
@MmuxDefineConstant{PF_LOCAL}
@MmuxDefineConstant{PF_UNIX}
@MmuxDefineConstant{PF_UNSPEC}
@MmuxDefineConstant{SHUT_RDWR}
@MmuxDefineConstant{SHUT_RD}
@MmuxDefineConstant{SHUT_WR}
@MmuxDefineConstant{MSG_CONFIRM}
@MmuxDefineConstant{MSG_DONTROUTE}
@MmuxDefineConstant{MSG_DONTWAIT}
@MmuxDefineConstant{MSG_EOR}
@MmuxDefineConstant{MSG_MORE}
@MmuxDefineConstant{MSG_NOSIGNAL}
@MmuxDefineConstant{MSG_OOB}
@MmuxDefineConstant{MSG_PEEK}
@MmuxDefineConstant{SOL_SOCKET}
@MmuxDefineConstant{SO_BROADCAST}
@MmuxDefineConstant{SO_DEBUG}
@MmuxDefineConstant{SO_DONTROUTE}
@MmuxDefineConstant{SO_ERROR}
@MmuxDefineConstant{SO_KEEPALIVE}
@MmuxDefineConstant{SO_LINGER}
@MmuxDefineConstant{SO_OOBINLINE}
@MmuxDefineConstant{SO_RCVBUF}
@MmuxDefineConstant{SO_REUSEADDR}
@MmuxDefineConstant{SO_SNDBUF}
@MmuxDefineConstant{SO_STYLE}
@MmuxDefineConstant{SO_TYPE}
@MmuxDefineConstant{INADDR_ANY}
@MmuxDefineConstant{INADDR_BROADCAST}
@MmuxDefineConstant{INADDR_LOOPBACK}
@MmuxDefineConstant{INADDR_NONE}
@MmuxDefineConstant{AI_ADDRCONFIG}
@MmuxDefineConstant{AI_ADDRCONFIG}
@MmuxDefineConstant{AI_ALL}
@MmuxDefineConstant{AI_CANONIDN}
@MmuxDefineConstant{AI_CANONNAME}
@MmuxDefineConstant{AI_IDN}
@MmuxDefineConstant{AI_NUMERICSERV}
@MmuxDefineConstant{AI_PASSIVE}
@MmuxDefineConstant{AI_V4MAPPED}
@MmuxDefineConstant{NI_DGRAM}
@MmuxDefineConstant{NI_IDN}
@MmuxDefineConstant{NI_NAMEREQD}
@MmuxDefineConstant{NI_NOFQDN}
@MmuxDefineConstant{NI_NUMERICHOST}
@MmuxDefineConstant{NI_NUMERICSERV}

@MmuxDefineConstant{RWF_APPEND}
@MmuxDefineConstant{RWF_DSYNC}
@MmuxDefineConstant{RWF_HIPRI}
@MmuxDefineConstant{RWF_NOWAIT}
@MmuxDefineConstant{RWF_SYNC}

@MmuxDefineConstant{IPPROTO_AH}
@MmuxDefineConstant{IPPROTO_BEETPH}
@MmuxDefineConstant{IPPROTO_COMP}
@MmuxDefineConstant{IPPROTO_DCCP}
@MmuxDefineConstant{IPPROTO_EGP}
@MmuxDefineConstant{IPPROTO_ENCAP}
@MmuxDefineConstant{IPPROTO_ESP}
@MmuxDefineConstant{IPPROTO_ETHERNET}
@MmuxDefineConstant{IPPROTO_GRE}
@MmuxDefineConstant{IPPROTO_ICMP}
@MmuxDefineConstant{IPPROTO_IDP}
@MmuxDefineConstant{IPPROTO_IGMP}
@MmuxDefineConstant{IPPROTO_IP}
@MmuxDefineConstant{IPPROTO_IPIP}
@MmuxDefineConstant{IPPROTO_IPV6}
@MmuxDefineConstant{IPPROTO_MPLS}
@MmuxDefineConstant{IPPROTO_MPTCP}
@MmuxDefineConstant{IPPROTO_MTP}
@MmuxDefineConstant{IPPROTO_PIM}
@MmuxDefineConstant{IPPROTO_PUP}
@MmuxDefineConstant{IPPROTO_RAW}
@MmuxDefineConstant{IPPROTO_RSVP}
@MmuxDefineConstant{IPPROTO_SCTP}
@MmuxDefineConstant{IPPROTO_TCP}
@MmuxDefineConstant{IPPROTO_TP}
@MmuxDefineConstant{IPPROTO_UDP}
@MmuxDefineConstant{IPPROTO_UDPLITE}

@MmuxDefineConstant{IPPORT_BIFFUDP}
@MmuxDefineConstant{IPPORT_CMDSERVER}
@MmuxDefineConstant{IPPORT_DAYTIME}
@MmuxDefineConstant{IPPORT_DISCARD}
@MmuxDefineConstant{IPPORT_ECHO}
@MmuxDefineConstant{IPPORT_EFSSERVER}
@MmuxDefineConstant{IPPORT_EXECSERVER}
@MmuxDefineConstant{IPPORT_FINGER}
@MmuxDefineConstant{IPPORT_FTP}
@MmuxDefineConstant{IPPORT_LOGINSERVER}
@MmuxDefineConstant{IPPORT_MTP}
@MmuxDefineConstant{IPPORT_NAMESERVER}
@MmuxDefineConstant{IPPORT_NETSTAT}
@MmuxDefineConstant{IPPORT_RESERVED}
@MmuxDefineConstant{IPPORT_RJE}
@MmuxDefineConstant{IPPORT_ROUTESERVER}
@MmuxDefineConstant{IPPORT_SMTP}
@MmuxDefineConstant{IPPORT_SUPDUP}
@MmuxDefineConstant{IPPORT_SYSTAT}
@MmuxDefineConstant{IPPORT_TELNET}
@MmuxDefineConstant{IPPORT_TFTP}
@MmuxDefineConstant{IPPORT_TIMESERVER}
@MmuxDefineConstant{IPPORT_TTYLINK}
@MmuxDefineConstant{IPPORT_USERRESERVED}
@MmuxDefineConstant{IPPORT_WHOIS}
@MmuxDefineConstant{IPPORT_WHOSERVER}

@MmuxDefineConstant{SOCK_CLOEXEC}
@MmuxDefineConstant{SOCK_DCCP}
@MmuxDefineConstant{SOCK_DGRAM}
@MmuxDefineConstant{SOCK_NONBLOCK}
@MmuxDefineConstant{SOCK_PACKET}
@MmuxDefineConstant{SOCK_RAW}
@MmuxDefineConstant{SOCK_RDM}
@MmuxDefineConstant{SOCK_SEQPACKET}
@MmuxDefineConstant{SOCK_STREAM}

@MmuxDefineConstant{WAIT_ANY}
@MmuxDefineConstant{WAIT_MYPGRP}

@MmuxDefineConstant{WEXITED}
@MmuxDefineConstant{WNOHANG}
@MmuxDefineConstant{WNOWAIT}
@MmuxDefineConstant{WSTOPPED}
@MmuxDefineConstant{WCONTINUED}
@MmuxDefineConstant{WUNTRACED}

@MmuxDefineConstant{P_ALL}
@MmuxDefineConstant{P_PID}
@MmuxDefineConstant{P_PIDFD}
@MmuxDefineConstant{P_PGID}

@MmuxDefineConstant{EXIT_SUCCESS}
@MmuxDefineConstant{EXIT_FAILURE}

@defvr Constant MMUX_LIBC_MSG_ZERO
@defvrx {Preprocessor Symbol} MMUX_HAVE_LIBC_MSG_ZERO
The symbol @code{MMUX_LIBC_MSG_ZERO} evaluates to zero; it is meant to be used as @var{flags}
argument for @cfunc{mmux_libc_send}, and similar functions, when no other @code{MMUX_LIBC_MSG_*}
flag is needed; it gives the reader of the code a remainder of which flags are available for the
operation.

The symbol @code{MMUX_HAVE_LIBC_MSG_ZERO} is always defined and it evaluates to @samp{1}.
@end defvr

@MmuxDefineConstant{_SC_2_CHAR_TERM}
@MmuxDefineConstant{_SC_2_C_BIND}
@MmuxDefineConstant{_SC_2_C_DEV}
@MmuxDefineConstant{_SC_2_C_VERSION}
@MmuxDefineConstant{_SC_2_FORT_DEV}
@MmuxDefineConstant{_SC_2_FORT_RUN}
@MmuxDefineConstant{_SC_2_LOCALEDEF}
@MmuxDefineConstant{_SC_2_PBS}
@MmuxDefineConstant{_SC_2_PBS_ACCOUNTING}
@MmuxDefineConstant{_SC_2_PBS_CHECKPOINT}
@MmuxDefineConstant{_SC_2_PBS_LOCATE}
@MmuxDefineConstant{_SC_2_PBS_MESSAGE}
@MmuxDefineConstant{_SC_2_PBS_TRACK}
@MmuxDefineConstant{_SC_2_SW_DEV}
@MmuxDefineConstant{_SC_2_UPE}
@MmuxDefineConstant{_SC_2_VERSION}
@MmuxDefineConstant{_SC_ADVISORY_INFO}
@MmuxDefineConstant{_SC_AIO_LISTIO_MAX}
@MmuxDefineConstant{_SC_AIO_MAX}
@MmuxDefineConstant{_SC_AIO_PRIO_DELTA_MAX}
@MmuxDefineConstant{_SC_ARG_MAX}
@MmuxDefineConstant{_SC_ASYNCHRONOUS_IO}
@MmuxDefineConstant{_SC_ATEXIT_MAX}
@MmuxDefineConstant{_SC_AVPHYS_PAGES}
@MmuxDefineConstant{_SC_BARRIERS}
@MmuxDefineConstant{_SC_BASE}
@MmuxDefineConstant{_SC_BC_BASE_MAX}
@MmuxDefineConstant{_SC_BC_DIM_MAX}
@MmuxDefineConstant{_SC_BC_SCALE_MAX}
@MmuxDefineConstant{_SC_BC_STRING_MAX}
@MmuxDefineConstant{_SC_CHARCLASS_NAME_MAX}
@MmuxDefineConstant{_SC_CHAR_BIT}
@MmuxDefineConstant{_SC_CHAR_MAX}
@MmuxDefineConstant{_SC_CHAR_MIN}
@MmuxDefineConstant{_SC_CHILD_MAX}
@MmuxDefineConstant{_SC_CLK_TCK}
@MmuxDefineConstant{_SC_CLOCK_SELECTION}
@MmuxDefineConstant{_SC_COLL_WEIGHTS_MAX}
@MmuxDefineConstant{_SC_CPUTIME}
@MmuxDefineConstant{_SC_C_LANG_SUPPORT}
@MmuxDefineConstant{_SC_C_LANG_SUPPORT_R}
@MmuxDefineConstant{_SC_DELAYTIMER_MAX}
@MmuxDefineConstant{_SC_DEVICE_IO}
@MmuxDefineConstant{_SC_DEVICE_SPECIFIC}
@MmuxDefineConstant{_SC_DEVICE_SPECIFIC_R}
@MmuxDefineConstant{_SC_EQUIV_CLASS_MAX}
@MmuxDefineConstant{_SC_EXPR_NEST_MAX}
@MmuxDefineConstant{_SC_FD_MGMT}
@MmuxDefineConstant{_SC_FIFO}
@MmuxDefineConstant{_SC_FILE_ATTRIBUTES}
@MmuxDefineConstant{_SC_FILE_LOCKING}
@MmuxDefineConstant{_SC_FILE_SYSTEM}
@MmuxDefineConstant{_SC_FSYNC}
@MmuxDefineConstant{_SC_GETGR_R_SIZE_MAX}
@MmuxDefineConstant{_SC_GETPW_R_SIZE_MAX}
@MmuxDefineConstant{_SC_HOST_NAME_MAX}
@MmuxDefineConstant{_SC_INT_MAX}
@MmuxDefineConstant{_SC_INT_MIN}
@MmuxDefineConstant{_SC_IOV_MAX}
@MmuxDefineConstant{_SC_IPV6}
@MmuxDefineConstant{_SC_JOB_CONTROL}
@MmuxDefineConstant{_SC_LEVEL1_DCACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL1_DCACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL1_DCACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL1_ICACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL1_ICACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL1_ICACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL2_CACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL2_CACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL2_CACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL3_CACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL3_CACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL3_CACHE_SIZE}
@MmuxDefineConstant{_SC_LEVEL4_CACHE_ASSOC}
@MmuxDefineConstant{_SC_LEVEL4_CACHE_LINESIZE}
@MmuxDefineConstant{_SC_LEVEL4_CACHE_SIZE}
@MmuxDefineConstant{_SC_LINE_MAX}
@MmuxDefineConstant{_SC_LOGIN_NAME_MAX}
@MmuxDefineConstant{_SC_LONG_BIT}
@MmuxDefineConstant{_SC_MAPPED_FILES}
@MmuxDefineConstant{_SC_MB_LEN_MAX}
@MmuxDefineConstant{_SC_MEMLOCK}
@MmuxDefineConstant{_SC_MEMLOCK_RANGE}
@MmuxDefineConstant{_SC_MEMORY_PROTECTION}
@MmuxDefineConstant{_SC_MESSAGE_PASSING}
@MmuxDefineConstant{_SC_MONOTONIC_CLOCK}
@MmuxDefineConstant{_SC_MQ_OPEN_MAX}
@MmuxDefineConstant{_SC_MQ_PRIO_MAX}
@MmuxDefineConstant{_SC_MULTI_PROCESS}
@MmuxDefineConstant{_SC_NETWORKING}
@MmuxDefineConstant{_SC_NGROUPS_MAX}
@MmuxDefineConstant{_SC_NL_ARGMAX}
@MmuxDefineConstant{_SC_NL_LANGMAX}
@MmuxDefineConstant{_SC_NL_MSGMAX}
@MmuxDefineConstant{_SC_NL_NMAX}
@MmuxDefineConstant{_SC_NL_SETMAX}
@MmuxDefineConstant{_SC_NL_TEXTMAX}
@MmuxDefineConstant{_SC_NPROCESSORS_CONF}
@MmuxDefineConstant{_SC_NPROCESSORS_ONLN}
@MmuxDefineConstant{_SC_NZERO}
@MmuxDefineConstant{_SC_OPEN_MAX}
@MmuxDefineConstant{_SC_PAGESIZE}
@MmuxDefineConstant{_SC_PAGE_SIZE}
@MmuxDefineConstant{_SC_PASS_MAX}
@MmuxDefineConstant{_SC_PHYS_PAGES}
@MmuxDefineConstant{_SC_PII}
@MmuxDefineConstant{_SC_PII_INTERNET}
@MmuxDefineConstant{_SC_PII_INTERNET_DGRAM}
@MmuxDefineConstant{_SC_PII_INTERNET_STREAM}
@MmuxDefineConstant{_SC_PII_OSI}
@MmuxDefineConstant{_SC_PII_OSI_CLTS}
@MmuxDefineConstant{_SC_PII_OSI_COTS}
@MmuxDefineConstant{_SC_PII_OSI_M}
@MmuxDefineConstant{_SC_PII_SOCKET}
@MmuxDefineConstant{_SC_PII_XTI}
@MmuxDefineConstant{_SC_PIPE}
@MmuxDefineConstant{_SC_POLL}
@MmuxDefineConstant{_SC_PRIORITIZED_IO}
@MmuxDefineConstant{_SC_PRIORITY_SCHEDULING}
@MmuxDefineConstant{_SC_RAW_SOCKETS}
@MmuxDefineConstant{_SC_READER_WRITER_LOCKS}
@MmuxDefineConstant{_SC_REALTIME_SIGNALS}
@MmuxDefineConstant{_SC_REGEXP}
@MmuxDefineConstant{_SC_REGEX_VERSION}
@MmuxDefineConstant{_SC_RE_DUP_MAX}
@MmuxDefineConstant{_SC_RTSIG_MAX}
@MmuxDefineConstant{_SC_SAVED_IDS}
@MmuxDefineConstant{_SC_SCHAR_MAX}
@MmuxDefineConstant{_SC_SCHAR_MIN}
@MmuxDefineConstant{_SC_SELECT}
@MmuxDefineConstant{_SC_SEMAPHORES}
@MmuxDefineConstant{_SC_SEM_NSEMS_MAX}
@MmuxDefineConstant{_SC_SEM_VALUE_MAX}
@MmuxDefineConstant{_SC_SHARED_MEMORY_OBJECTS}
@MmuxDefineConstant{_SC_SHELL}
@MmuxDefineConstant{_SC_SHRT_MAX}
@MmuxDefineConstant{_SC_SHRT_MIN}
@MmuxDefineConstant{_SC_SIGNALS}
@MmuxDefineConstant{_SC_SIGQUEUE_MAX}
@MmuxDefineConstant{_SC_SINGLE_PROCESS}
@MmuxDefineConstant{_SC_SPAWN}
@MmuxDefineConstant{_SC_SPIN_LOCKS}
@MmuxDefineConstant{_SC_SPORADIC_SERVER}
@MmuxDefineConstant{_SC_SSIZE_MAX}
@MmuxDefineConstant{_SC_STREAMS}
@MmuxDefineConstant{_SC_STREAM_MAX}
@MmuxDefineConstant{_SC_SYMLOOP_MAX}
@MmuxDefineConstant{_SC_SYNCHRONIZED_IO}
@MmuxDefineConstant{_SC_SYSTEM_DATABASE}
@MmuxDefineConstant{_SC_SYSTEM_DATABASE_R}
@MmuxDefineConstant{_SC_THREADS}
@MmuxDefineConstant{_SC_THREAD_ATTR_STACKADDR}
@MmuxDefineConstant{_SC_THREAD_ATTR_STACKSIZE}
@MmuxDefineConstant{_SC_THREAD_CPUTIME}
@MmuxDefineConstant{_SC_THREAD_DESTRUCTOR_ITERATIONS}
@MmuxDefineConstant{_SC_THREAD_KEYS_MAX}
@MmuxDefineConstant{_SC_THREAD_PRIORITY_SCHEDULING}
@MmuxDefineConstant{_SC_THREAD_PRIO_INHERIT}
@MmuxDefineConstant{_SC_THREAD_PRIO_PROTECT}
@MmuxDefineConstant{_SC_THREAD_PROCESS_SHARED}
@MmuxDefineConstant{_SC_THREAD_SAFE_FUNCTIONS}
@MmuxDefineConstant{_SC_THREAD_SPORADIC_SERVER}
@MmuxDefineConstant{_SC_THREAD_STACK_MIN}
@MmuxDefineConstant{_SC_THREAD_THREADS_MAX}
@MmuxDefineConstant{_SC_TIMEOUTS}
@MmuxDefineConstant{_SC_TIMERS}
@MmuxDefineConstant{_SC_TIMER_MAX}
@MmuxDefineConstant{_SC_TRACE}
@MmuxDefineConstant{_SC_TRACE_EVENT_FILTER}
@MmuxDefineConstant{_SC_TRACE_INHERIT}
@MmuxDefineConstant{_SC_TRACE_LOG}
@MmuxDefineConstant{_SC_TTY_NAME_MAX}
@MmuxDefineConstant{_SC_TYPED_MEMORY_OBJECTS}
@MmuxDefineConstant{_SC_TZNAME_MAX}
@MmuxDefineConstant{_SC_T_IOV_MAX}
@MmuxDefineConstant{_SC_UCHAR_MAX}
@MmuxDefineConstant{_SC_UINT_MAX}
@MmuxDefineConstant{_SC_UIO_MAXIOV}
@MmuxDefineConstant{_SC_ULONG_MAX}
@MmuxDefineConstant{_SC_USER_GROUPS}
@MmuxDefineConstant{_SC_USER_GROUPS_R}
@MmuxDefineConstant{_SC_USHRT_MAX}
@MmuxDefineConstant{_SC_V6_ILP32_OFF32}
@MmuxDefineConstant{_SC_V6_ILP32_OFFBIG}
@MmuxDefineConstant{_SC_V6_LP64_OFF64}
@MmuxDefineConstant{_SC_V6_LPBIG_OFFBIG}
@MmuxDefineConstant{_SC_VERSION}
@MmuxDefineConstant{_SC_WORD_BIT}
@MmuxDefineConstant{_SC_XBS5_ILP32_OFF32}
@MmuxDefineConstant{_SC_XBS5_ILP32_OFFBIG}
@MmuxDefineConstant{_SC_XBS5_LP64_OFF64}
@MmuxDefineConstant{_SC_XBS5_LPBIG_OFFBIG}
@MmuxDefineConstant{_SC_XOPEN_CRYPT}
@MmuxDefineConstant{_SC_XOPEN_ENH_I18N}
@MmuxDefineConstant{_SC_XOPEN_LEGACY}
@MmuxDefineConstant{_SC_XOPEN_REALTIME}
@MmuxDefineConstant{_SC_XOPEN_REALTIME_THREADS}
@MmuxDefineConstant{_SC_XOPEN_SHM}
@MmuxDefineConstant{_SC_XOPEN_UNIX}
@MmuxDefineConstant{_SC_XOPEN_VERSION}
@MmuxDefineConstant{_SC_XOPEN_XCU_VERSION}
@MmuxDefineConstant{_SC_XOPEN_XPG2}
@MmuxDefineConstant{_SC_XOPEN_XPG3}
@MmuxDefineConstant{_SC_XOPEN_XPG4}

@MmuxDefineConstant{_CS_LFS64_CFLAGS}
@MmuxDefineConstant{_CS_LFS64_LDFLAGS}
@MmuxDefineConstant{_CS_LFS64_LIBS}
@MmuxDefineConstant{_CS_LFS64_LINTFLAGS}
@MmuxDefineConstant{_CS_LFS_CFLAGS}
@MmuxDefineConstant{_CS_LFS_LDFLAGS}
@MmuxDefineConstant{_CS_LFS_LIBS}
@MmuxDefineConstant{_CS_LFS_LINTFLAGS}
@MmuxDefineConstant{_CS_PATH}

@MmuxDefineConstant{_PC_ASYNC_IO}
@MmuxDefineConstant{_PC_CHOWN_RESTRICTED}
@MmuxDefineConstant{_PC_FILESIZEBITS}
@MmuxDefineConstant{_PC_LINK_MAX}
@MmuxDefineConstant{_PC_MAX_CANON}
@MmuxDefineConstant{_PC_MAX_INPUT}
@MmuxDefineConstant{_PC_NAME_MAX}
@MmuxDefineConstant{_PC_NO_TRUNC}
@MmuxDefineConstant{_PC_PATH_MAX}
@MmuxDefineConstant{_PC_PIPE_BUF}
@MmuxDefineConstant{_PC_PRIO_IO}
@MmuxDefineConstant{_PC_REC_INCR_XFER_SIZE}
@MmuxDefineConstant{_PC_REC_MAX_XFER_SIZE}
@MmuxDefineConstant{_PC_REC_MIN_XFER_SIZE}
@MmuxDefineConstant{_PC_REC_XFER_ALIGN}
@MmuxDefineConstant{_PC_SYNC_IO}
@MmuxDefineConstant{_PC_VDISABLE}

@MmuxDefineConstant{RLIMIT_AS}
@MmuxDefineConstant{RLIMIT_CORE}
@MmuxDefineConstant{RLIMIT_CPU}
@MmuxDefineConstant{RLIMIT_DATA}
@MmuxDefineConstant{RLIMIT_FSIZE}
@MmuxDefineConstant{RLIMIT_LOCKS}
@MmuxDefineConstant{RLIMIT_MEMLOCK}
@MmuxDefineConstant{RLIMIT_MSGQUEUE}
@MmuxDefineConstant{RLIMIT_NICE}
@MmuxDefineConstant{RLIMIT_NOFILE}
@MmuxDefineConstant{RLIMIT_NPROC}
@MmuxDefineConstant{RLIMIT_RSS}
@MmuxDefineConstant{RLIMIT_RTPRIO}
@MmuxDefineConstant{RLIMIT_RTTIME}
@MmuxDefineConstant{RLIMIT_SIGPENDING}
@MmuxDefineConstant{RLIMIT_STACK}
@MmuxDefineConstant{RLIM_INFINITY}

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {mmux_asciizcp_t} mmux_cc_libc_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_cc_libc_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_cc_libc_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_cc_libc_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node initialisation
@chapter Library initialisation


@deftypefun bool mmux_cc_libc_init (void)
Initialise library's internal state; we can safely call this function multimple times.  When
successful return @cfalse{}; otherwise return @ctrue{}.
@end deftypefun

@c page
@node errors
@chapter Errors management


@cindex @code{errno} variable
@cindex Variacle @code{errno}
@cindex Error handling
@cindex Handling errors


@deftypefun bool mmux_libc_errno_set (mmux_sint_t @var{errnum})
Setter for the standard @code{errno} variable.  The return value is always @cfalse{}.
@end deftypefun


@deftypefun bool mmux_libc_errno_ref (mmux_sint_t * @var{result_errnum_p})
Getter for the standard @code{errno} variable: always store the current value of @code{errno} in the
location referenced by @var{result_errnum_p}.  When @code{errno} is zero: the return value is
@ctrue{}, there is no reason to query @code{errno}; otherwise it is @cfalse{}.

@example
mmux_sint_t     errnum;

if (mmux_libc_errno_ref(&errnum)) @{
  ... /* there was no error: why are we querying "errno"? */
@} else @{
  mmux_asciizcp_t       errmsg;

  mmux_libc_strerror(&errmsg, errnum);
  ... /* handle the error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_errno_consume (mmux_sint_t * @var{result_errnum_p})
Getter--and--resetter for the standard @code{errno} variable: always store the current value of
@code{errno} in the location referenced by @var{result_errnum_p}, then reset @code{errno} to zero.
Upon calling this function, when @code{errno} is zero: the return value is @ctrue{}, there is no
reason to query @code{errno}; otherwise it is @cfalse{}.

@example
mmux_sint_t     errnum;

if (mmux_libc_errno_consume(&errnum)) @{
  ... /* there was no error: why are we querying "errno"? */
@} else @{
  mmux_asciizcp_t       errmsg;

  mmux_libc_strerror(&errmsg, errnum);
  ... /* handle the error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strerror (mmux_asciizcp_t * @var{result_error_message_p}, mmux_sint_t @var{errnum})
@MmuxCInterface{strerror}.  The return value is always @cfalse{}.
@end deftypefun

@c page
@node memory
@chapter Memory management


@menu
* memory allocation::           Memory allocation.
* memory operations::           Memory operations.
@end menu

@c page
@node memory allocation
@section Memory allocation


@deftypefn {Preprocessor Macro} bool mmux_libc_malloc (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{len})
@deftypefnx {Function} bool mmux_libc_malloc_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{len})
@MmuxCInterface{malloc}.  The macro just casts a pointer @var{P_p} of any type to @code{mmux_pointer_t
*}.  Upon successful return: the pointer variable referenced by @var{P_p} is set to the pointer
referencing the newly allocated memory block.

@example
mmux_libc_tm_t *  tm;

if (mmux_libc_malloc(&tm, sizeof(mmux_libc_tm_t))) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_calloc (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx Function bool mmux_libc_calloc_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@MmuxCInterface{calloc}.  The macro just casts a pointer @var{P_p} of any type to @code{mmux_pointer_t
*}.  Upon successful return: the pointer variable referenced by @var{P_p} is set to the pointer
referencing the newly allocated memory block.

@example
mmux_double_t *  P;

if (mmux_libc_calloc(&P, 123, sizeof(mmux_double_t))) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_realloc (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{newlen})
@deftypefnx Function bool mmux_libc_realloc_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{newlen})
@MmuxCInterface{realloc}.  The macro just casts a pointer @var{P_p} of any type to @code{mmux_pointer_t
*}.

@itemize
@item
Upon calling this function: @var{P_p} must reference a pointer variable holding the pointer to the
memory block to reallocate.

@item
Upon successfully returning from this function: the pointer variable referenced by @var{P_p} holds
the new pointer.
@end itemize

@example
mmux_libc_tm_t *  tm;

if (mmux_libc_malloc(&tm, 1024)) @{
  /* error */
@}
if (mmux_libc_realloc(&tm, 4096)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_reallocarray (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx Function bool mmux_libc_reallocarray_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@MmuxCInterface{reallocarray}.  The macro just casts a pointer @var{P_p} of any type to
@code{mmux_pointer_t *}.  Upon successful return: the pointer variable referenced by @var{P_p} is
set to the pointer referencing the newly allocated memory block.

@example
mmux_double_t *  P;

if (mmux_libc_calloc(&P, 123, sizeof(mmux_double_t))) @{
  /* error */
@}
if (mmux_libc_reallocarray(&P, 456, sizeof(mmux_double_t))) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_free (mmux_pointer_t @var{P})
@MmuxCInterface{free}.
@end deftypefun

@c page
@node memory operations
@section Memory operations


@deftypefun bool mmux_libc_memset (mmux_pointer_t @var{ptr}, mmux_uint8_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memset}.
@end deftypefun


@deftypefun bool mmux_libc_memzero (mmux_pointer_t @var{ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memzero}.
@end deftypefun


@deftypefun bool mmux_libc_memcpy (mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memcpy}.
@end deftypefun


@deftypefun bool mmux_libc_mempcpy (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{mempcpy}.
@end deftypefun


@deftypefun bool mmux_libc_memccpy (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_uint8_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memccpy}.
@end deftypefun


@deftypefun bool mmux_libc_memmove (mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memmove}.
@end deftypefun


@deftypefun bool mmux_libc_memcmp (mmux_sint_t * @var{result_p}, mmux_pointerc_t @vari{ptr}, mmux_pointerc_t @varii{ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memcmp}.
@end deftypefun


@deftypefun bool mmux_libc_memchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memchr}.
@end deftypefun


@deftypefun bool mmux_libc_rawmemchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet})
@MmuxCInterface{rawmemchr}.
@end deftypefun


@deftypefun bool mmux_libc_memrchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memrchr}.
@end deftypefun


@deftypefun bool mmux_libc_memmem (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{haystack_ptr}, mmux_usize_t @var{haystack_len}, mmux_pointer_t @var{needle_ptr}, mmux_usize_t @var{needle_len})
@MmuxCInterface{memmem}.
@end deftypefun

@c page
@node strings
@chapter String operations


@menu
* strings inspection::          Inspecting @asciiz{} strings.
* strings duplication::         Duplicating @asciiz{} strings.
* strings concatenation::       Concatenating @asciiz{} strings.
* strings comparison::          Comparing @asciiz{} strings.
* strings collation::           Collation builtins for @asciiz{} strings.
* strings searching::           Searching in @asciiz{} strings.
* strings tokens::              Finding tokens in @asciiz{} strings.
@end menu

@c page
@node strings inspection
@section Inspecting @asciiz{} strings


@deftypefun bool mmux_libc_strlen (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr})
@MmuxCInterface{strlen}.

@example
mmux_asciizcp_t         bufptr = "hello world";
mmux_usize_t            buflen;

if (mmux_libc_strlen(&buflen, bufptr)) @{
  /* error, it should never happen */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_strnlen (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{ptr}, mmux_usize_t @var{maxlen})
@MmuxCInterface{strnlen}.

@example
mmux_asciizcp_t         bufptr = "hello world";
mmux_usize_t            buflen;

if (mmux_libc_strnlen(&buflen, bufptr, 4096)) @{
  /* error, it should never happen */
@}
@end example
@end deftypefun

@c page
@node strings duplication
@section Duplicating @asciiz{} strings


@deftypefun bool mmux_libc_strcpy (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{strcpy}.
@end deftypefun


@deftypefun bool mmux_libc_strncpy (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncpy}.
@end deftypefun


@deftypefun bool mmux_libc_stpcpy(mmux_asciizp_t * @var{result_after_ptr_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{stpcpy}.
@end deftypefun


@deftypefun bool mmux_libc_stpncpy(mmux_asciizp_t * @var{result_after_ptr_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{stpncpy}.
@end deftypefun


@deftypefun bool mmux_libc_strdup (mmux_asciizcp_t * @var{result_oustr_p}, mmux_asciizcp_t @var{instr})
@MmuxCInterface{strdup}.
@end deftypefun


@deftypefun bool mmux_libc_strndup (mmux_asciizcp_t * @var{result_oustr_p}, mmux_asciizcp_t @var{instr}, mmux_usize_t @var{len})
@MmuxCInterface{strndup}.
@end deftypefun

@c page
@node strings concatenation
@section Concatenating @asciiz{} strings


@deftypefun bool mmux_libc_strcat (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr})
@MmuxCInterface{strcat}.
@end deftypefun


@deftypefun bool mmux_libc_strncat (mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncat}.
@end deftypefun

@c page
@node strings comparison
@section Comparing @asciiz{} strings


@deftypefun bool mmux_libc_strcmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr})
@MmuxCInterface{strcmp}.
@end deftypefun


@deftypefun bool mmux_libc_strncmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncmp}.
@end deftypefun


@deftypefun bool mmux_libc_strcasecmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr})
@MmuxCInterface{strcasecmp}.
@end deftypefun


@deftypefun bool mmux_libc_strncasecmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strncasecmp}.
@end deftypefun


@deftypefun bool mmux_libc_strverscmp (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @varii{ptr}, mmux_asciizcp_t @vari{ptr})
@MmuxCInterface{strverscmp}.
@end deftypefun

@c page
@node strings collation
@section Collation builtins for @asciiz{} strings


@deftypefun bool mmux_libc_strcoll (mmux_sint_t * @var{result_p}, mmux_asciizcp_t @vari{ptr}, mmux_asciizcp_t @varii{ptr})
@MmuxCInterface{strcoll}.
@end deftypefun


@deftypefun bool mmux_libc_strxfrm (mmux_usize_t * @var{result_size_p}, mmux_asciizp_t @var{dst_ptr}, mmux_asciizcp_t @var{src_ptr}, mmux_usize_t @var{len})
@MmuxCInterface{strxfrm}.
@end deftypefun

@c page
@node strings searching
@section Searching in @asciiz{} strings


@deftypefun bool mmux_libc_strchr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strchr}.
@end deftypefun


@deftypefun bool mmux_libc_strchrnul (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strchrnul}.
@end deftypefun


@deftypefun bool mmux_libc_strrchr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{ptr}, mmux_schar_t @var{schar})
@MmuxCInterface{strrchr}.
@end deftypefun


@deftypefun bool mmux_libc_strstr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{haystack}, mmux_asciizcp_t @var{needle})
@MmuxCInterface{strstr}.
@end deftypefun


@deftypefun bool mmux_libc_strcasestr (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{haystack}, mmux_asciizcp_t @var{needle})
@MmuxCInterface{strcasestr}.
@end deftypefun


@deftypefun bool mmux_libc_strspn (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{skipset})
@MmuxCInterface{strspn}.
@end deftypefun


@deftypefun bool mmux_libc_strcspn (mmux_usize_t * @var{result_len_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{stopset})
@MmuxCInterface{strcspn}.
@end deftypefun


@deftypefun bool mmux_libc_strpbrk (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{stopset})
@MmuxCInterface{strpbrk}.
@end deftypefun

@c page
@node strings tokens
@section Finding tokens in @asciiz{} strings


@deftypefun bool mmux_libc_strtok (mmux_asciizcp_t * @var{result_p}, mmux_asciizp_t @var{newstring}, mmux_asciizcp_t @var{delimiters})
@MmuxCInterface{strtok}.
@end deftypefun


@deftypefun bool mmux_libc_basename (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{pathname})
@MmuxCInterface{basename}.
@end deftypefun


@deftypefun bool mmux_libc_dirname (mmux_asciizcp_t * @var{result_p}, mmux_asciizcp_t @var{pathname})
@MmuxCInterface{dirname}.
@end deftypefun

@c page
@node characters
@chapter Character operations


@menu
* characters classes::          Character classes.
* characters capital::          Character capitalisation.
@end menu

@c page
@node characters classes
@section Character classes


@deftypefun bool mmux_libc_islower (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{islower}.
@end deftypefun


@deftypefun bool mmux_libc_isupper (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isupper}.
@end deftypefun


@deftypefun bool mmux_libc_isalpha (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isalpha}.
@end deftypefun


@deftypefun bool mmux_libc_isdigit (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isdigit}.
@end deftypefun


@deftypefun bool mmux_libc_isalnum (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isalnum}.
@end deftypefun


@deftypefun bool mmux_libc_isxdigit (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isxdigit}.
@end deftypefun


@deftypefun bool mmux_libc_ispunct (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{ispunct}.
@end deftypefun


@deftypefun bool mmux_libc_isspace (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isspace}.
@end deftypefun


@deftypefun bool mmux_libc_isblank (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isblank}.
@end deftypefun


@deftypefun bool mmux_libc_isgraph (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isgraph}.
@end deftypefun


@deftypefun bool mmux_libc_isprint (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isprint}.
@end deftypefun


@deftypefun bool mmux_libc_iscntrl (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{iscntrl}.
@end deftypefun


@deftypefun bool mmux_libc_isascii (bool * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{isascii}.
@end deftypefun

@c page
@node characters capital
@section Character capitalisation


@deftypefun bool mmux_libc_tolower (mmux_schar_t * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{tolower}.
@end deftypefun


@deftypefun bool mmux_libc_toupper (mmux_schar_t * @var{result_p}, mmux_schar_t @var{ch})
@MmuxCInterface{toupper}.
@end deftypefun

@c page
@node time
@chapter Times and dates


@menu
* time timeval::                The @objtype{mmux_libc_timeval_t} type.
* time timespec::               The @objtype{mmux_libc_timespec_t} type.
* time tm::                     The @objtype{mmux_libc_tm_t} type.
* time functions::              Handling time.
@end menu

@c page
@node time timeval
@section The @objtype{mmux_libc_timeval_t} type


@MmuxCStructOpaqueTypedef{timeval}
@MmuxSetterGetter{timeval, tv_sec,  mmux_time_t}
@MmuxSetterGetter{timeval, tv_usec, mmux_slong_t}
@MmuxStructDumper{timeval}


@deftypefun bool mmux_libc_timeval_set (mmux_libc_timeval_t * @var{timeval_p}, mmux_time_t @var{seconds}, mmux_slong_t @var{microseconds})
Initialise the fields of a @MmuxCStruct{timeval}.
@end deftypefun

@c page
@node time timespec
@section The @objtype{mmux_libc_timespec_t} type


To have more expressive names: in this @api{} we ``rename'' the fields @samp{tv_sec} and
@samp{tv_nsec} of @MmuxCStruct{timespec} to @samp{ts_sec} and @samp{ts_nsec}.


@MmuxCStructOpaqueTypedef{timespec}
@MmuxSetterGetter{timespec, ts_sec,  mmux_time_t}
@MmuxSetterGetter{timespec, ts_nsec, mmux_slong_t}
@MmuxStructDumper{timespec}


@deftypefun bool mmux_libc_timespec_set (mmux_libc_timeval_t * @var{timeval_p}, mmux_time_t @var{seconds}, mmux_slong_t @var{nanoseconds})
Initialise the fields of a @MmuxCStruct{timespec}.
@end deftypefun

@c page
@node time tm
@section The @objtype{mmux_libc_tm_t} type


@MmuxCStructOpaqueTypedef{tm}
@MmuxSetterGetter{tm, tm_sec,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_min,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_hour,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_mday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_mon,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_year,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_wday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_yday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_isdst,       mmux_sint_t}
@MmuxSetterGetter{tm, tm_gmtoff,      mmux_slong_t}
@MmuxSetterGetter{tm, tm_zone,        mmux_asciizcp_t}
@MmuxStructDumper{tm}


@deftypefun bool mmux_libc_tm_reset (mmux_libc_tm_t * @var{TM_P})
Reset the fields to:

@example
tm_sec    = 0
tm_min    = 0
tm_hour   = 0
tm_mday   = 1
tm_mon    = 0
tm_year   = 0
tm_wday   = 0
tm_yday   = 0
tm_isdst  = 0
tm_gmtoff = 0
tm_zone   = NULL
@end example
@end deftypefun

@c page
@node time functions
@section Handling time


@deftypefun bool mmux_libc_time (mmuc_time_t * @var{result_p})
@MmuxCInterface{time}.

@example
mmux_time_t       T;

mmux_libc_time(&T);
@end example
@end deftypefun


@deftypefun bool mmux_libc_localtime (mmux_libc_tm_t * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{localtime}.

@example
mmux_time_t       T;
mmux_libc_tm_t *  tm_p;

mmux_libc_time(&T);
mmux_libc_localtime(&tm_p, T);
@end example
@end deftypefun


@deftypefun bool mmux_libc_gmtime (mmux_libc_tm_t * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{gmtime}.

@example
mmux_time_t       T;
mmux_libc_tm_t *  tm_p;

mmux_libc_time(&T);
mmux_libc_gmtime(&tm_p, T);
@end example
@end deftypefun


@deftypefun bool mmux_libc_ctime (mmux_asciizcp_t * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{ctime}.

@example
mmux_time_t     T;
mmux_asciizcp_t    str;

mmux_libc_time(&T);
mmux_libc_ctime(&str, T);
mmux_libc_dprintfou("%s\n", str);
@end example
@end deftypefun


@deftypefun bool mmux_libc_mktime (mmux_time_t * @var{result_p}, mmux_libc_tm_t * @var{tm_p})
@MmuxCInterface{mktime}.

@example
mmux_time_t       T1, T2;
mmux_libc_tm_t *  tm_p;

mmux_libc_time(&T1);
mmux_libc_localtime(&tm_p, T1);
mmux_libc_mktime(&T2, tm_p);
@end example
@end deftypefun


@deftypefun bool mmux_libc_timegm (mmux_time_t * @var{result_p}, mmux_libc_tm_t * @var{tm_p})
@MmuxCInterface{timegm}.

@example
mmux_time_t       T1, T2;
mmux_libc_tm_t *  tm_p;

mmux_libc_time(&T1);
mmux_libc_localtime(&tm_p, T1);
mmux_libc_timegm(&T2, tm_p);
@end example
@end deftypefun


@deftypefun bool mmux_libc_asctime (mmux_asciizcp_t * @var{result_p}, mmux_libc_tm_t * @var{tm_p})
@MmuxCInterface{asctime}.

@example
mmux_time_t       T;
mmux_libc_tm_t *  tm_p;
mmux_asciizcp_t      str;

mmux_libc_time(&T);
mmux_libc_localtime(&tm_p, T);
mmux_libc_asctime(&str, tm_p);
mmux_libc_dprintfou("%s\n", str);
@end example
@end deftypefun


@deftypefun bool mmux_libc_strftime (char * @var{bufptr}, mmux_usize_t * @var{buflen_p}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{tm_p})
@MmuxCInterface{strftime}.  Format an output string representation of the timestamp referenced by
@var{TM_P} and store it in the buffer referenced by @var{bufptr}.

@itemize
@item
Upon calling this function: @var{buflen_p} must reference a location containing the number of bytes
in the buffer referenced by @var{bufptr}.

@item
Upon successfully returning from a function call: the location referenced by @var{buflen_p} is set
to the number of characters in the output string, including the terminating null byte.
@end itemize

@example
mmux_time_t       T;
mmux_libc_tm_t *  tm_p;

#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	4096
mmux_usize_t  buflen = IS_THIS_ENOUGH_QUESTION_MARK;
char          bufstr[buflen];

mmux_libc_time(&T);
mmux_libc_localtime(&tm_p, T);
if (mmux_libc_strftime(bufstr, &buflen, template, tm_p)) @{
  /* error */
@}
mmux_libc_dprintfou("%s\n", bufstr);
@end example
@end deftypefun


@deftypefun bool mmux_libc_strptime (char ** @var{first_unprocessed_after_timestamp_p}, mmux_asciizcp_t @var{input_string}, mmux_asciizcp_t @var{template}, mmux_libc_tm_t * @var{tm_p})
@MmuxCInterface{strptime}.

@example
mmux_asciizcp_t      template     = "%a, %d %b %Y %H:%M:%S %z";
mmux_asciizcp_t      input_string = "Fri, 15 Nov 2024 23:11:20 +0100";
mmux_libc_tm_t *  tm_p;
char *            first_unprocessed_after_timestamp;

if (mmux_libc_calloc(&tm_p, 1, sizeof(mmux_libc_tm_t)) @{
  /* error */
@}
if (mmux_libc_strptime(&first_unprocessed_after_timestamp, input_string, template, tm_p)) @{
  /* error */
@}
mmux_libc_tm_dump(MMUX_LIBC_STDOU, tm_p, NULL);
@end example
@end deftypefun


@deftypefun mmux_uint_t mmux_libc_sleep (mmux_uint_t * @var{leftover_result_p}, mmux_uint_t @var{seconds})
@MmuxCInterface{sleep}.
@end deftypefun


@deftypefun bool mmux_libc_nanosleep (mmux_libc_timespec_t * @var{requested_time}, mmux_libc_timespec_t * @var{remaining_time})
@MmuxCInterface{nanosleep}.

@example
mmux_libc_timespec_t    requested_time;
mmux_libc_timespec_t    remaining_time;

mmux_libc_timespec_set(&requested_time, 12, 34);
if (mmux_libc_nanosleep(&requested_time, &remaining_time)) @{
  /* error or interruption */
@}
@end example
@end deftypefun

@c page
@node system
@chapter System configuration


@menu
* system parameters::           Configuration parameters.
* system limits::               Configuration limits.
@end menu

@c page
@node system parameters
@section Configuration parameters


@cindex @samp{MMUX_LIBC_SC_} constants
@cindex @samp{MMUX_LIBC_CS_} constants
@cindex Constants @samp{MMUX_LIBC_SC_}
@cindex Constants @samp{MMUX_LIBC_CS_}


@deftypefun bool mmux_libc_sysconf (mmux_slong_t * @var{result_p}, mmux_sint_t @var{parameter})
@MmuxCInterface{sysconf}.  @var{parameter} must be one of the @samp{MMUX_LIBC__SC_*} constants.

@example
mmux_slong_t    result;

if (mmux_libc_sysconf(&result, MMUX_LIBC__SC_PAGESIZE)) @{
  /* error */
@}
/* the result is in "result" */
@end example
@end deftypefun


@deftypefun bool mmux_libc_confstr_size (mmux_usize_t * @var{result_required_nbytes_p}, mmux_sint_t @var{parameter})
@deftypefunx bool mmux_libc_confstr (mmux_sint_t @var{parameter}, char * @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{confstr}.  @var{parameter} must be one of the @samp{MMUX_LIBC__CS_*} constants.

@example
mmux_sint_t     parameter = MMUX_LIBC__CS_PATH;
mmux_usize_t    required_nbytes;

if (mmux_libc_confstr_size(&required_nbytes, parameter)) @{ /* error */ @}
@{
  char value[required_nbytes];

  if (mmux_libc_confstr(parameter, value, required_nbytes)) @{ /* error */ @}
  /* the result is in "value" */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pathconf (mmux_slong_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{parameter})
@MmuxCInterface{pathconf}.
@end deftypefun


@deftypefun bool mmux_libc_fpathconf (mmux_slong_t * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{parameter})
@MmuxCInterface{fpathconf}.
@end deftypefun

@c page
@node system limits
@section Configuration limits


@MmuxCStructOpaqueTypedef{rlimit}
@MmuxSetterGetter{rlimit, rlim_cur, mmux_rlim_t}
@MmuxSetterGetter{rlimit, rlim_max, mmux_rlim_t}
@MmuxStructDumper{rlimit}


@deftypefun bool mmux_libc_getrlimit (mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{rlimit_p})
@MmuxCInterface{getrlimit}.
@end deftypefun


@deftypefun bool mmux_libc_setrlimit (mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{rlimit_p})
@MmuxCInterface{setrlimit}.
@end deftypefun


@deftypefun bool mmux_libc_prlimit (mmux_libc_pid_t @var{pid}, mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{new_rlimit_p}, mmux_libc_rlimit_t * @var{old_rlimit_p})
@MmuxCInterface{prlimit}.
@end deftypefun

@c page
@node persona
@chapter Persona operations


@menu
* persona uids::                Representing UIDs.
* persona gids::                Representing GIDs.
* persona getting::             Getting users and groups.
* persona setting::             Setting users and groups.
* persona login::               Identifying who logged in.
* persona database user::       User database.
* persona database group::      Group database.
@end menu

@c page
@node persona uids
@section Representing UIDs


To obtain a UID value and convert it to string, we can do:

@example
mmux_libc_uid_t         the_uid;
mmux_usize_t            required_nchars;

mmux_libc_getuid(&the_uid);

if (mmux_libc_uid_sprint_size(&required_nchars, the_uid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_uid_sprint(str, required_nchars, the_uid) @{
    /* error */
  @}
@}
@end example


@deftp {Opaque Struct Alias} mmux_libc_uid_t
Type of data structure containing a value of type @objtype{mmux_uid_t}.
@end deftp


@deftypefun bool mmux_libc_make_uid (mmux_libc_uid_t * @var{result_p}, mmux_uid_t @var{uid_num})
Build a new value of type @objtype{mmux_libc_uid_t}.
@end deftypefun


@deftypefun bool mmux_libc_uid_parse (mmux_libc_uid_t * @var{uid_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_uid_t}
value; store the value in the location referenced by @var{uid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_uid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_uid_t @var{uid})
Determine the number of characters required to contain the string representation of @var{uid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_uid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_uid_t @var{uid})
Convert @var{uid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node persona gids
@section Representing GIDs


To obtain a GID value and convert it to string, we can do:

@example
mmux_libc_gid_t         the_gid;
mmux_usize_t            required_nchars;

mmux_libc_getgid(&the_gid);

if (mmux_libc_gid_sprint_size(&required_nchars, the_gid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_gid_sprint(str, required_nchars, the_gid) @{
    /* error */
  @}
@}
@end example


@deftp {Opaque Struct Alias} mmux_libc_gid_t
Type of data structure containing a value of type @objtype{mmux_gid_t}.
@end deftp


@deftypefun bool mmux_libc_make_gid (mmux_libc_gid_t * @var{result_p}, mmux_gid_t @var{gid_num})
Build a new value of type @objtype{mmux_libc_gid_t}.
@end deftypefun


@deftypefun bool mmux_libc_gid_parse (mmux_libc_gid_t * @var{gid_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_gid_t}
value; store the value in the location referenced by @var{gid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_gid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_gid_t @var{gid})
Determine the number of characters required to contain the string representation of @var{gid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_gid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_gid_t @var{gid})
Convert @var{gid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node persona getting
@section Getting users and groups


@deftypefun bool mmux_libc_getuid (mmux_libc_uid_t * @var{result_p})
@MmuxCInterface{getuid}.
@end deftypefun


@deftypefun bool mmux_libc_getgid (mmux_libc_gid_t * @var{result_p})
@MmuxCInterface{getgid}.
@end deftypefun


@deftypefun bool mmux_libc_geteuid (mmux_libc_uid_t * @var{result_p})
@MmuxCInterface{geteuid}.
@end deftypefun


@deftypefun bool mmux_libc_getegid (mmux_libc_gid_t * @var{result_p})
@MmuxCInterface{getegid}.
@end deftypefun


To retrieve the supplementary groups of the current process we do:

@example
mmux_usize_t    ngroups;

if (mmux_libc_getgroups_size(&ngroups)) @{
  /* error */
@} else @{
  mmux_libc_gid_t       gids[ngroups];

  if (mmux_libc_getgroups(&ngroups, gids)) @{
    /* error */
  @} else @{
    /* do something with gids */
  @}
@}
@end example


@deftypefun bool mmux_libc_getgroups_size (mmux_usize_t * @var{result_ngroups_p})
Determine the number of supplementary groups of the current process and store it in the location
referenced by @var{ngroups_p}.
@end deftypefun


@deftypefun bool mmux_libc_getgroups (mmux_usize_t * @var{ngroups_p}, mmux_libc_gid_t * @var{groups_p})
@MmuxCInterface{getgroups}.  Fill the array referenced by @var{groups_p} with values representing
the supplementary groups of the current process.

@itemize
@item
Upon entering the function call: the array must have a number of elements equal to the value
referenced by @var{ngroups_p}.

@item
Upon returning from the function call: the location referenced by @var{ngroups_p} is updated with
the actual number of values stored in the array.
@end itemize
@end deftypefun


To retrieve the groups a user belongs to we do:

@example
mmux_asciizcp_t    user_name = gimme_a_username();
mmux_libc_git_t user_gid  = gimme_its_gid(user_name);
mmux_usize_t    ngroups;

if (mmux_libc_getgrouplist_size(&ngroups, user_name, user_gid)) @{
  /* error */
@} else @{
  mmux_libc_gid_t       gids[ngroups];

  if (mmux_libc_getgrouplist(user_name, user_gid, &ngroups, gids)) @{
    /* error */
  @} else @{
    /* do something with gids */
  @}
@}
@end example


@deftypefun bool mmux_libc_getgrouplist_size (mmux_usize_t * @var{result_ngroups_p}, mmux_asciizcp_t @var{username}, mmux_libc_gid_t @var{gid})
Determine the number of groups a user belongs to and store it in the location referenced by
@var{ngroups_p}.
@end deftypefun


@deftypefun bool mmux_libc_getgrouplist (mmux_asciizcp_t @var{username}, mmux_libc_gid_t @var{gid}, mmux_usize_t * @var{ngroups_p}, mmux_libc_gid_t * @var{groups_p})
@MmuxCInterface{getgrouplist}.  Fill the array referenced by @var{groups_p} with values representing
the groups a user belongs to.

@itemize
@item
Upon entering the function call: the array must have a number of elements equal to the value
referenced by @var{ngroups_p}.

@item
Upon returning from the function call: the location referenced by @var{ngroups_p} is updated with
the actual number of values stored in the array.
@end itemize
@end deftypefun

@c page
@node persona setting
@section Setting users and groups


@deftypefun bool mmux_libc_setuid (mmux_libc_uid_t @var{uid})
@MmuxCInterface{setuid}.
@end deftypefun


@deftypefun bool mmux_libc_seteuid (mmux_libc_uid_t @var{uid})
@MmuxCInterface{seteuid}.
@end deftypefun


@deftypefun bool mmux_libc_setreuid (mmux_libc_uid_t @var{uid}, mmux_libc_uid_t @var{euid})
@MmuxCInterface{setreuid}.
@end deftypefun


@deftypefun bool mmux_libc_setgid (mmux_libc_gid_t @var{gid})
@MmuxCInterface{setgid}.
@end deftypefun


@deftypefun bool mmux_libc_setegid (mmux_libc_gid_t @var{gid})
@MmuxCInterface{setegid}.
@end deftypefun


@deftypefun bool mmux_libc_setregid (mmux_libc_gid_t @var{gid}, mmux_libc_gid_t @var{egid})
@MmuxCInterface{setregid}.
@end deftypefun

@c page
@node persona login
@section Identifying who logged in


@deftypefun bool mmux_libc_getlogin (mmux_asciizcp_t * @var{result_username_p})
@MmuxCInterface{getlogin}.
@end deftypefun

@c page
@node persona database user
@section User database


@MmuxCStructOpaqueTypedef{passwd}
@MmuxSetterGetter{passwd,	pw_name,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_passwd,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_uid,		mmux_libc_uid_t}
@MmuxSetterGetter{passwd,	pw_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{passwd,	pw_gecos,	mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_dir,		mmux_asciizcp_t}
@MmuxSetterGetter{passwd,	pw_shell,	mmux_asciizcp_t}
@MmuxStructDumper{passwd}


@deftypefun bool mmux_libc_getpwuid (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_libc_uid_t @var{uid})
@MmuxCInterface{getpwuid}.
@end deftypefun


@deftypefun bool mmux_libc_getpwnam (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_asciizcp_t @var{username})
@MmuxCInterface{getpwnam}.
@end deftypefun


@deftypefun bool mmux_libc_setpwent (void)
@MmuxCInterface{setpwent}.
@end deftypefun


@deftypefun bool mmux_libc_endpwent (void)
@MmuxCInterface{endpwent}.
@end deftypefun


@deftypefun bool mmux_libc_getpwent (mmux_libc_passwd_t * * @var{result_passwd_pp})
@MmuxCInterface{getpwent}.
@end deftypefun

@c page
@node persona database group
@section Group database


@MmuxCStructOpaqueTypedef{group}
@MmuxSetterGetter{group,	gr_name,	mmux_asciizcp_t}
@MmuxSetterGetter{group,	gr_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{group,	gr_mem,		mmux_asciizcp_t*}
@MmuxStructDumper{group}


@deftypefun bool mmux_libc_getgrgid (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{getgrgid}.
@end deftypefun


@deftypefun bool mmux_libc_getgrnam (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_asciizcp_t @var{groupname})
@MmuxCInterface{getgrnam}.
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_group_member (bool * @var{result_is_member_p}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{group_member}.
@end deftypefn


@deftypefun bool mmux_libc_setgrent (void)
@MmuxCInterface{setgrent}.
@end deftypefun


@deftypefun bool mmux_libc_endgrent (void)
@MmuxCInterface{endgrent}.
@end deftypefun


@deftypefun bool mmux_libc_getgrent (mmux_libc_group_t * * @var{result_group_pp})
@MmuxCInterface{getgrent}.
@end deftypefun

@c page
@node processes
@chapter Processes


@menu
* processes pids::              Representing PIDs.
* processes statuses::          Representing process completion--statuses.
* processes getting::           Getting PIDs.
* processes forking::           Forking processes.
* processes waiting::           Waiting for process completion.
* processes exiting::           Exiting processes.
@end menu

@c page
@node processes pids
@section Representing PIDs


@deftp {Opaque Struct Typedef} mmux_libc_pid_t
Opaque data structure type representing a @objtype{mmux_pid_t}.
@end deftp


@deftypefun bool mmux_libc_make_pid (mmux_libc_pid_t * @var{result_p}, mmux_pid_t @var{pid_num})
Build a new value of type @objtype{mmux_libc_pid_t}.
@end deftypefun


@deftypefun bool mmux_libc_pid_equal (mmux_libc_pid_t @vari{pid}, mmux_libc_pid_t @varii{pid})
Return true if @vari{pid} and  @varii{pid} are equal.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_pid_t the_pid;
mmux_usize_t    required_nchars;

mmux_libc_getpid (&the_pid);

if (mmux_libc_pid_sprint_size(&required_nchars, the_pid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_pid_sprint(str, required_nchars, the_pid) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_pid_parse (mmux_libc_pid_t * @var{pid_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_pid_t}
value; store the value in the location referenced by @var{pid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_pid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_pid_t @var{pid})
Determine the number of characters required to contain the string representation of @var{pid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_pid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_pid_t @var{pid})
Convert @var{pid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node processes statuses
@section Representing process completion--statuses


@deftp {Opaque Struct Typedef} mmux_libc_completed_process_status_t
Opaque data structure type representing a process completion--status, which is a
@objtype{mmux_sint_t} value.
@end deftp


@deftypefun bool mmux_libc_make_process_completion_status (mmux_libc_completed_process_status_t * @var{result_p}, mmux_sint_t @var{status_num})
Build a new value of type @objtype{mmux_libc_completed_process_status_t}.
@end deftypefun


@deftypefun bool mmux_libc_completed_process_status_equal (mmux_libc_completed_process_status_t @vari{status}, mmux_libc_completed_process_status_t @varii{status})
Return true if @vari{status} and @varii{status} are equal.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_completed_process_status_t    the_status = ...;
mmux_usize_t                            required_nchars;

if (mmux_libc_completed_process_status_sprint_size(&required_nchars, the_status) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_completed_process_status_sprint(str, required_nchars, the_status) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_completed_process_status_parse (mmux_libc_completed_process_status_t * @var{status_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a
@objtype{mmux_libc_completed_process_status_t} value; store the value in the location referenced by
@var{status_p}.  If an error occurs and @var{who} is not @cnull{}: print an error message to
@stderr{} using @var{who} as name of the entity that performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_completed_process_status_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_completed_process_status_t @var{status})
Determine the number of characters required to contain the string representation of @var{status} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_completed_process_status_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_completed_process_status_t @var{status})
Convert @var{status} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_WIFEXITED (mmux_libc_completed_process_status_t completed_process_status)
@MmuxCMacroInterfaceTwo{WIFEXITED,waitpid}.
@end deftypefun


@deftypefun mmux_sint_t mmux_libc_WEXITSTATUS (mmux_libc_completed_process_status_t completed_process_status)
@MmuxCMacroInterfaceTwo{WEXITSTATUS,waitpid}.
@end deftypefun


@deftypefun bool mmux_libc_WIFSIGNALED (mmux_libc_completed_process_status_t completed_process_status)
@MmuxCMacroInterfaceTwo{WIFSIGNALED,waitpid}.
@end deftypefun


@deftypefun mmux_libc_interprocess_signal_t mmux_libc_WTERMSIG (mmux_libc_completed_process_status_t completed_process_status)
@MmuxCMacroInterfaceTwo{WTERMSIG,waitpid}.
@end deftypefun


@deftypefun bool mmux_libc_WCOREDUMP (mmux_libc_completed_process_status_t completed_process_status)
@MmuxCMacroInterfaceTwo{WCOREDUMP,waitpid}.
@end deftypefun


@deftypefun bool mmux_libc_WIFSTOPPED (mmux_libc_completed_process_status_t completed_process_status)
@MmuxCMacroInterfaceTwo{WIFSTOPPED,waitpid}.
@end deftypefun


@deftypefun mmux_libc_interprocess_signal_t mmux_libc_WSTOPSIG (mmux_libc_completed_process_status_t completed_process_status)
@MmuxCMacroInterfaceTwo{WSTOPSIG,waitpid}.
@end deftypefun


@deftypefun bool mmux_libc_WIFCONTINUED (mmux_libc_completed_process_status_t completed_process_status)
@MmuxCMacroInterfaceTwo{WIFCONTINUED,waitpid}.
@end deftypefun

@c page
@node processes getting
@section Getting PIDs


@deftypefun bool mmux_libc_getpid  (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gitpid}.
@end deftypefun


@deftypefun  bool mmux_libc_getppid (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gitppid}.
@end deftypefun


@deftypefun bool mmux_libc_gettid (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gittid}.
@end deftypefun

@c page
@node processes forking
@section Forking processes


@deftypefun bool mmux_libc_fork (bool * @var{this_is_the_parent_process_p}, mmux_libc_pid_t * @var{child_process_pid_p})
@MmuxCInterface{fork}.  When a call is successful:

Regarding the argument @var{this_is_the_parent_process_p}: the referenced variable is mutated only
when a call is successful, otherwise it is left untouched.

@itemize
@item
In the parent process: the referenced variable is set to @ctrue{}.

@item
In the child process: the referenced variable is set to @cfalse{}.
@end itemize

Regarding the argument @var{child_process_pid_p}: the referenced variable is mutated only in the
parent process and when a call is successful, otherwise it is left untouched.

@itemize
@item
In the parent process: the referenced variable is set to the child process identifier.

@item
In the child process: the referenced variable is left untouched.
@end itemize

@example
bool                    this_is_the_parent_process;
mmux_libc_pid_t         child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  mmux_sint_t         errnum;

  mmux_libc_errno_consume(&errnum);
  ... /* handle the error */
@} else if (this_is_the_parent_process) @{
  ... /* do something in the parent process, maybe using "child_pid" */
@} else @{
  ... /* do something in the child process */
@}
@end example
@end deftypefun

@c page
@node processes waiting
@section Waiting for process completion


@menu
* processes waiting args::      Convention for common arguments.
* processes waiting waitpid::   Waiting with @cfunc{waitpid}.
* processes waiting other::     Waiting with other functions.
@end menu

@c page
@node processes waiting args
@subsection Convention for common arguments


This section documents the common arguments in calls to process--completion waiting--functions.  For
all the documented functions:

@table @code
@item bool * @var{completed_process_status_available_p}
pointer argument which cannot be @cnull{}; when the function call is successful:

@itemize
@item
if we have collected the completion status of a process: the referenced variable is set to @ctrue{};

@item
if no completion status was collected: the referenced variable is set to @cfalse{};
@end itemize

@noindent
when the function call is a failure: the referenced variable is left untouched;

@item mmux_libc_pid_t * @var{completed_process_pid_p}
pointer argument which cannot be @cnull{}; when the function call is successful and we have
collected the completion status of a process: the PID of the completed process is stored in the
referenced variable, otherwise the variable is left untouched;

@item mmux_libc_completed_process_status_t * @var{completed_process_status_p}
pointer argument which cannot be @cnull{}; when the function call is successful and we have
collected the completion status of a process: such status is stored in the referenced variable,
otherwise the variable is left untouched.
@end table

@c page
@node processes waiting waitpid
@subsection Waiting with @cfunc{waitpid}


For the documentation of the common arguments see @ref{processes waiting args, Convention for common
arguments}.


@deftypefun bool mmux_libc_wait_any_process (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of any child process.

@example
bool                                    completed_process_status_available;
mmux_libc_pid_t                         completed_process_pid;
mmux_libc_completed_process_status_t    completed_process_status;

if (mmux_libc_wait_any_process(&completed_process_status_available, &completed_process_pid,
                               &completed_process_status, MMUX_LIBC_WNOHANG)) @{
  ... /* handle the error */
@} else @{
  if (completed_process_status_available) @{
    ... /* do something with "completed_process_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_my_process_group (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of any child process in the same process group
of the calling process.

@example
bool                                    completed_process_status_available;
mmux_libc_pid_t                         completed_process_pid;
mmux_libc_completed_process_status_t    completed_process_status;

if (mmux_libc_wait_my_process_group(&completed_process_status_available, &completed_process_pid,
                                    &completed_process_status, MMUX_LIBC_WNOHANG)) @{
  ... /* handle the error */
@} else @{
  if (completed_process_status_available) @{
    ... /* do something with "completed_process_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_process_id (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p}, mmux_libc_pid_t @var{pid}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of a specific process whose process identifier
is @var{pid}.

@example
bool                    this_is_the_parent_process;
mmux_libc_pid_t         child_pid;

if (mmux_libc_fork(&this_is_the_parent_process, &child_pid)) @{
  ... /* handle the error */
@} else if (this_is_the_parent_process) @{
  bool                                  completed_process_status_available;
  mmux_libc_pid_t                       completed_process_pid;
  mmux_libc_completed_process_status_t  completed_process_status;

  if (mmux_libc_wait_process_id(&completed_process_status_available, &completed_process_pid,
                                &completed_process_status, child_pid, MMUX_LIBC_WNOHANG)) @{
    ... /* handle the error */
  @} else @{
    if (completed_process_status_available) @{
      ... /* do something with "completed_process_status" */
    @} else @{
      ... /* no completed process status was collected */
    @}
  @}
@} else @{
  ... /* do something in the child process */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_wait_group_id (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_sint_t * @var{completed_process_status_p}, mmux_libc_gid_t @var{gid}, mmux_sint_t @var{options})
@MmuxCInterface{waitpid}.  Wait for the termination of any process belonging to the process group
@var{gid}.

@example
mmux_libc_gid_t       the_gid;

if (mmux_libc_getgid(&the_gid)) @{
  ... /* handle the error */
@} else @{
  bool                                  completed_process_status_available;
  mmux_libc_pid_t                       completed_process_pid;
  mmux_libc_completed_process_status_t  completed_process_status;

  if (mmux_libc_wait_group_id(&completed_process_status_available, &completed_process_pid,
                              &completed_process_status, the_gid, MMUX_LIBC_WNOHANG)) @{
    ... /* handle the error */
  @} else @{
    if (completed_process_status_available) @{
      ... /* do something with "completed_process_status" */
    @} else @{
      ... /* no completed process status was collected */
    @}
  @}
@}
@end example
@end deftypefun

@c page
@node processes waiting other
@subsection Waiting with other functions


For the documentation of the common arguments see @ref{processes waiting args, Convention for common
arguments}.


@deftypefun bool mmux_libc_wait (bool * @var{completed_process_status_available_p}, mmux_libc_pid_t * @var{completed_process_pid_p}, mmux_libc_completed_process_status_t * @var{completed_process_status_p})
@MmuxCInterface{wait}.  Wait for the termination of any child process.

@example
bool                                    completed_process_status_available;
mmux_libc_pid_t                         completed_process_pid;
mmux_libc_completed_process_status_t    completed_process_status;

if (mmux_libc_wait(&completed_process_status_available, &completed_process_pid, &completed_process_status)) @{
  ... /* handle the error */
@} else @{
  if (completed_process_status_available) @{
    ... /* do something with "completed_process_status" */
  @} else @{
    ... /* no completed process status was collected */
  @}
@}
@end example
@end deftypefun

@c page
@node processes exiting
@section Exiting processes


@deftypefun bool mmux_libc_exit (mmux_sint_t @var{status})
@MmuxCInterface{exit}.
@end deftypefun


@deftypefun bool mmux_libc_exit_success (void)
@deftypefunx bool mmux_libc_exit_failure (void)
Wrappers for @cfunc{mmux_libc_exit} that terminate the current process with, respectively, the
status @code{MMUX_LIBC_EXIT_SUCCESS} or @code{MMUX_LIBC_EXIT_FAILURE}.
@end deftypefun


@deftypefun bool mmux_libc__exit (mmux_sint_t @var{status})
@MmuxCInterface{_exit}.
@end deftypefun


@deftypefun bool mmux_libc_atexit (void (* @var{function_pointer}) (void))
@MmuxCInterface{atexit}.
@end deftypefun

@c page
@node signals
@chapter Interprocess signals handling


@menu
* signals signals::             Representing interprocess signals.
@end menu

@c page
@node signals signals
@section Representing interprocess signals


@deftp {Opaque Struct Typedef} mmux_libc_interprocess_signal_t
Opaque data structure type representing an interprocess signal number.
@end deftp


@deftypefun bool mmux_libc_make_interprocess_signal (mmux_libc_interprocess_signal_t * @var{result_p}, mmux_sint_t @var{signal_number})
Build a new value of type @objtype{mmux_libc_interprocess_signal_t}.

@example
mmux_libc_interprocess_signal_t ipxsig;

if (mmux_libc_make_interprocess_signal(&ipxsig, MMUX_LIBC_SIGUSR1) @{
  ... /* this error happens only if @var{signal_NUMBER} is negative */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signal_equal (mmux_libc_interprocess_signal_t @vari{ipxsig}, mmux_libc_interprocess_signal_t @varii{ipxsig})
Return true if @vari{ipxsig} and  @varii{ipxsig} are equal.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_interprocess_signal_t         ipxsig;
mmux_usize_t                            required_nchars;

mmux_libc_make_signal_number(&the_signal_number, MMUX_LIBC_SIGUSR1);

if (mmux_libc_interprocess_signal_sprint_size(&required_nchars, ipxsig) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_interprocess_signal_sprint(str, required_nchars, ipxsig) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_interprocess_signal_parse (mmux_libc_interprocess_signal_t * @var{ipxsig_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a
@objtype{mmux_libc_interprocess_signal_t} value; store the value in the location referenced by
@var{ipxsig_p}.  If an error occurs and @var{who} is not @cnull{}: print an error message to
@stderr{} using @var{who} as name of the entity that performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signal_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_interprocess_signal_t @var{ipxsig})
Determine the number of characters required to contain the string representation of @var{ipxsig} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_interprocess_signal_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_interprocess_signal_t @var{ipxsig})
Convert @var{ipxsig} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node fds
@chapter File descriptors


@menu
* fds fds::                     File descriptors type.
* fds printing::                Printing formatted output.
* fds opening::                 Opening file descriptors.
* fds closing::                 Closing file descriptors.
* fds reading::                 Reading from file descriptors.
* fds writing::                 Writing to file descriptors.
* fds seeking::                 Seeking position in file descriptors.
* fds duplicating::             Duplicating file descriptors.
* fds piping::                  Opening file descriptor pipes.
* fds selecting::               Selecting file descriptors.
* fds scatter-gather::          Scatter--gather input and output.
* fds copying::                 Copying ranges from file to file.
* fds flock::                   File locks.
* fds fun control::             File descriptors functionality ontrol.
* fds io control::              File descriptors input/output control.
* fds memfd::                   Memory-mapped file descriptors.
@end menu

@c page
@node fds fds
@section File descriptors type


@deftp {Opaque Type} mmux_libc_file_descriptor_t
@deftpx {Opaque Type} mmux_libc_fd_t
Opaque type representing file descriptors.  It must be passed by value.
@end deftp


@deftypefun bool mmux_libc_stdin (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard input.
@end deftypefun


@deftypefun bool mmux_libc_stdou (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard output.
@end deftypefun


@deftypefun bool mmux_libc_stder (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard error.
@end deftypefun


@deftypefun bool mmux_libc_at_fdcwd (mmux_libc_file_descriptor_t * @var{result_p})
Return the file descriptor associated to the constant @code{AT_FDCWD}.  We can use it with
@cfunc{mmux_libc_openat} and similar functions.
@end deftypefun


@deftypefun bool mmux_libc_make_fd (mmux_libc_file_descriptor_t * @var{result_p}, mmux_sint_t @var{fd_num})
Make a new file descriptor value.
@end deftypefun


@deftypefun bool mmux_libc_fd_equal (mmux_libc_fd_t @vari{fd}, mmux_libc_fd_t @varii{fd})
Return @ctrue{} if @vari{fd} is equal to @varii{fd}; otherwise return @cfalse{}.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_fd_t  the_fd = gimme_an_fd();
mmux_usize_t    required_nchars;

if (mmux_libc_fd_sprint_size(&required_nchars, the_fd) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_fd_sprint(str, required_nchars, the_fd) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_fd_parse (mmux_libc_fd_t * @var{fd_p}, mmux_asciizcp_t @var{str}, mmux_asciizcp_t @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_fd_t}
value; store the value in the location referenced by @var{fd_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_fd_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_fd_t @var{fd})
Determine the number of characters required to contain the string representation of @var{fd} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_fd_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_fd_t @var{fd})
Convert @var{fd} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node fds printing
@section Printing formatted output


@deftypefun bool mmux_libc_dprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_asciizcp_t @var{template}, ...)
@deftypefunx bool mmux_libc_dprintfou (mmux_asciizcp_t template, ...)
@deftypefunx bool mmux_libc_dprintfer (mmux_asciizcp_t template, ...)
@MmuxCInterface{dprintf}.  Print the message to, respectively: @var{fd}, @stdout{}, @stderr{}.

To print to a file descriptor:

@example
mmux_libc_ptn_t         ptn;
mmux_libc_fd_t          fd;
mmux_sint_t             flags = MMUX_LIBC_O_RDONLY;
mmux_mode_t             mode  = 0;

if (mmux_libc_make_file_system_pathname(&ptn, "./file.ext")) @{
  /* error */
@};

if (mmux_libc_open(&fd, ptn, flags, mode)) @{
  /* error */
@}

if (mmux_libc_dprintf(fd, "the number is %d\n", 123)) @{
  /* error */
@}
@end example

To print to @stdout{} and @stderr{}:

@example
if (mmux_libc_dprintfou("the number is %d\n", 123)) @{
  /* error */
@}
if (mmux_libc_dprintfer("the number is %d\n", 456)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_vdprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_asciizcp_t @var{template}, va_list @var{ap})
@deftypefunx bool mmux_libc_vdprintfou (mmux_asciizcp_t @var{template}, va_list @var{ap})
@deftypefunx bool mmux_libc_vdprintfer (mmux_asciizcp_t @var{template}, va_list @var{ap})
@MmuxCInterface{vdprintf}.  Print the message to, respectively: @var{fd}, @stdout{}, @stderr{}.
Notice that @file{stdarg.h} is already included by @value{PackageHeaderFile}.

@example
bool
my_print_error (mmux_asciizcp_t template, ...)
@{
  bool          rv;
  va_list       ap;

  va_start(ap, template);
  @{
    rv = mmux_libc_vdprintfer(template, ap);
  @}
  va_end(ap);
  return rv;
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_dprintf_newline (mmux_libc_file_descriptor_t @var{fd})
@deftypefunx bool mmux_libc_dprintfou_newline (void)
@deftypefunx bool mmux_libc_dprintfer_newline (void)
Print a single newline character to, respectively: @var{fd}, @stdout{}, @stderr{}.
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineTypePrinterFunc{STEM}
@deftypefun bool mmux_\STEM\_dprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_\STEM\_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun

@end macro

@MmuxDefineTypePrinterFunc{pointer}

@MmuxDefineTypePrinterFunc{schar}
@MmuxDefineTypePrinterFunc{uchar}
@MmuxDefineTypePrinterFunc{sshort}
@MmuxDefineTypePrinterFunc{ushort}
@MmuxDefineTypePrinterFunc{sint}
@MmuxDefineTypePrinterFunc{uint}
@MmuxDefineTypePrinterFunc{slong}
@MmuxDefineTypePrinterFunc{ulong}
@MmuxDefineTypePrinterFunc{sllong}
@MmuxDefineTypePrinterFunc{ullong}

@MmuxDefineTypePrinterFunc{sint8}
@MmuxDefineTypePrinterFunc{uint8}
@MmuxDefineTypePrinterFunc{sint16}
@MmuxDefineTypePrinterFunc{uint16}
@MmuxDefineTypePrinterFunc{sint32}
@MmuxDefineTypePrinterFunc{uint32}
@MmuxDefineTypePrinterFunc{sint64}
@MmuxDefineTypePrinterFunc{uint64}

@MmuxDefineTypePrinterFunc{float}
@MmuxDefineTypePrinterFunc{double}
@MmuxDefineTypePrinterFunc{ldouble}

@MmuxDefineTypePrinterFunc{float32}
@MmuxDefineTypePrinterFunc{float64}
@MmuxDefineTypePrinterFunc{float128}

@MmuxDefineTypePrinterFunc{float32x}
@MmuxDefineTypePrinterFunc{float64x}
@MmuxDefineTypePrinterFunc{float128x}

@MmuxDefineTypePrinterFunc{decimal32}
@MmuxDefineTypePrinterFunc{decimal64}
@MmuxDefineTypePrinterFunc{decimal128}

@MmuxDefineTypePrinterFunc{complexf}
@MmuxDefineTypePrinterFunc{complexd}
@MmuxDefineTypePrinterFunc{complexld}

@MmuxDefineTypePrinterFunc{complexf32}
@MmuxDefineTypePrinterFunc{complexf64}
@MmuxDefineTypePrinterFunc{complexf128}

@MmuxDefineTypePrinterFunc{complexf32x}
@MmuxDefineTypePrinterFunc{complexf64x}
@MmuxDefineTypePrinterFunc{complexf128x}

@MmuxDefineTypePrinterFunc{complexd32}
@MmuxDefineTypePrinterFunc{complexd64}
@MmuxDefineTypePrinterFunc{complexd128}

@MmuxDefineTypePrinterFunc{usize}
@MmuxDefineTypePrinterFunc{ssize}

@MmuxDefineTypePrinterFunc{sintmax}
@MmuxDefineTypePrinterFunc{uintmax}
@MmuxDefineTypePrinterFunc{sintptr}
@MmuxDefineTypePrinterFunc{uintptr}
@MmuxDefineTypePrinterFunc{ptrdiff}
@MmuxDefineTypePrinterFunc{mode}
@MmuxDefineTypePrinterFunc{off}
@MmuxDefineTypePrinterFunc{pid}
@MmuxDefineTypePrinterFunc{uid}
@MmuxDefineTypePrinterFunc{gid}
@MmuxDefineTypePrinterFunc{wchar}
@MmuxDefineTypePrinterFunc{wint}
@MmuxDefineTypePrinterFunc{time}
@MmuxDefineTypePrinterFunc{socklen}
@MmuxDefineTypePrinterFunc{rlim}

@deftypefun bool mmux_libc_fd_dprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_file_descriptor_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_pid_dprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_pid_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_uid_dprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_uid_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_gid_dprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_gid_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_ptn_dprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_file_system_pathname_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun


@deftypefun bool mmux_libc_completed_process_status_dprintf (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_completed_process_status_t @var{value})
Print to @var{fd} the string representation of @var{value}.
@end deftypefun

@c page
@node fds opening
@section Opening file descriptors


@menu
* fds opening standard::        Standard file descriptor opening.
* fds opening extended::        Extended file descriptor opening.
@end menu

@c page
@node fds opening standard
@subsection Standard file descriptor opening


@deftypefun bool mmux_libc_open (mmux_libc_file_descriptor_t * @var{result_p}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{flags}, mmux_mode_t @var{mode})
@MmuxCInterface{open}.

@example
mmux_libc_file_system_pathname_t pathname;
mmux_libc_file_descriptor_t      fd;

mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

if (mmux_libc_make_file_system_pathname(&pathname, "/path/to/file.ext")) @{
  /* error */
@};

if (mmux_libc_open(&fd, pathname, flags, mode)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_openat (mmux_libc_file_descriptor_t * @var{result_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{flags}, mmux_mode_t @var{mode})
@MmuxCInterface{openat}.

@example
mmux_libc_file_system_pathname_t pathname;
mmux_libc_file_descriptor_t      dirfd;
mmux_libc_file_descriptor_t      fd;

mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

if (mmux_libc_make_file_system_pathname(&pathname, "/path/to/file.ext")) @{
  /* error */
@};

mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_openat(&fd, dirfd, pathname, flags, mode)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds opening extended
@subsection Extended file descriptor opening


The function @cfunc{openat2} and the data structure @code{struct open_how} are system extensions
implemented by the Linux kernel.


@MmuxCStructOpaqueTypedef{open_how}


@MmuxSetterGetter{open_how, flags,   mmux_uint64_t}
@MmuxSetterGetter{open_how, mode,    mmux_uint64_t}
@MmuxSetterGetter{open_how, resolve, mmux_uint64_t}
@MmuxStructDumper{open_how}


To dump the contents of @code{mmux_libc_open_how_t} we can do:

@example
mmux_libc_file_descriptor_t     fder;
mmux_libc_open_how_t            open_how;

mmux_libc_memzero(&open_how, sizeof(mmux_libc_open_how_t));

mmux_libc_open_how_flags_set(&open_how, \
  MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);

mmux_libc_open_how_mode_set(&open_how, \
  MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

mmux_libc_open_how_resolve_set(&open_how, \
  MMUX_LIBC_RESOLVE_BENEATH               \
  | MMUX_LIBC_RESOLVE_NO_MAGICLINKS       \
  | MMUX_LIBC_RESOLVE_NO_SYMLINKS         \
  | MMUX_LIBC_RESOLVE_NO_XDEV);

mmux_libc_stder(&fder);
if (mmux_libc_open_how_dump(fder, &open_how, NULL)) @{
  /* error */
@}
@end example

@noindent
notice how the Linux kernel demands the data structure to be reset to zero before use; this code
prints:

@example
struct open_how = 0x7ffca7af5b80
struct open_how->flags = 194 (O_ACCMODE | O_CREAT | O_EXCL | O_RDWR)
struct open_how->mode = 384 (S_IRUSR | S_IRWXU | S_IWUSR)
struct open_how->resolve = 15 (RESOLVE_BENEATH | RESOLVE_NO_MAGICLINKS | RESOLVE_NO_SYMLINKS | RESOLVE_NO_XDEV)
@end example


@deftypefn {Linux Function} bool mmux_libc_openat2 (mmux_libc_file_descriptor_t * @var{fd}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_open_how_t const * const @var{how_p})
@MmuxCInterface{openat2}.

@example
mmux_libc_file_system_pathname_t      ptn;
mmux_libc_file_descriptor_t           dirfd;
mmux_libc_file_descriptor_t           fd;
mmux_libc_open_how_t                  open_how;

/* required by the Linux kernel */
mmux_libc_memzero(&open_how, sizeof(mmux_libc_open_how_t));

mmux_libc_open_how_flags_set(&open_how, \
  MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL);

mmux_libc_open_how_mode_set(&open_how, \
  MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR);

mmux_libc_open_how_resolve_set(&open_how, \
  MMUX_LIBC_RESOLVE_BENEATH               \
  | MMUX_LIBC_RESOLVE_NO_MAGICLINKS       \
  | MMUX_LIBC_RESOLVE_NO_SYMLINKS         \
  | MMUX_LIBC_RESOLVE_NO_XDEV);

if (mmux_libc_make_file_system_pathname(&ptn, "./file.ext")) @{
  /* error */
@};

mmux_libc_at_fdcwd(&dirfd);

if (mmux_libc_openat2(&fd, dirfd, ptn, &open_how)) @{
  /* error */
@}
@end example
@end deftypefn

@c page
@node fds closing
@section Closing file descriptors


@deftypefun bool mmux_libc_close (mmux_libc_file_descriptor_t @var{fd})
@MmuxCInterface{close}.
@end deftypefun

@c page
@node fds reading
@section Reading from file descriptors


@deftypefun bool mmux_libc_read (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{read}.

@example
mmux_libc_file_descriptor_t     fd;
mmux_usize_t                    nbytes_done;
mmux_usize_t                    buflen = 4096;
mmux_uint8_t                    bufptr[buflen];

mmux_libc_stdin(&fd);
if (mmux_libc_read(&nbytes_done, fd, bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pread (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_off_t @var{offset})
@MmuxCInterface{pread}.
@end deftypefun

@c page
@node fds writing
@section Writing to file descriptors


@deftypefun bool mmux_libc_write (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{write}.

@example
mmux_libc_file_descriptor_t     fd;
mmux_usize_t                    nbytes_done;
mmux_usize_t                    buflen;
mmux_asciizcp_t                 bufptr = "ciao";

mmux_libc_strlen(&buflen, bufptr);
mmux_libc_stdou(&fd);
if (mmux_libc_write(&nbytes_done, fd, bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pwrite (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_off_t @var{offset})
@MmuxCInterface{pwrite}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_write_buffer (mmux_libc_file_descriptor_t @var{fd}, mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@deftypefunx bool mmux_libc_write_buffer_to_stdou (mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
@deftypefunx bool mmux_libc_write_buffer_to_stder (mmux_pointerc_t @var{bufptr}, mmux_usize_t @var{buflen})
Like @cfunc{mmux_libc_write}, but write a buffer to the file descriptor, respectively: @var{fd},
@stdout{}, @stderr{}.  If the number of written bytes equals @var{buflen}: return @cfalse{},
otherwise return @ctrue{}.

These functions exist mostly as tools in debugging code.

@example
mmux_usize_t    buflen;
mmux_uint8_t    bufptr[buflen];

if (mmux_libc_write_buffer_to_stdou(bufptr, buflen)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds seeking
@section Seeking position in file descriptors


@deftypefun bool mmux_libc_lseek (mmux_libc_file_descriptor_t @var{fd}, mmux_off_t * @var{offset_p}, mmux_sint_t @var{whence})
@MmuxCInterface{lseek}.

Upon calling this function: @var{offset_p} must reference a variable whose value represents the
offset from the position selected by @var{whence}.

Upon successfully returning from this function: the variable referenced by @var{offset_p} has been
updated to represent the resulting position, measured in bytes, from the beginning of the file.

@example
mmux_libc_fd_t  fd     = get_some_fd();
mmux_off_t      offset = 123;
mmux_sint_t     whence = MMUX_LIBC_SEEK_SET;

if (mmux_libc_lseek(fd, &offset, whence)) @{
  /* error */
@}

/* now "offset" has been updated */
@end example
@end deftypefun

@c page
@node fds duplicating
@section Duplicating file descriptors


@deftypefun bool mmux_libc_dup (mmux_libc_file_descriptor_t * @var{new_fd_p}, mmux_libc_file_descriptor_t @var{old_fd})
@MmuxCInterface{dup}.
@end deftypefun


@deftypefun bool mmux_libc_dup2 (mmux_libc_file_descriptor_t @var{old_fd}, mmux_libc_file_descriptor_t @var{new_fd})
@MmuxCInterface{dup2}.
@end deftypefun


@deftypefun bool mmux_libc_dup3 (mmux_libc_file_descriptor_t @var{old_fd}, mmux_libc_file_descriptor_t @var{new_fd}, mmux_sint_t @var{flags})
@MmuxCInterface{dup3}.

@example
mmux_asciizcp_t    pathname = "/path/to/file.ext";
mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

mmux_libc_fd_t  fd1, fd2;

if (mmux_libc_open(&fd1, pathname, flags, mode)) @{
  /* error */
@}

/* I'm so dirty. */
mmux_libc_make_fd(&fd2, 5);

if (mmux_libc_dup3(fd1, fd2, MMUX_LIBC_O_CLOEXEC)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds piping
@section Opening file descriptor pipes


@deftypefun bool mmux_libc_pipe (mmux_libc_file_descriptor_t @var{fds}[2])
@MmuxCInterface{pipe}.

@example
@{
  bool                this_is_the_paren_process;
  mmux_libc_pid_t     child_pid;
  mmux_libc_fd_t      paren_to_child_fds[2];
  mmux_libc_fd_t      paren_fr_child_fds[2];

  if        (mmux_libc_pipe(paren_to_child_fds)) @{
    ... /* error */
  @} else if (mmux_libc_pipe(paren_fr_child_fds)) @{
    ... /* error */
  @} else if (mmux_libc_fork(&this_is_the_paren_process, &child_pid)) @{
    ... /* error */
  @} else if (this_is_the_paren_process) @{
    paren_play(paren_fr_child_fds[0], paren_to_child_fds[1], child_pid);
  @} else @{
    child_play(paren_to_child_fds[0], paren_fr_child_fds[1]);
  @}
@}
void
paren_play (mmux_libc_fd_t read_fr_child_fd, mmux_libc_fd_t writ_to_child_fd, mmux_libc_pid_t child_pid)
@{
  ...
@}
void
child_play (mmux_libc_fd_t read_fr_paren_fd, mmux_libc_fd_t writ_to_paren_fd)
@{
  ...
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_close_pipe (mmux_libc_file_descriptor_t @var{fds}[2])
Close both the file descriptors in @var{fds}.  If both closures succeed: return @cfalse{}; otherwise
return @ctrue{}.  If closing the first fails: this function still closes the second.

This function might be useful when an error occurs after we have created a pipe.
@end deftypefun

@c page
@node fds selecting
@section Selecting file descriptors


Example:

@example
mmux_libc_fd_set_t      read_fd_set[1], writ_fd_set[1], exce_fd_set[1];
mmux_uint_t             nfds_ready;
mmux_uint_t             maximum_nfds_to_check = MMUX_LIBC_FD_SETSIZE;
mmux_libc_timeval_t     timeout[1];
mmux_libc_fd_t          in, ou;
bool                    isset;

mmux_libc_stdin(&in);
mmux_libc_stdou(&ou);

mmux_libc_FD_ZERO(read_fd_set);
mmux_libc_FD_ZERO(writ_fd_set);
mmux_libc_FD_ZERO(exce_fd_set);

mmux_libc_FD_SET(in, read_fd_set);
mmux_libc_FD_SET(ou, writ_fd_set);

mmux_libc_timeval_set(timeout, 1, 0);

if (mmux_libc_select(&nfds_ready, maximum_nfds_to_check,
                     read_fd_set, writ_fd_set, exce_fd_set,
                     timeout)) @{
  /* error */
@}

mmux_libc_FD_ISSET(&isset, in, read_fd_set);
if (isset) @{
  /* do something */
@}

mmux_libc_FD_ISSET(&isset, ou, writ_fd_set);
if (isset) @{
  /* do something */
@}

mmux_libc_FD_ISSET(&isset, in, exce_fd_set);
if (isset) @{
  /* do something */
@}
@end example


@deftypefun bool mmux_libc_FD_ZERO (mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_ZERO}.
@end deftypefun


@deftypefun bool mmux_libc_FD_SET (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_SET}.
@end deftypefun


@deftypefun bool mmux_libc_FD_CLR (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_CLR}.
@end deftypefun


@deftypefun bool mmux_libc_FD_ISSET (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t const * @var{fd_set_p})
@MmuxCInterface{FD_ISSET}.
@end deftypefun


@deftypefun bool mmux_libc_select (mmux_uint_t * @var{nfds_ready_p}, mmux_uint_t @var{maximum_nfds_to_check}, mmux_libc_fd_set_t * @var{read_fd_set_p}, mmux_libc_fd_set_t * @var{write_fd_set_p}, mmux_libc_fd_set_t * @var{except_fd_set_p}, mmux_libc_timeval_t * @var{timeout_p})
@MmuxCInterface{select}.
@end deftypefun

@c page
@node fds scatter-gather
@section Scatter--gather input and output


@MmuxCStructOpaqueTypedef{iovec}


@deftp {Opaque Struct Typedef} mmux_libc_iovec_array_t
Data structure type representing an array of @objtype{mmux_libc_iovec_t} data structures.  It has
the following fields:

@table @code
@item iova_base
Pointer to the array.

@item iova_len
Number of slots in the array.
@end table
@end deftp

@MmuxSetterGetter{iovec, iov_base, mmux_pointer_t}
@MmuxSetterGetter{iovec, iov_len,  mmux_usize_t}
@MmuxStructDumper{iovec}

@MmuxSetterGetter{iovec_array, iova_base, mmux_pointer_t}
@MmuxSetterGetter{iovec_array, iova_len,  mmux_usize_t}
@MmuxStructDumper{iovec_array}


@deftypefun bool mmux_libc_readv (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array})
@MmuxStructDumper{readv}.
@end deftypefun


@deftypefun bool mmux_libc_writev (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array})
@MmuxStructDumper{writev}.
@end deftypefun


@deftypefun bool mmux_libc_preadv (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array}, mmux_off_t @var{offset})
@MmuxStructDumper{preadv}.
@end deftypefun


@deftypefun bool mmux_libc_pwritev (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array}, mmux_off_t @var{offset})
@MmuxStructDumper{pwritev}.
@end deftypefun


@deftypefun bool mmux_libc_preadv2 (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array}, mmux_off_t @var{offset}, mmux_sint_t @var{flags})
@MmuxStructDumper{preadv2}.
@end deftypefun


@deftypefun bool mmux_libc_pwritev2 (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array}, mmux_off_t @var{offset}, mmux_sint_t @var{flags})
@MmuxStructDumper{pwritev2}.
@end deftypefun

@c page
@node fds copying
@section Copying ranges from file to file


@deftypefun bool mmux_libc_copy_file_range (mmux_usize_t * @var{number_of_bytes_copied_p}, mmux_libc_file_descriptor_t @var{input_fd}, mmux_sint64_t * @var{input_position_p}, mmux_libc_file_descriptor_t @var{ouput_fd}, mmux_sint64_t * @var{ouput_position_p}, mmux_usize_t @var{number_of_bytes_to_copy}, mmux_sint_t @var{flags})
@MmuxCInterface{copy_file_range}.
@end deftypefun


If we need to copy data between file descriptors, we can adapt the following code template:

@example
mmux_libc_fd_t                  infd, oufd;

static mmux_usize_t const       read_buflen = 1024;
mmux_octet_t                    read_bufptr[read_buflen];
mmux_usize_t                    nbytes_read;

gimme_an_input_fd(&infd);
gimme_an_ouput_fd(&oufd);

/* Loop reading while the number of bytes read is positive. */
do @{
  if (mmux_libc_read(&nbytes_read, infd, read_bufptr, read_buflen)) @{
    /* error */
  @}

  if (nbytes_read > 0) @{
    mmux_octet_t *  write_bufptr    = read_bufptr;
    mmux_usize_t    write_buflen    = nbytes_read;
    mmux_usize_t    nbytes_written  = 0;

    /* Loop writing until we have written all the bytes from the buffer. */
    do @{
      if (mmux_libc_write(&nbytes_written, oufd, write_bufptr, write_buflen)) @{
        /* error */
      @}

      if (nbytes_written < write_buflen) @{
        write_bufptr += nbytes_written;
        write_buflen -= nbytes_written;
      @}
    @} while (nbytes_written < write_buflen);
  @}
@} while (nbytes_read > 0);
@end example
@c page
@node fds flock
@section File locks


@MmuxCStructOpaqueTypedef{flock}
@MmuxSetterGetter{flock, l_type,   mmux_sshort_t}
@MmuxSetterGetter{flock, l_whence, mmux_sshort_t}
@MmuxSetterGetter{flock, l_start,  mmux_off_t}
@MmuxSetterGetter{flock, l_len,    mmux_off_t}
@MmuxSetterGetter{flock, l_pid,    mmux_libc_pid_t}
@MmuxStructDumper{flock}

@deftypefun bool mmux_libc_flag_to_symbol_struct_flock_l_type (mmux_asciizcp_t* @var{str_p}, mmux_sint_t @var{flag})
Identify @var{flag} as a value for the field @code{l_type} of @objtype{mmux_libc_flock_t}; store in
the variable referenced by @var{str_p} a pointer to a statically allocated @asciiz{} string
representing the name of the value.
@end deftypefun

@c page
@node fds fun control
@section File descriptors functionality ontrol


@deftypefun bool mmux_libc_fcntl (mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{command}, mmux_pointer_t @var{parameter_p})
@MmuxCInterface{fcntl}.  Arguments:

@table @var
@item fd
A file descriptor.

@item command
A constant representing a command for @cfunc{fcntl}.

@item parameter_p
Pointer to a variable representing a parameter that can be input or output depending on the
@var{command}.
@end table
@end deftypefun


@deftypefun bool mmux_libc_fcntl_command_flag_to_symbol (mmux_asciizcp_t* @var{str_p}, mmux_sint_t @var{command})
Identify @var{command} as a command argument for @cfunc{mmux_libc_fcntl}; store in the variable
referenced by @var{str_p} a pointer to a statically allocated @asciiz{} string representing a string
representation of the @var{command}.
@end deftypefun

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_DUPFD
Duplicate a file descriptor; @var{parameter_p} must reference a variable of type
@objtype{mmux_libc_file_descriptor_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETFD
Get file descriptor flags, like @samp{MMUX_LIBC_FD_CLOEXEC}; @var{parameter_p} must reference a variable
of type @objtype{mmux_sint_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETFD
Set file descriptor flags, like @samp{MMUX_LIBC_FD_CLOEXEC}; @var{parameter_p} must reference a variable
of type @objtype{mmux_sint_t} holding a bitwise OR combination of flags.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETFL
Get open file descriptor flags, like @samp{O_RDWR}; @var{parameter_p} must reference a variable of
type @objtype{mmux_sint_t}.

To set blocking mode for a file descriptor we do:

@example
mmux_libc_fd_t  fd;
mmux_sint_t     parameter;

/* Acquire current file descriptor flags. */
if (mmux_libc_fcntl(in, MMUX_LIBC_F_GETFL, &parameter)) @{
  /* error */
@}

/* Null the non-block flag. */
parameter &= (~ MMUX_LIBC_O_NONBLOCK);

/* Set the new flags. */
if (mmux_libc_fcntl(in, MMUX_LIBC_F_SETFL, &parameter)) @{
  /* error */
@}
@end example
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETFL
Set open file descriptor flags, like @samp{O_APPEND}; @var{parameter_p} must reference a variable of
type @objtype{mmux_sint_t} holding a bitwise OR combination of flags.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETLK
Get a @MmuxCStruct{flock} describing a lock that blocks a requested lock; @var{parameter_p} must
reference a value of type @objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETLK
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETLKW
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_GETLK
Get a @MmuxCStruct{flock} describing a lock that blocks a requested lock; @var{parameter_p} must
reference a value of type @objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_SETLK
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_SETLKW
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETOWN
Get the process or group id that receives the signal @samp{SIGIO}; @var{parameter_p} must reference
a variable of type @objtype{mmux_libc_pid_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETOWN
Set the process or group id that receives the signal @samp{SIGIO}; @var{parameter_p} must reference
a variable of type @objtype{mmux_libc_pid_t}.
@end defvr

@c page
@node fds io control
@section File descriptors input/output control


@deftypefun bool mmux_libc_ioctl (mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{command}, mmux_pointer_t @var{parameter_p})
@MmuxCInterface{ioctl}.  Arguments:

@table @var
@item fd
A file descriptor.

@item command
A constant representing a command for @cfunc{ioctl}.

@item parameter_p
Pointer to a variable representing a parameter that can be input or output depending on the
@var{command}.
@end table
@end deftypefun

@c ------------------------------------------------------------------------

@defvr {Iontl Command} MMUX_LIBC_SIOCATMARK
Detect if the data received through a socket has reached the mark; @var{parameter_p} must reference
a variable of type @objtype{mmux_sint_t}.
@end defvr

@c page
@node fds memfd
@section Memory--mapped file descriptors


To use a memory--mapped file descriptor, we do:

@example
mmux_libc_fd_t  mfd;

if (mmux_libc_make_mfd(&mfd)) @{
  /* error */
@}
@{
  /* Write something. */
  if (mmux_libc_dprintf(mfd, "The value is %d.\n", 123)) @{
    /* error */
  @}

  /* Copy the data to stdout. */
  if (mmux_libc_mfd_writeou(mfd)) @{
    /* error */
  @}
@}
if (mmux_libc_close(mfd)) @{
  /* error */
@}
@end example

@noindent
we can apply to a memory--mapped file descriptor almost all the functions that act upon ordinary
file descriptors.


@deftypefun bool mmux_libc_make_mfd (mmux_libc_file_descriptor_t * @var{mfd_p})
Create a new file descriptor whose underlying device is mapped into ordinary memory; store the
resulting file descriptor in the variable referenced by @var{mfd_p}.  This function makes use of
@cfunc{mmux_libc_memfd_create}.
@end deftypefun


@deftypefun bool mmux_libc_mfd_length (mmux_usize_t * @var{len_p}, mmux_libc_file_descriptor_t @var{mfd})
Store in the variable referenced by @var{len_p} the number of bytes in the device underlying
@var{mfd}.
@end deftypefun


@deftypefun bool mmux_libc_mfd_write (mmux_libc_file_descriptor_t @var{oufd}, mmux_libc_file_descriptor_t @var{mfd})
Copy all the data in the device underlying @var{mfd} to the file descriptor @var{oufd}.

This function ignores the current device position, writing all the data from the beginning to the
end of the underlying device.  When successful: the current device position is restored to the
original, so it is left unchanged.  If an error occurs: the underlying device position is undefined.

@strong{NOTE} It appears the memory--mapped file descriptors cannot be used with
@cfunc{mmux_libc_copy_file_range}.
@end deftypefun


@deftypefun bool mmux_libc_mfd_writeou (mmux_libc_file_descriptor_t @var{mfd})
@deftypefunx bool mmux_libc_mfd_writeer (mmux_libc_file_descriptor_t @var{mfd})
Wrappers for @cfunc{mmux_libc_mfd_write} that write the underlying device contents to, respectively:
@stdout{}, @stderr{}.
@end deftypefun

@c page
@node fs
@chapter File system


@menu
* fs types::                    Type definitions for file system operations.
* fs links::                    Hard and symbolic links.
* fs deleting::                 Deleting links.
* fs renaming::                 Renaming links.
* fs directories::              Directories.
* fs ownership::                File ownership.
* fs permissions::              File access permissions.
* fs attributes::               File attributes.
* fs truncating::               Truncating files.
* fs times::                    File system times.
@end menu

@c page
@node fs types
@section Type definitions for file system operations


@deftp {Opaque Struct Type} mmux_libc_file_system_pathname_t
@deftpx {Opaque Struct Type} mmux_libc_ptn_t
Data type representing a file system pathname as a non--@cnull{} pointer to @asciiz{} string.
@end deftp


@deftypefun bool mmux_libc_make_file_system_pathname (mmux_libc_file_system_pathname_t * @var{pathname_p}, mmux_asciizcp_t @var{asciiz_pathname})
Make a new file system pathname value.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_free (mmux_libc_file_system_pathname_t @var{pathname})
Release the memory holding the pathname as @asciiz{} string using @cfunc{mmux_libc_free}.
@end deftypefun

@c page
@node fs links
@section Hard and symbolic links


@deftypefun bool mmux_libc_link (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{link}.
@end deftypefun


@deftypefun bool mmux_libc_linkat (mmux_libc_file_descriptor_t @var{oldfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newfd}, mmux_libc_file_system_pathname_t @var{newname}, mmux_sint_t @var{flags})
@MmuxCInterface{linkat}
@end deftypefun


@deftypefun bool mmux_libc_symlink (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{symlink}.
@end deftypefun


@deftypefun bool mmux_libc_readlink (mmux_usize_t * @var{required_nbytes_p}, mmux_libc_file_system_pathname_t @var{linkname}, mmux_asciizp_t @var{buffer}, mmux_usize_t @var{provided_nbytes})
@MmuxCInterface{readlink}.
@end deftypefun


@deftypefun bool mmux_libc_readlink_malloc (mmux_libc_file_system_pathname_t * @var{result_pathname_p}, mmux_libc_file_system_pathname_t @var{linkname})
Like @cfunc{mmux_libc_readlink} but when successful: allocate a memory block, using
@cfunc{mmux_libc_malloc}, and store the resulting pathname @asciiz{} string in it, including the
terminating nul character; we must release the allocated memory using @cfunc{mmux_libc_free}.
@end deftypefun


@deftypefun bool mmux_libc_readlinkat (mmux_usize_t * @var{required_nbytes_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{linkname}, mmux_asciizp_t @var{buffer}, mmux_usize_t @var{provided_nbytes})
@MmuxCInterface{readlinkat}.
@end deftypefun


@deftypefun bool mmux_libc_readlinkat_malloc (mmux_libc_file_system_pathname_t * @var{result_pathname_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{linkname})
Like @cfunc{mmux_libc_readlinkat} but when successful: allocate a memory block, using
@cfunc{mmux_libc_malloc}, and store the resulting pathname @asciiz{} string in it, including the
terminating nul character; we must release the allocated memory using @cfunc{mmux_libc_free}.
@end deftypefun


@deftypefun bool mmux_libc_canonicalize_file_name (mmux_libc_file_system_pathname_t * @var{result_pathname_p}, mmux_libc_file_system_pathname_t @var{input_pathname})
@MmuxCInterface{canonicalize_file_name}.  When successful: a memory buffer is allocated, using
@cfunc{mmux_libc_malloc}, and the resulting pathname is stored in it, including the terminating nul;
a pointer to the buffer is stored in the location referenced by @var{result_pathname_p}.  It is
responsibility of the caller to release the buffer with a call to @cfunc{mmux_libc_free}.
@end deftypefun


@deftypefun bool mmux_libc_realpath (mmux_asciizp_t * @var{result_pathname_p}, mmux_libc_file_system_pathname_t @var{input_pathname})
@MmuxCInterface{realpath}.  When successful: a memory buffer is allocated, using
@cfunc{mmux_libc_malloc}, and the resulting pathname is stored in it, including the terminating nul;
a pointer to the buffer is stored in the location referenced by @var{result_pathname_p}.  It is
responsibility of the caller to release the buffer with a call to @cfunc{mmux_libc_free}.
@end deftypefun

@c page
@node fs deleting
@section Deleting links


@deftypefun bool mmux_libc_unlink (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{unlink}.
@end deftypefun


@deftypefun bool mmux_libc_unlinkat (mmux_libc_file_descriptor_t dirfd, mmux_libc_file_system_pathname_t pathname, mmux_sint_t flags)
@MmuxCInterface{unlinkat}.
@end deftypefun


@deftypefun bool mmux_libc_rmdir (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{rmdir}.
@end deftypefun


@deftypefun bool mmux_libc_remove (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{remove}.
@end deftypefun

@c page
@node fs renaming
@section Renaming links


@deftypefun bool mmux_libc_rename (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{rename}.
@end deftypefun


@deftypefun bool mmux_libc_renameat (mmux_libc_file_descriptor_t @var{olddirfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newdirfd}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{renameat}.
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_renameat2 (mmux_libc_file_descriptor_t @var{olddirfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newdirfd}, mmux_libc_file_system_pathname_t @var{newname}, mmux_uint_t flags)
@MmuxCInterface{renameat2}.
@end deftypefn

@c page
@node fs directories
@section Directories


@deftypefun bool mmux_libc_mkdir (mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t mode)
@MmuxCInterface{mkdir}.
@end deftypefun


@deftypefun bool mmux_libc_mkdirat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode})
@MmuxCInterface{mkdirat}.
@end deftypefun

@c page
@node fs ownership
@section File ownership


@deftypefun bool mmux_libc_chown (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterface{chown}.
@end deftypefun


@deftypefun bool mmux_libc_fchown (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterface{fchown}.
@end deftypefun


@deftypefun bool mmux_libc_lchown (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterface{lchown}.
@end deftypefun


@deftypefun bool mmux_libc_fchownat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid}, mmux_sint_t flags);
@MmuxCInterface{fchownat}.
@end deftypefun

@c page
@node fs permissions
@section File access permissions


@deftypefun bool mmux_libc_umask (mmux_mode_t * @var{old_mask_p}, mmux_mode_t @var{new_mask})
@MmuxCInterface{umask}.
@end deftypefun


@deftypefun bool mmux_libc_getumask (mmux_mode_t * @var{current_mask_p})
Store the current mask in the location referenced by @var{current_mask_p}.  Do not change the
current mask.
@end deftypefun


@deftypefun bool mmux_libc_chmod (mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode})
@MmuxCInterface{chmod}.
@end deftypefun


@deftypefun bool mmux_libc_fchmod (mmux_libc_file_descriptor_t @var{fd}, mmux_mode_t @var{mode})
@MmuxCInterface{fchmod}.
@end deftypefun


@deftypefun bool mmux_libc_fchmodat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode}, mmux_sint_t @var{flags})
@MmuxCInterface{fchmodat}.
@end deftypefun


@deftypefun bool mmux_libc_access (mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{how})
@MmuxCInterface{access}.
@end deftypefun


@deftypefun bool mmux_libc_faccessat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{how}, mmux_sint_t @var{flags})
@MmuxCInterface{faccessat}.
@end deftypefun

@c page
@node fs attributes
@section File attributes


@MmuxCStructOpaqueTypedef{stat}
@MmuxSetterGetter{stat, st_mode,        mmux_mode_t}
@MmuxSetterGetter{stat,	st_ino,		mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_dev,		mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_nlink,	mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_uid,		mmux_libc_uid_t}
@MmuxSetterGetter{stat,	st_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{stat,	st_size,	mmux_off_t}
@MmuxSetterGetter{stat,	st_atime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_atime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_mtime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_mtime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_ctime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_ctime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_blocks,	mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_blksize,	mmux_uint_t}
@MmuxStructDumper{stat}


@deftypefun bool mmux_libc_stat (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{stat}.
@end deftypefun


@deftypefun bool mmux_libc_fstat (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{fstat}.
@end deftypefun


@deftypefun bool mmux_libc_lstat (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{lstat}.
@end deftypefun


@deftypefun bool mmux_libc_fstatat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p}, mmux_sint_t flags)
@MmuxCInterface{fstatat}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISMQ (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPESIMQ}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISSEM (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPEISSEM}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISSHM (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPEISSHM}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISDIR (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISDIR}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISCHR (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISCHR}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISBLK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISBLK}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISREG (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISREG}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISFIFO (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISFIFO}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISLNK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISLNK}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISSOCK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISSOCK}.
@end deftypefun

@c page
@node fs truncating
@section Truncating files


@deftypefun bool mmux_libc_truncate (mmux_libc_file_system_pathname_t pathname, mmux_off_t len)
@MmuxCInterface{truncate}.
@end deftypefun


@deftypefun bool mmux_libc_ftruncate (mmux_libc_file_descriptor_t fd, mmux_off_t len);
@MmuxCInterface{ftruncate}.
@end deftypefun

@c page
@node fs times
@section File system times


@MmuxCStructOpaqueTypedef{utimbuf}
@MmuxSetterGetter{utimbuf, actime,  mmux_time_t}
@MmuxSetterGetter{utimbuf, modtime, mmux_time_t}
@MmuxStructDumper{utimbuf}


@deftypefun bool mmux_libc_utime (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_utimbuf_t @var{utimbuf})
@MmuxCInterface{utime}.
@end deftypefun


@deftypefun bool mmux_libc_utimes (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{utimes}.
@end deftypefun

@deftypefun bool mmux_libc_lutimes (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{lutimes}.
@end deftypefun


@deftypefun bool mmux_libc_futimes (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timeval_t @var{access}, mmux_libc_timeval_t @var{modification})
@MmuxCInterface{futimes}.
@end deftypefun

@c page
@node sockets
@chapter Networking sockets


@menu
* sockets inames::              Socket interface names.
* sockets in_addr::             Address format @objtype{mmux_libc_in_addr_t}.
* sockets insix_addr::          Address format @objtype{mmux_libc_insix_addr_t}.
* sockets sockaddr_un::         Address format @objtype{mmux_libc_sockaddr_un_t}.
* sockets sockaddr_in::         Address format @objtype{mmux_libc_sockaddr_in_t}.
* sockets sockaddr_insix::      Address format @objtype{mmux_libc_sockaddr_insix_t}.
* sockets sockaddr::            Address format @objtype{mmux_libc_sockaddr_t}.
* sockets addrinfo::            Address informations.
* sockets hostsdb::             Hosts database.
* sockets servicesdb::          Services database.
* sockets protocolsdb::         Protocols database.
* sockets networksdb::          Networks database.
* sockets byteorder::           Converting byte order in socket addresses.
* sockets convaddr::            Converting socket addresses between formats.
* sockets getaddrinfo::         Getting address informations.
* sockets getnameinfo::         Getting address name informations.
* sockets creating::            Sockets: creating, pairs, shutting down, inspecting.
* sockets stream::              Sending and receiving data through a stream socket.
* sockets server::              Stream socket servers.
* sockets client::              Stream socket clients.
* sockets dgram::               Sending and receiving data through a datagram socket.
* sockets options::             Socket options.
@end menu

@c page
@node sockets inames
@section Socket interface names


@MmuxCStructOpaqueTypedef{if_nameindex}
@MmuxCStructPointerOpaqueTypedef{if_nameindex}
@MmuxSetterGetter{if_nameindex, if_index, mmux_uint_t}
@MmuxSetterGetter{if_nameindex, if_name,  mmux_asciizcp_t}
@MmuxStructDumper{if_nameindex}


@deftypefun bool mmux_libc_if_nametoindex (mmux_uint_t * @var{index_p}, mmux_asciizcp_t @var{network_interface_name})
@MmuxCInterface{if_nametoindex}.

@example
mmux_asciizcp_t         network_interface_name = "eth0";
mmux_uint_t             network_interface_index;

if (mmux_libc_if_nametoindex(&network_interface_index, network_interface_name)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_indextoname (mmux_asciizp_t @var{result_network_interface_name}, mmux_uint_t @var{network_interface_index})
@MmuxCInterface{if_indextoname}.

@example
mmux_uint_t     network_interface_index = 2;
char            network_interface_name[MMUX_LIBC_IFNAMSIZ];

if (mmux_libc_if_indextoname(network_interface_name, network_interface_index) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_nameindex (mmux_libc_if_nameindex_t const * * @var{result_nameindex_array_p})
@MmuxCInterface{if_nameindex}.

@example
mmux_libc_if_nameindex_t const *        nameindex_array;

if (mmux_libc_if_nameindex(&nameindex_array)) @{
  /* error */
@}

for (int i=0; true; ++i) @{
  mmux_uint_t           if_index;
  mmux_asciizcp_t       if_name;

  mmux_libc_if_index_ref(&if_index, A + i);
  mmux_libc_if_name_ref (&if_name,  A + i);

  if (if_index) @{
    /* do something with "if_index" and "if_name" */
  @} else @{
    break;
  @}
@}

mmux_libc_if_freenameindex(nameindex_array);
@end example
@end deftypefun


@deftypefun bool mmux_libc_if_freenameindex (mmux_libc_if_nameindex_t const * @var{nameindex_array})
@MmuxCInterface{if_freenameindex}.
@end deftypefun

@c page
@node sockets in_addr
@section Address format @objtype{mmux_libc_in_addr_t}


Data structures of type @objtype{mmux_libc_in_addr_t} represent IPv4 addresses in numerical form, as
32-bit values stored in network byte order.


@MmuxCStructOpaqueTypedef{in_addr}
@MmuxCStructPointerOpaqueTypedef{in_addr}
@MmuxSetterGetter{in_addr, s_addr, mmux_uint32_t}
@MmuxStructDumper{in_addr}


@deftypefun bool mmux_libc_make_in_addr (mmux_libc_in_addr_t * in_addr_p, mmux_uint32_t network_byteorder_value)
Initialise the data structure referenced by @var{in_addr_p} to the address
@var{network_byteorder_value}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_none (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_NONE}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_any (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_ANY}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_broadcast (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_BROADCAST}.
@end deftypefun


@deftypefun bool mmux_libc_make_in_addr_loopback (mmux_libc_in_addr_t * @var{in_addr_p})
Initialise the data structure referenced by @var{in_addr_p} to the predefined standard address
@code{INADDR_LOOPBACK}.
@end deftypefun

@c page
@node sockets insix_addr
@section Address format @objtype{mmux_libc_insix_addr_t}


Data structures of type @objtype{mmux_libc_insix_addr_t} represent IPv6 addresses in binary format.


@deftp {Opaque Struct Typedef} mmux_libc_insix_addr_t
An opaque alias for @code{struct in6_addr}.
@end deftp

@MmuxCStructPointerOpaqueTypedef{insix_addr}
@MmuxStructDumper{insix_addr}


@deftypefun bool mmux_libc_make_insix_addr_loopback (mmux_libc_insix_addr_t * @var{insix_addr_p})
Initialise the data structure referenced by @var{insix_addr_p} to the predefined standard
@code{in6addr_loopback}.
@end deftypefun


@deftypefun bool mmux_libc_make_insix_addr_any (mmux_libc_insix_addr_t * @var{insix_addr_p})
Initialise the data structure referenced by @var{insix_addr_p} to the predefined standard
@code{in6addr_any}.
@end deftypefun

@c page
@node sockets sockaddr_un
@section Address format @objtype{mmux_libc_sockaddr_un_t}


@MmuxCStructOpaqueTypedef{sockaddr_un}
@MmuxCStructPointerOpaqueTypedef{sockaddr_un}
@MmuxSetterGetter{sockaddr_un, sun_family, mmux_sshort_t}
@MmuxSetterGetter{sockaddr_un, sun_path,   mmux_libc_file_system_pathname_t}
@MmuxStructDumper{sockaddr_un}


The file system pathname associated to an address of format @objtype{mmux_libc_sockaddr_un_t} is
embedded in the data structure itself; it has maximum length of fixed size, hard--coded in the data
structure definition.  The pathname must be an @asciiz{} string and the terminating nul must be
included in the embedded @asciiz{} string.

If we want to allocate a block of memory wide enough to contain a pathname of maximum length we have
to take the @cfunc{sizeof} of the data structure type.  If we want to compute the address size
needed as arguments by some socket functions: we have to use the following function.


@deftypefun mmux_usize_t mmux_libc_SUN_LEN (mmux_libc_sockaddr_un_t const * @var{sockaddr_un_p})
Return the address size, measured in bytes, of the address data structure referenced by
@var{sockaddr_un_p}.

@itemize
@item
The returned size does @strong{not} include the terminating nul of the included file pathname.

@item
The returned size is the correct value to hand to functions requiring the address size, like
@cfunc{mmux_libc_bind}.
@end itemize
@end deftypefun

@c page
@node sockets sockaddr_in
@section Address format @objtype{mmux_libc_sockaddr_in_t}


@MmuxCStructOpaqueTypedef{sockaddr_in}
@MmuxCStructPointerOpaqueTypedef{sockaddr_in}
@MmuxSetterGetter{sockaddr_in, sin_family, mmux_sshort_t}
@MmuxSetterGetter{sockaddr_in, sin_addr,   mmux_libc_in_addr_t}
@MmuxSetterGetter{sockaddr_in, sin_port,   mmux_host_byteorder_ushort_t}
@MmuxStructDumper{sockaddr_in}


@deftypefun bool mmux_libc_sin_addr_p_ref (mmux_libc_in_addr_t ** sin_addr_pp, mmux_libc_sockaddr_in_t * sockaddr_p)
Store in the location referenced by @var{sin_addr_pp} a pointer to the field @code{sin_addr} of the
data structure referenced by @var{sockaddr_p}.
@end deftypefun

@c page
@node sockets sockaddr_insix
@section Address format @objtype{mmux_libc_sockaddr_insix_t}


To ease typing on keyboards, @value{PACKAGE} renames: the name of the data structure @code{struct
sockaddr_in6} to @objtype{mmux_libc_sockaddr_insix_t}; the fields @code{sin6_} of @code{struct
sockaddr_in6} to @code{sinsix_}.


@deftp {Opaque Struct Typedef} mmux_libc_sockaddr_insix_t
An opaque alias for @code{struct sockaddr_in6}.
@end deftp


@MmuxCStructPointerOpaqueTypedef{sockaddr_insix}
@MmuxSetterGetter{sockaddr_insix, sinsix_family,   mmux_sshort_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_addr,     mmux_libc_insix_addr_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_flowinfo, mmux_uint32_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_scope_id, mmux_uint32_t}
@MmuxSetterGetter{sockaddr_insix, sinsix_port,     mmux_host_byteorder_uint16_t}
@MmuxStructDumper{sockaddr_insix}


@deftypefun bool mmux_libc_sinsix_addr_p_ref (mmux_libc_insix_addr_t ** @var{sin_addr_pp}, mmux_libc_sockaddr_in_t * @var{sockaddr_p})
Store in the location referenced by @var{sinsix_addr_pp} a pointer to the field @code{sinsix_addr}
of the data structure referenced by @var{sockaddr_p}.
@end deftypefun

@c page
@node sockets sockaddr
@section Address format @objtype{mmux_libc_sockaddr_t}


@deftp {Opaque Struct Typedef} mmux_libc_sockaddr_t
An opaque alias for a non--standard data structure type: we can handle this type as being big enough
to contain any of the data structure types @code{struct sockaddr_*}.  @value{PACKAGE} uses this data
type as alias for @MmuxCStruct{sockaddr}.
@end deftp

@MmuxCStructPointerOpaqueTypedef{sockaddr}
@MmuxSetterGetter{sockaddr, sa_family,   mmux_sshort_t}
@MmuxStructDumper{sockaddr}

@c page
@node sockets addrinfo
@section Address informations


@MmuxCStructOpaqueTypedef{addrinfo}
@MmuxCStructPointerOpaqueTypedef{addrinfo}
@MmuxSetterGetter{addrinfo, ai_flags,           mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_family,          mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_socktype,        mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_protocol,        mmux_sint_t}
@MmuxSetterGetter{addrinfo, ai_addrlen,         mmux_socklen_t}
@MmuxSetterGetter{addrinfo, ai_addr,            mmux_libc_sockaddr_t *}
@MmuxSetterGetter{addrinfo, ai_canonname,       mmux_asciizp_t}
@MmuxSetterGetter{addrinfo, ai_next,            mmux_libc_addrinfo_t *}
@MmuxStructDumper{addrinfo}

@c page
@node sockets hostsdb
@section Hosts database


@MmuxCStructOpaqueTypedef{hostent}
@MmuxCStructPointerOpaqueTypedef{hostent}
@MmuxSetterGetter{hostent, h_name,              mmux_asciizp_t}
@MmuxSetterGetter{hostent, h_aliases,           mmux_asciizpp_t}
@MmuxSetterGetter{hostent, h_addrtype,          mmux_sint_t}
@MmuxSetterGetter{hostent, h_length,            mmux_sint_t}
@MmuxSetterGetter{hostent, h_addr_list,         mmux_asciizpp_t}
@MmuxSetterGetter{hostent, h_addr,              mmux_asciizp_t}
@MmuxStructDumper{hostent}


@deftypefun bool mmux_libc_sethostent (mmux_sint_t @var{stayopen})
@MmuxCInterface{sethostent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endhostent (void)
@MmuxCInterface{endhostent}.
@end deftypefun


@deftypefun bool mmux_libc_gethostent (mmux_libc_hostent_t const * * @var{result_hostent_pp})
@MmuxCInterface{gethostent}.
@end deftypefun

@c page
@node sockets servicesdb
@section Services database


@MmuxCStructOpaqueTypedef{servent}
@MmuxCStructPointerOpaqueTypedef{servent}
@MmuxSetterGetter{servent, s_name,		mmux_asciizp_t}
@MmuxSetterGetter{servent, s_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{servent, s_port,		mmux_sint_t}
@MmuxSetterGetter{servent, s_proto,		mmux_asciizp_t}
@MmuxStructDumper{servent}


@deftypefun bool mmux_libc_setservent (mmux_sint_t @var{stayopen})
@MmuxCInterface{setservent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endservent (void)
@MmuxCInterface{endservent}.
@end deftypefun


@deftypefun bool mmux_libc_getservent (mmux_libc_servent_t const * * @var{result_servent_pp})
@MmuxCInterface{getservent}.
@end deftypefun


@deftypefun bool mmux_libc_getservbyname(mmux_libc_servent_t const * * @var{result_servent_pp}, mmux_asciizcp_t @var{service_name_p}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getservbyname}.  If an error occurs: @var{result_servent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_servent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 service_name_p  = "smtp";
mmux_asciizcp_t                 protocol_name_p = "tcp";
mmux_libc_servent_t const *     servent_p;

if (mmux_libc_getservbyname(&servent_p, service_name_p, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getservbyport (mmux_libc_servent_t const * * @var{result_servent_pp}, mmux_sint_t @var{host_byteorder_port}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getservbyport}.  If an error occurs: @var{result_servent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_servent_pp} is never set to
@cnull{}.

@example
mmux_sint_t                     host_byteorder_port = 25;
mmux_asciizcp_t                 protocol_name_p     = "tcp";
mmux_libc_servent_t const *     servent_p;

if (mmux_libc_getservbyport(&servent_p, host_byteorder_port, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node sockets protocolsdb
@section Protocols database


@MmuxCStructOpaqueTypedef{protoent}
@MmuxCStructPointerOpaqueTypedef{protoent}
@MmuxSetterGetter{protoent, p_name,		mmux_asciizp_t}
@MmuxSetterGetter{protoent, p_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{protoent, p_proto,		mmux_sint_t}
@MmuxStructDumper{protoent}


@deftypefun bool mmux_libc_setprotoent (mmux_sint_t @var{stayopen})
@MmuxCInterface{setprotoent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endprotoent (void)
@MmuxCInterface{endprotoent}.
@end deftypefun


@deftypefun bool mmux_libc_getprotoent (mmux_libc_protoent_t const * * @var{result_protoent_pp})
@MmuxCInterface{getprotoent}.
@end deftypefun


@deftypefun bool mmux_libc_getprotobyname (mmux_libc_protoent_t const * * @var{result_protoent_pp}, mmux_asciizcp_t @var{protocol_name_p})
@MmuxCInterface{getprotobyname}.  If an error occurs: @var{result_protoent_pp} is left untouched and
the return value is @ctrue{}.  The location referenced by @var{result_protoent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 protocol_name_p = "tcp";
mmux_libc_protoent_t const *    protoent_p;

if (mmux_libc_getprotobyname(&protoent_p, protocol_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getprotobynumber (mmux_libc_protoent_t const * * @var{result_protoent_pp}, mmux_sint_t @var{proto})
@MmuxCInterface{getprotobynumber}.  If an error occurs: @var{result_protoent_pp} is left untouched
and the return value is @ctrue{}.  The location referenced by @var{result_protoent_pp} is never set
to @cnull{}.

@example
mmux_libc_protoent_t const *    protoent_p;

if (mmux_libc_getprotobyname(&protoent_p, MMUX_LIBC_IPPROTO_TCP)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node sockets networksdb
@section Networks database


@MmuxCStructOpaqueTypedef{netent}
@MmuxCStructPointerOpaqueTypedef{netent}
@MmuxSetterGetter{netent, n_name,		mmux_asciizp_t}
@MmuxSetterGetter{netent, n_aliases,		mmux_asciizpp_t}
@MmuxSetterGetter{netent, n_addrtype,		mmux_sint_t}
@MmuxSetterGetter{netent, n_net,		mmux_ulong_t}
@MmuxStructDumper{netent}


@deftypefun bool mmux_libc_setnetent (mmux_sint_t @var{stayopen})
@MmuxCInterface{setnetent}.
@end deftypefun


@deftypefun decl bool mmux_libc_endnetent (void)
@MmuxCInterface{endnetent}.
@end deftypefun


@deftypefun bool mmux_libc_getnetent (mmux_libc_netent_t const * * @var{result_netent_pp})
@MmuxCInterface{getnetent}.
@end deftypefun


@deftypefun bool mmux_libc_getnetbyname (mmux_libc_netent_t const * * @var{result_netent_pp}, mmux_asciizcp_t @var{network_name_p})
@MmuxCInterface{getnetbyname}.  If an error occurs: @var{result_netent_pp} is left untouched and the
return value is @ctrue{}.  The location referenced by @var{result_netent_pp} is never set to
@cnull{}.

@example
mmux_asciizcp_t                 network_name_p = "loopback";
mmux_libc_netent_t const *      netent_p;

if (mmux_libc_getnetbyname(&netent_p, network_name_p)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_getnetbyaddr (mmux_libc_netent_t const * * @var{result_netent_pp}, mmux_uint32_t @var{n_net}, mmux_sint_t @var{af_type})
@MmuxCInterface{getnetbyaddr}.  If an error occurs: @var{result_netent_pp} is left untouched and the
return value is @ctrue{}.  The location referenced by @var{result_netent_pp} is never set to
@cnull{}.

The argument @var{n_net} is homogeneous to the values of the field @samp{n_net} of
@MmuxCStruct{netent}: the network address in host byteorder.

@example
mmux_asciizcp_t                 dotted_quad = "127.0.0.0";
mmux_libc_in_addr_t             address;
mmux_uint32_t                   netw_byteorder_n_net;
mmux_uint32_t                   host_byteorder_n_net;
mmux_libc_netent_t const *      netent_p;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET, dotted_quad)) @{
  /* error */
@}
mmux_libc_s_addr_ref(&netw_byteorder_n_net, &address);
mmux_libc_ntohl(&host_byteorder_n_net, netw_byteorder_n_net);
if (mmux_libc_getnetbyaddr(&netent_p, host_byteorder_n_net, MMUX_LIBC_AF_INET)) @{
  /* error */
@}
/* do something with "netent_p" */
@end example
@end deftypefun

@c page
@node sockets byteorder
@section Converting byte order in socket addresses


@deftypefun bool mmux_libc_htons (mmux_uint16_t * network_byteorder_value_p, mmux_uint16_t host_byteorder_value)
@MmuxCInterface{htons}.  Host--to--network short--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_ntohs (mmux_uint16_t * host_byteorder_value_p, mmux_uint16_t network_byteorder_value)
@MmuxCInterface{ntohs}.  Network--to--host short--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_htonl (mmux_uint32_t * network_byteorder_value_p, mmux_uint32_t host_byteorder_value)
@MmuxCInterface{htonl}.  Host--to--network long--number byte order conversion.
@end deftypefun


@deftypefun bool mmux_libc_ntohl (mmux_uint32_t * host_byteorder_value_p, mmux_uint32_t network_byteorder_value)
@MmuxCInterface{ntohl}.  Network--to--host long--number byte order conversion.
@end deftypefun

@c page
@node sockets convaddr
@section Converting socket addresses between formats


@deftypefun bool mmux_libc_inet_pton (mmux_pointer_t @var{ouput_addr_p}, mmux_sint_t @var{input_af_family}, mmux_asciizcp_t @var{input_presentation_p})
@MmuxCInterface{inet_pton}.

Convert the @asciiz{} Internet address presentation referenced by @var{input_presentation_p} into a
binary data structure; the presentation is expected to represent an address in the format specified
by @var{input_af_family}, for example @samp{MMUX_LIBC_AF_INET} or @samp{MMUX_LIBC_AF_INET6}.

When successful, the resulting data structure is stored in the buffer referenced by
@var{ouput_addr_p}; when @var{input_af_family} equals:

@table @samp
@item MMUX_LIBC_AF_INET
The referenced buffer must be a data structure of type @objtype{mmux_libc_in_addr_t}.

@item MMUX_LIBC_AF_INET6
The referenced buffer must be a data structure of type @objtype{mmux_libc_insix_addr_t}.
@end table

Example:

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET, dotted_quad)) @{
  /* error */
@}
@end example

Example:

@example
mmux_asciizcp_t         presentation = "1:2:3:4:5:6:7:8";
mmux_libc_insix_addr_t  address;

if (mmux_libc_inet_pton(&address, MMUX_LIBC_AF_INET6, presentation)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_ntop (mmux_asciizp_t @var{ouput_presentation_p}, mmux_usize_t @var{ouput_presentation_provided_nchars}, mmux_sint_t @var{input_af_family}, mmux_pointer_t @var{input_addr_p})
@MmuxCInterface{inet_ntop}.

Convert the Internet address data structure referenced by @var{input_addr_p} in its @asciiz{}
presentation and copy it into the buffer referenced by @var{ouput_presentation_p}; the data
structure is expected to represent an address in the format specified by @var{input_af_family}, for
example @samp{MMUX_LIBC_AF_INET} or @samp{MMUX_LIBC_AF_INET6}; when @var{input_af_family} equals:

@table @samp
@item MMUX_LIBC_AF_INET
The referenced data structure must be of type @objtype{mmux_libc_in_addr_t}.

@item MMUX_LIBC_AF_INET6
The referenced data structure must be of type @objtype{mmux_libc_insix_addr_t}.
@end table

If the length of the @asciiz{} presentation, including its terminating nul, is less than or equal to
@var{ouput_presentation_provided_nchars}: the whole string, including its terminating nul, is
written in the output buffer; then the return value if @cfalse{}.  Otherwise nothing is written and
the return value is @ctrue{}.

Example:

@example
mmux_libc_in_addr_t     address;

if (mmux_libc_make_in_addr_broadcast(&address)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntop(str, IS_THIS_ENOUGH_QUESTION_MARK, MMUX_LIBC_AF_INET, &address)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example

Example:

@example
mmux_libc_insix_addr_t     address;

if (mmux_libc_make_insix_addr_loopback(&address)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntop(str, IS_THIS_ENOUGH_QUESTION_MARK, MMUX_LIBC_AF_INET6, &address)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_inet_aton (mmux_libc_in_addr_ptr_t @var{ouput_addr_p}, mmux_asciizcp_t @var{input_presentation_p})
@MmuxCInterface{inet_aton}.

Convert the dotted--quad @asciiz{} representation of an IPv4 address referenced by
@var{input_presentation_p} into a data structure of type @objtype{mmux_libc_in_addr_t}; store the
result in the data structure referenced by @var{ouput_addr_p}.

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_aton(&address, dotted_quad)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_ntoa (mmux_asciizp_t @var{ouput_presentation_p}, mmux_usize_t @var{ouput_presentation_provided_nchars}, mmux_libc_in_addr_t * @var{input_addr_p})
@MmuxCInterface{inet_ntoa}.

Convert the IPv4 address referenced by @var{input_addr_p} in its dotted--quad @asciiz{} presentation
and copy it into the buffer referenced by @var{ouput_presentation_p}.

If the length of the @asciiz{} presentation, including its terminating nul, is less than or equal to
@var{ouput_presentation_provided_nchars}: the whole string, including its terminating nul, is
written in the output buffer; then the return value if @cfalse{}.  Otherwise nothing is written and
the return value is @ctrue{}.

@example
mmux_libc_in_addr_t     in_addr;

if (mmux_libc_make_in_addr_broadcast(&in_addr)) @{
  /* error */
@}

@{
#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	32
  char  str[IS_THIS_ENOUGH_QUESTION_MARK];

  if (mmux_libc_inet_ntoa(str, IS_THIS_ENOUGH_QUESTION_MARK, &in_addr)) @{
    /* error */
  @}

  /* do something with the presentation in "str" */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_addr (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_asciizcp_t @var{presentation_in_addr_p})
@MmuxCInterface{inet_addr}.

If an error occurs: the location referenced by @var{result_in_addr_p} is left untouched; the return
value if @ctrue{}.

@example
mmux_asciizcp_t         dotted_quad = "127.0.0.1";
mmux_libc_in_addr_t     address;

if (mmux_libc_inet_addr(&address, dotted_quad)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_inet_network (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_asciizcp_t @var{presentation_in_addr_p})
@MmuxCInterface{inet_addr}.

If an error occurs: the location referenced by @var{result_in_addr_p} is left untouched; the return
value if @ctrue{}.
@end deftypefun


@deftypefun bool mmux_libc_inet_makeaddr (mmux_libc_in_addr_ptr_t @var{result_in_addr_p}, mmux_libc_in_addr_ptr_t @var{net_in_addr_p}, mmux_libc_in_addr_ptr_t @var{local_in_addr_p})
@MmuxCInterface{inet_makeaddr}.
@end deftypefun


@deftypefun bool mmux_libc_inet_lnaof (mmux_libc_in_addr_ptr_t @var{local_in_addr_p}, mmux_libc_in_addr_ptr_t @var{in_addr_p})
@MmuxCInterface{inet_lnaof}.
@end deftypefun


@deftypefun bool mmux_libc_inet_netof (mmux_libc_in_addr_ptr_t @var{net_in_addr_p}, mmux_libc_in_addr_ptr_t @var{in_addr_p})
@MmuxCInterface{inet_netof}.
@end deftypefun

@c page
@node sockets getaddrinfo
@section Getting address informations


Usage example:

@example
mmux_asciizcp_t                 node    = "localhost";
mmux_asciizcp_t                 service = "smtp";
mmux_libc_addrinfo_t            hints;

mmux_libc_addrinfo_ptr_t        addrinfo_linked_list_p;
mmux_sint_t                     error_code;

mmux_libc_ai_flags_set    (&hints, MMUX_LIBC_AI_V4MAPPED | MMUX_LIBC_AI_ADDRCONFIG | MMUX_LIBC_AI_CANONNAME);
mmux_libc_ai_family_set   (&hints, MMUX_LIBC_AF_UNSPEC);
mmux_libc_ai_socktype_set (&hints, MMUX_LIBC_SOCK_STREAM);
mmux_libc_ai_protocol_set (&hints, MMUX_LIBC_IPPROTO_TCP);

if (mmux_libc_getaddrinfo(&addrinfo_linked_list, &error_code, node, service, &hints)) @{
  mmux_asciizcp_t      error_message;

  mmux_libc_gai_strerror(&error_message, error_code);
  /* handle the error */
@} else @{
  /* do something with "addrinfo_linked_list_p" */

  mmux_libc_freeaddrinfo(addrinfo_linked_list_p);
@}
@end example


@deftypefun bool mmux_libc_getaddrinfo (mmux_libc_addrinfo_ptr_t * @var{result_addrinfo_linked_list_pp}, mmux_sint_t * @var{result_error_code_p}, mmux_asciizcp_t @var{node}, mmux_asciizcp_t @var{service}, mmux_libc_addrinfo_ptr_t @var{hints_p})
@MmuxCInterface{getaddrinfo}.
@end deftypefun


@deftypefun bool mmux_libc_freeaddrinfo (mmux_libc_addrinfo_ptr_t @var{addrinfo_linked_list_p})
@MmuxCInterface{freeaddrinfo}.
@end deftypefun


@deftypefun bool mmux_libc_gai_strerror (mmux_asciizcp_t * @var{result_error_message_p}, mmux_sint_t @var{errnum})
@MmuxCInterface{gai_strerror}.
@end deftypefun

@c page
@node sockets getnameinfo
@section Getting address name informations


Usage example:

@example
mmux_libc_sockaddr_in_t input_sockaddr;
mmux_sint_t             error_code;
mmux_sint_t             flags = 0;

#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	512
char                    hostname[IS_THIS_ENOUGH_QUESTION_MARK];
char                    servname[IS_THIS_ENOUGH_QUESTION_MARK];

gimme_an_address(&input_sockaddr);

if (mmux_libc_getnameinfo (hostname, IS_THIS_ENOUGH_QUESTION_MARK,
                           servname, IS_THIS_ENOUGH_QUESTION_MARK,
                           &error_code,
                           &input_sockaddr, sizeof(mmux_libc_sockaddr_in_t), flags)) @{
  mmux_asciizcp_t      error_message;

  mmux_libc_gai_strerror(&error_message, error_code);
  /* handle the error */
@} else @{
  /* do something with "hostname" and "servname" */
@}
@end example


@deftypefun bool mmux_libc_getnameinfo (mmux_asciizcp_t @var{result_hostname_p}, mmux_socklen_t @var{provided_hostname_len}, mmux_asciizcp_t @var{result_servname_p}, mmux_socklen_t @var{provided_servname_len}, mmux_sint_t * @var{result_error_code_p}, mmux_libc_sockaddr_ptr_t @var{input_sockaddr_p}, mmux_socklen_t @var{input_sockaddr_size}, mmux_sint_t @var{flags})
@MmuxCInterface{getnameinfo}.
@end deftypefun

@c page
@node sockets creating
@section Sockets: creating, pairs, shutting down, inspecting


@deftp {Opaque Typedef} mmux_libc_network_socket_t
An alias for @objtype{mmux_libc_file_descriptor_t} representing a networking socket.
@end deftp


@deftypefun bool mmux_libc_make_network_socket (mmux_libc_network_socket_t * @var{result_p}, mmux_sint_t @var{sock_num})
Initialise the value referenced by @var{result_p} with the given integer.
@end deftypefun


@deftypefun bool mmux_libc_socket (mmux_libc_network_socket_t * @var{result_sock_p}, mmux_sint_t @var{pf_namespace}, mmux_sint_t @var{sock_style}, mmux_sint_t @var{ipproto})
@MmuxCInterface{socket}.

@example
mmux_libc_network_socket_t      sock;

if (mmux_libc_socket(&sock, MMUX_LIBC_PF_INET, MMUX_LIBC_SOCK_STREAM, MMUX_LIBC_IPPROTO_TCP)) @{
  /* error */
@}

mmux_libc_shutdown(sock, MMUX_LIBC_SHUT_RDWR);
@end example
@end deftypefun


@deftypefun bool mmux_libc_shutdown (mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{shut_how})
@MmuxCInterface{shutdown}.
@end deftypefun


@deftypefun bool mmux_libc_socketpair (mmux_libc_network_socket_t * @var{result_sock1_p}, mmux_libc_network_socket_t * @var{result_sock2_p}, mmux_sint_t @var{pf_namespace}, mmux_sint_t @var{sock_style}, mmux_sint_t @var{ipproto})
@MmuxCInterface{socketpair}.

@example
mmux_libc_network_socket_t      sock1, sock2;

if (mmux_libc_socketpair(&sock1, &sock2, MMUX_LIBC_PF_LOCAL, MMUX_LIBC_SOCK_STREAM, MMUX_LIBC_IPPROTO_IP)) @{
  /* error */
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_getpeername (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t * @var{provided_sockaddr_size})
@MmuxCInterface{getpeername}.

@example
mmux_libc_network_socket_t      sock;
mmux_libc_sockaddr_t            sockaddr;
mmux_socklen_t                  sockaddr_size = sizeof(mmux_libc_sockaddr_t);

gimme_a_stream_sock(&sock);

if (mmux_libc_getpeername(sock, &sockaddr, &sockaddr_size)) @{
  /* error */
@}

/* do something with "sockaddr", whose real size is "sockaddr_size" */
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun bool mmux_libc_getsockname (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t * @var{provided_sockaddr_size})
@MmuxCInterface{getsockname}.

@example
mmux_libc_network_socket_t      sock;
mmux_libc_sockaddr_t            sockaddr;
mmux_socklen_t                  sockaddr_size = sizeof(mmux_libc_sockaddr_t);

gimme_a_stream_sock(&sock);

if (mmux_libc_getsockname(sock, &sockaddr, &sockaddr_size)) @{
  /* error */
@}

/* do something with "sockaddr", whose real size is "sockaddr_size" */
@end example
@end deftypefun

@c page
@node sockets stream
@section Sending and receiving data through a stream socket


@deftypefun bool mmux_libc_send (mmux_usize_t * @var{result_number_of_bytes_sent_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{send}.
@end deftypefun


@deftypefun bool mmux_libc_recv (mmux_usize_t * @var{result_number_of_bytes_received_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{recv}.
@end deftypefun

@c page
@node sockets server
@section Stream socket servers


@deftypefun bool mmux_libc_bind (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t @var{sockaddr_size})
@MmuxCInterface{bind}.
@end deftypefun


@deftypefun bool mmux_libc_listen (mmux_libc_network_socket_t @var{sock}, mmux_uint_t @var{pending_connections_queue_length}a)
@MmuxCInterface{listen}.
@end deftypefun


@deftypefun bool mmux_libc_accept (mmux_libc_network_socket_t * @var{result_connected_sock_p}, mmux_libc_sockaddr_ptr_t @var{result_client_sockaddr_p}, mmux_socklen_t * @var{result_client_sockaddr_size_p}, mmux_libc_network_socket_t @var{server_sock})
@MmuxCInterface{accept}.

@itemize
@item
Upon calling: the location referenced by @var{result_client_sockaddr_size_p} must be set to the
number of bytes allocated for the address referenced by @var{result_client_sockaddr_p}.

@item
Upon successfully returning: the location referenced by @var{result_client_sockaddr_size_p} is reset
to the actual size of the client address.
@end itemize
@end deftypefun


@deftypefn {Linux Function} bool mmux_libc_accept4 (mmux_libc_network_socket_t * @var{result_connected_sock_p}, mmux_libc_sockaddr_ptr_t @var{result_client_sockaddr_p}, mmux_socklen_t * @var{result_client_sockaddr_size_p}, mmux_libc_network_socket_t @var{server_sock}, mmux_sint_t @var{flags})
@MmuxCInterface{accept4}.

@itemize
@item
Upon calling: the location referenced by @var{result_client_sockaddr_size_p} must be set to the
number of bytes allocated for the address referenced by @var{result_client_sockaddr_p}.

@item
Upon successfully returning: the location referenced by @var{result_client_sockaddr_size_p} is reset
to the actual size of the client address.
@end itemize
@end deftypefn

@c page
@node sockets client
@section Stream socket clients


@deftypefun bool mmux_libc_connect (mmux_libc_network_socket_t @var{sock}, mmux_libc_sockaddr_ptr_t @var{sockaddr_p}, mmux_socklen_t @var{sockaddr_size})
@MmuxCInterface{connect}.
@end deftypefun

@c page
@node sockets dgram
@section Sending and receiving data through a datagram socket


@deftypefun bool mmux_libc_sendto (mmux_usize_t * @var{result_number_of_bytes_sent_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags}, mmux_libc_sockaddr_ptr_t @var{destination_sockaddr_p}, mmux_socklen_t @var{destination_sockaddr_size})
@MmuxCInterface{sendto}.
@end deftypefun


@deftypefun bool mmux_libc_recvfrom (mmux_usize_t * @var{result_number_of_bytes_received_p}, mmux_libc_sockaddr_ptr_t @var{result_sender_sockaddr_p}, mmux_socklen_t * @var{result_sender_sockaddr_size_p}, mmux_libc_network_socket_t @var{sock}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_sint_t @var{flags})
@MmuxCInterface{recvfrom}.

The arguments @var{result_sender_sockaddr_p} and @var{result_sender_sockaddr_size_p} can be
@cnull{} if we are not interested in retrieving the sender address; if they are not @cnull{}:

@itemize
@item
Upon entering the call: the location referenced by @var{result_sender_sockaddr_size_p} must be set
to the number of bytes allocated to contain the sender address.

@item
Upon successfully returning from the call: the location referenced by
@var{result_sender_sockaddr_size_p} is reset to the actual number of bytes required to contain the
sender address.
@end itemize
@end deftypefun

@c page
@node sockets options
@section Socket options


@MmuxCStructOpaqueTypedef{linger}
@MmuxCStructPointerOpaqueTypedef{linger}
@MmuxSetterGetter{linger, l_onoff,		mmux_sint_t}
@MmuxSetterGetter{linger, l_linger,		mmux_sint_t}
@MmuxStructDumper{linger}


@deftypefun bool mmux_libc_getsockopt (mmux_pointer_t @var{result_optval_p}, mmux_socklen_t * @var{result_optlen_p}, mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{level}, mmux_sint_t @var{optname})
@MmuxCInterface{getsockopt}.
@end deftypefun


@deftypefun bool mmux_libc_setsockopt (mmux_libc_network_socket_t @var{sock}, mmux_sint_t @var{level}, mmux_sint_t @var{optname}, mmux_pointer_t @var{optval_p}, mmux_socklen_t @var{optlen})
@MmuxCInterface{setsockopt}.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
the package @mmux{} CC Types is available online:

@center @url{https://github.com/marcomaggi/mmux-cc-types/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

